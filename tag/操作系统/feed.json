{
    "version": "https://jsonfeed.org/version/1",
    "title": "意大利炮打友军 • All posts by \"操作系统\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "url": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "title": "操作系统学习笔记2：多线程",
            "date_published": "2024-03-22T09:44:11.000Z",
            "content_html": "<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>现代软件大多支持多线程，相比于进程切换，线程共享代码段，数据段以及其他系统资源，但是拥有单独的寄存器和堆栈。<br>服务器采用多线程，可以减少创建进程的资源消耗，同时处理多个并发请求。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>响应性提高</li>\n<li>资源共享</li>\n<li>创建与切换更加经济</li>\n</ul>\n<h2 id=\"多核编程\"><a href=\"#多核编程\" class=\"headerlink\" title=\"多核编程\"></a>多核编程</h2><p>并行性 vs 并发性<br><strong>并行性</strong>：是同时执行多个任务<br><strong>并发性</strong>：是让每个任务都能取得进展，在单处理器上也能实现</p>\n<p>Amdahl定理：程序中只有S%可以串行执行时，优化比<br>$$\\eta \\leq \\frac{1}{S+\\frac{1-S}{N}}$$</p>\n<h3 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h3><ul>\n<li>分析一个任务是否可以多核</li>\n<li>平衡某些任务适合单独核心执行</li>\n<li>数据分割</li>\n<li>数据依赖，避免同步性受损</li>\n<li>调试程序</li>\n</ul>\n<h3 id=\"并行类型\"><a href=\"#并行类型\" class=\"headerlink\" title=\"并行类型\"></a>并行类型</h3>",
            "tags": [
                "技术",
                "博客",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "url": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "title": "操作系统学习笔记1",
            "date_published": "2024-03-22T07:52:53.000Z",
            "content_html": "<h2 id=\"内核设计\"><a href=\"#内核设计\" class=\"headerlink\" title=\"内核设计\"></a>内核设计</h2><h3 id=\"微内核\"><a href=\"#微内核\" class=\"headerlink\" title=\"微内核\"></a>微内核</h3><p>微内核实现了一个功能较少，但是容易扩展的内核架构，客户程序和不同的功能之间提供<strong>消息传递</strong>功能。除了必须内核功能外，功能组件都作为用户程序来实现。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>例如Solaris，有7种可以在运行时加载的模块。</p>\n<h3 id=\"混合架构例子\"><a href=\"#混合架构例子\" class=\"headerlink\" title=\"混合架构例子\"></a>混合架构例子</h3><ul>\n<li>MacOS X，其Mach内核提供了远程过程调用，进程间通信等功能。BSD内核提供了POSIX库和文件系统等功能。</li>\n<li>iOS基于MacOSX，在系统的顶层提供了媒体服务用来支持图形化，Cocoa Touch库提供了有触屏硬件支持的Objective-C API</li>\n<li>Android由Linux内核，增加了一套Dalvik虚拟机和核心库。采用基于Java的Android API用来进行Java开发。运行在Dalvik虚拟机。</li>\n</ul>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><h3 id=\"D-Trace\"><a href=\"#D-Trace\" class=\"headerlink\" title=\"D Trace\"></a>D Trace</h3><p>使用D语言</p>\n<p>这个工具可以动态探测运行系统。跟踪系统调用以及指令的运行环境（用户or内核）<br>DTrace提供内核探头，拥有内核运行的编译器，生成安全指令。通过调用创建的内核探头，执行<strong>启用控制块</strong>可以捕获一些数据。</p>\n<h2 id=\"操作系统生成\"><a href=\"#操作系统生成\" class=\"headerlink\" title=\"操作系统生成\"></a>操作系统生成</h2><p>SYSGEN程序用于配置和生成操作系统。系统安装可以有三种情况</p>\n<ul>\n<li>极端定制：修改源代码，重新编译系统生成</li>\n<li>极端通用：系统描述表已定义好安装的模块，直接激活</li>\n<li>折中：选择模块进行链接来生成</li>\n</ul>\n<h2 id=\"编程实例\"><a href=\"#编程实例\" class=\"headerlink\" title=\"编程实例\"></a>编程实例</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>头文件：</p>\n<ul>\n<li>linux&#x2F;init.h</li>\n<li>linux&#x2F;kernel.h</li>\n<li>linux.model.h</li>\n</ul>\n<p>重要函数：</p>\n<ul>\n<li>printk：存储到内核日志缓冲区，用dmesg访问，可以指定优先级</li>\n<li>module_init() &amp; module_exit():用于注册模块。</li>\n</ul>\n<p>编译好的内核模块，使用sudo insmod simple.ko来插入内核<br>使用sudo ramos simple来移除</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>kmalloc：分配内核内存 </p>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h2><p>进程是一个活动实体，包含代码、程序计数器、堆栈等。</p>\n<h3 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h3><p>包括：</p>\n<ul>\n<li>新进程：创建进程</li>\n<li>运行中：指令执行中</li>\n<li>等待：进程等待某个信号</li>\n<li>就绪：等待分配处理器</li>\n<li>终止：进程已完成</li>\n</ul>\n<h3 id=\"进程控制块\"><a href=\"#进程控制块\" class=\"headerlink\" title=\"进程控制块\"></a>进程控制块</h3><p>存储了一个进程的相关信息：</p>\n<ul>\n<li>进程状态</li>\n<li>程序计数器</li>\n<li>CPU寄存器</li>\n<li>CPU调度信息</li>\n<li>内存管理信息</li>\n<li>记账信息</li>\n<li>IO状态信息</li>\n</ul>\n<p>信息采用task_struct来表示，位于&lt;linux&#x2F;sched.h&gt;<br>这个结构还存储了父进程、子进程等。<br>linux系统使用一个current_state结构来指向当前运行的进程。</p>\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p>被加载运行的进程，进入<strong>任务队列</strong>，在内存中等待运行的就是<strong>就绪队列</strong>，等待IO的进程就放在对应的<strong>设备队列</strong>。</p>\n<p>对于整个流程，进程首先被创建，加入到就绪队列，之后被分配到CPU执行时，会有几种可能：</p>\n<ul>\n<li>发出IO请求，进入IO队列</li>\n<li>创建子进程，等待进程执行结束</li>\n<li>中断产生，被放回就绪队列</li>\n</ul>\n<h3 id=\"调度程序\"><a href=\"#调度程序\" class=\"headerlink\" title=\"调度程序\"></a>调度程序</h3><p>调度程序分为短期调度程序和长期调度程序。</p>\n<ul>\n<li>短期调度程序针对的程序IO请求频繁，决策时间较短。</li>\n<li>长期调度程序的创建和杀死速度都较慢，因此有更多时间进行调度。</li>\n</ul>\n<p>长期调度程序应选择IO于CPU密集型程序并重的进程。</p>\n<h3 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h3><p>切换进程需要切换状态，典型时间为几毫秒。</p>\n<h2 id=\"进程运行\"><a href=\"#进程运行\" class=\"headerlink\" title=\"进程运行\"></a>进程运行</h2><p>进程可以产生子进程，因此其组织结构是“树”。init进程是pid为1的进程</p>\n<p>重要的init子进程：</p>\n<ul>\n<li>kthreadd：创建额外内核进程。</li>\n<li>sshd：创建ssh连接</li>\n</ul>\n<p>ps -el 列出进程</p>\n<p>fork（）函数创建一个子进程，子进程复制父进程的地址空间。它们都执行fork之后的内容。父进程fork（）返回子进程pid。子进程返回0。父进程可能会需要wait子进程。</p>\n<p>注意：windows的createProcess函数不继承父进程空间，而是需要制定一个特定程序。</p>\n<p>父进程可以调用wait，让子进程（僵尸进程）标识符得到释放。并且如果父进程先被终止，如果没有级连终止的要求下，init进程成为子进程的父。</p>\n<h2 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2><p>进程和其他进程通信称为协作。进程间协作机制称为IPC，IPC有两种基本模型：<strong>共享内存</strong>和<strong>消息传递</strong></p>\n<p>目前，在多核系统上，共享内存机制由于高速缓存的不一致性，性能要差于消息传递。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存区域驻留在创建共享内存段的进程内。并且负责确保内存不会被同时写入。<br>共享内存有一个循环数组，用于共享进程发送信息的缓冲。</p>\n<h3 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h3><p>消息传递需要至少提供send()和receive()两个操作。这样要考虑几个问题：</p>\n<ul>\n<li>直接or间接通信</li>\n<li>同步or异步</li>\n<li>自动or显式缓冲</li>\n</ul>\n<h4 id=\"通信的直接or间接\"><a href=\"#通信的直接or间接\" class=\"headerlink\" title=\"通信的直接or间接\"></a>通信的直接or间接</h4><p>采用直接通信的send()和receive()都需要直接指定接收方的地址，可能是对称或非对称的（非对称即接收方只能接受向其发送的进程信息）</p>\n<p>间接通信的方法则通过邮箱或端口来发送信息。通过把邮箱抽象为一个对象，这种方式有如下特点：</p>\n<ul>\n<li>共享邮箱才能建立链路</li>\n<li>一个链路与多个进程关联</li>\n<li>两个进程之间可以有多个链路<br>但是一个消息只能被一个进程接收<br>邮箱可以为系统或进程拥有，进程拥有的邮箱必须要确定所有者和使用者。所有者只能接受信息，使用者只能发送信息。<br>进程被终止后，邮箱将消失。操作系统的邮箱是独立存在的。操作系统提供机制允许进程进行创建、删除、使用邮箱。而且通过系统调用，邮箱的所有权可以传给其他进程。</li>\n</ul>\n<h4 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h4><p>关于消息传递的同步性，有以下四种可能：</p>\n<ul>\n<li>阻塞发送：发送消息后，直到被接收，进程都将阻塞</li>\n<li>非阻塞发送：发送后继续操作</li>\n<li>阻塞接收：阻塞进程，直到能接收信息</li>\n<li>非阻塞接收：接收进程收到有效信息或空信息</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>缓存有三种形式：</p>\n<ul>\n<li>零容量：要求发送者应当阻塞发送，因为消息队列不能等待。</li>\n<li>有限容量：最多n条消息可以等待，超过这个数量时进程将阻塞</li>\n<li>无限容量：进程不会阻塞发送</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"posix\"><a href=\"#posix\" class=\"headerlink\" title=\"posix\"></a>posix</h4><p>posix通过内存映射文件共享内存，通过系统调用shm_open(name,O_CREAT|O_RDRW,0666)函数来创建共享内存对象。<br>创建成功后，函数ftruncate(shm_fd,4096)用于配置对象的大小（4096字节）<br>最后，mmap()函数用于将内存映射文件包含共享内存。返回ptr<br>使用sprintf()将message写入ptr。<br>最终消费者使用了共享内存后，调用shm_unlink()移除共享内存</p>\n<h4 id=\"Mach\"><a href=\"#Mach\" class=\"headerlink\" title=\"Mach\"></a>Mach</h4><p>Mach通过消息传递（采用邮箱）实现<br>包括两个邮箱：内核邮箱和通知邮箱。调用msg_send()来发送消息，msg_receive()接收消息，msg_rpc()用来进行远程过程调用。<br>系统调用port_allocate()来创建新邮箱。可以指定最大排队信息，而且消息复制到邮箱中可以保证单个发送者的顺序统一。<br>发送消息如果遇到邮箱满了，可能会等待（无限或n毫秒），或者立刻返回，或者在操作系统中为一个线程存储一个消息。<br>邮箱可以形成一个邮箱集合来服务单个任务。port_status()用于返回指定邮箱的消息数量。<br>Mach本来是为了分布式系统设计，但是为了多核系统，Mach也可以使用虚拟内存，把发送者地址空间映射到接收者地址空间，来提高性能。</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>windows支持多个操作环境或子系统，应用程序通过消息传递来通信。Windows使用ALPC工具来进行进程间通信。<br>类似于TCP连接，Windows内部也使用了<strong>连接端口</strong>和<strong>通信端口</strong>区分的思想。此外，通信回调机制允许服务器和客户端在等待时也能响应接受请求。<br>这个机制包含三种技术：</p>\n<ul>\n<li>对于小消息，采用消息队列进行存储，复制传递</li>\n<li>对于大消息（256字节+）：采用区段对象传递，为共享内存。</li>\n<li>对于巨大消息，采用API直接读写目标地址空间。</li>\n</ul>\n<p>注意：ALPC不属于WinAPI</p>\n<h3 id=\"服务器和客户端通信\"><a href=\"#服务器和客户端通信\" class=\"headerlink\" title=\"服务器和客户端通信\"></a>服务器和客户端通信</h3><h4 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字\"></a>套接字</h4><p>详见计算机网络</p>\n<h4 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h4><p>RPC：远程过程调用</p>\n<p>RPC和套接字不同，具有明确的数据结构。和本地调用过程相似，RPC隐藏了远程调用的通信细节。<br>对于每个远程过程，客户端都有一个存根用来调用服务器端口，并传递参数。返回值也可以传递回客户端。<br>通过时间戳，系统可以避免RPC被重复执行。而且还需要和客户确认RPC调用已经收到且执行。这要求客户机实现RPC调用的发送后接收到ACK信息。<br>使用交会服务程序，可以让客户请求RPC的端口灵活分配。<br>RPC可用于实现分布式文件系统</p>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><p>管道是一个半双工的结构<br>分为<strong>普通管道</strong>和<strong>命名管道</strong><br>UNIX上，管道采用pipe(int fd[])函数来创建，fd[0]为读出端，fd[1]为写入端<br>父子进程通信可以使用管道来进行，因为子进程继承了夫进程的管道，他们共享一个管道但是有两个fd。但是普通管道需要在同一机器上有父子关系的进程。</p>\n<p>命名管道：提供了一个双向的，不必须父子关系的，多进程通信的管道。<br>而且通信结束后，管道依旧存在。</p>\n<ul>\n<li><p>对于UNIX，管道通过mkfifo()系统调用来进行。通过调用对文件的读写函数来进行常规读写。只有显式删除才会关闭管道。这是半双工且单机通信的，除非用套接字来进行远程通信。</p>\n</li>\n<li><p>对于Windows，CreateNamedPipe()支持创建全双工且支持远程的通信。</p>\n</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "操作系统"
            ]
        }
    ]
}