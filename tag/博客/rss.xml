<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>意大利炮打友军 • Posts by &#34;博客&#34; tag</title>
        <link>http://example.com</link>
        <description></description>
        <language>zh-CN</language>
        <pubDate>Tue, 26 Mar 2024 19:54:58 +0800</pubDate>
        <lastBuildDate>Tue, 26 Mar 2024 19:54:58 +0800</lastBuildDate>
        <category>随笔</category>
        <category>技术</category>
        <category>大模型训练</category>
        <category>课题组</category>
        <category>笔记</category>
        <category>博客</category>
        <category>markdown</category>
        <category>Linux</category>
        <category>月历</category>
        <category>写作</category>
        <category>科幻</category>
        <category>世界观</category>
        <category>python</category>
        <category>WSL</category>
        <category>编译</category>
        <category>通信</category>
        <category>操作系统</category>
        <category>电赛</category>
        <category>周报</category>
        <category>神经网络</category>
        <category>pytorch</category>
        <category>记录</category>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B02/</guid>
            <title>大模型通信笔记2</title>
            <link>http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B02/</link>
            <category>技术</category>
            <category>大模型训练</category>
            <category>博客</category>
            <category>通信</category>
            <pubDate>Tue, 26 Mar 2024 19:54:58 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;数据并行&#34;&gt;&lt;a href=&#34;#数据并行&#34; class=&#34;headerlink&#34; title=&#34;数据并行&#34;&gt;&lt;/a&gt;数据并行&lt;/h2&gt;&lt;p&gt;传统的数据并行是让每个GPU分别进行FWD和BWD，然后把梯度进行聚合操作，然后再下发给每个GPU，称为All Reduce。&lt;/p&gt;
&lt;h3 id=&#34;缺点&#34;&gt;&lt;a href=&#34;#缺点&#34; class=&#34;headerlink&#34; title=&#34;缺点&#34;&gt;&lt;/a&gt;缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;存储开销大。每块GPU上都存了一份完整的模型，造成冗余&lt;/li&gt;
&lt;li&gt;通讯开销大。Server需要和每一个Worker进行梯度传输。当Server和Worker不在一台机器上时，Server的带宽将会成为整个系统的计算效率瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异步梯度更新&#34;&gt;&lt;a href=&#34;#异步梯度更新&#34; class=&#34;headerlink&#34; title=&#34;异步梯度更新&#34;&gt;&lt;/a&gt;异步梯度更新&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Worker不等待梯度更新，用旧的参数进行下一轮训练，可能会延迟一步更新梯度，整体收敛速度变慢，但是提升通讯计算比。&lt;/li&gt;
&lt;li&gt;延迟步数会指定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布式数据并行&#34;&gt;&lt;a href=&#34;#分布式数据并行&#34; class=&#34;headerlink&#34; title=&#34;分布式数据并行&#34;&gt;&lt;/a&gt;分布式数据并行&lt;/h3&gt;&lt;p&gt;核心目标是降低通信压力，因此要将Server的通信压力转到Worker上，最简单的就是Ring-AllReduce。&lt;/p&gt;
&lt;h4 id=&#34;Ring-Allreduce&#34;&gt;&lt;a href=&#34;#Ring-Allreduce&#34; class=&#34;headerlink&#34; title=&#34;Ring Allreduce&#34;&gt;&lt;/a&gt;Ring Allreduce&lt;/h4&gt;&lt;p&gt;核心思路是实现Reduce Scatter和All-Gather。GPU每次之和前后两个GPU通信，1卡给2卡发a号数据，2给3发b号，以此类推。三次更新后每张卡都有1个号的完整的数据。&lt;/p&gt;
&lt;p&gt;之后在进行All-Gather，依旧环形通信，把每个部分全聚合的都发给下一个，然后依此类推，3轮通信就可以覆盖所有。&lt;/p&gt;
&lt;h2 id=&#34;显存开销&#34;&gt;&lt;a href=&#34;#显存开销&#34; class=&#34;headerlink&#34; title=&#34;显存开销&#34;&gt;&lt;/a&gt;显存开销&lt;/h2&gt;&lt;p&gt;数据并行中，每个卡都存储了所有参数，怎么办？&lt;/p&gt;
&lt;p&gt;在实际存储中，分为两部分存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型状态：包括参数，优化器，梯度等&lt;/li&gt;
&lt;li&gt;驻留数据：包括activation，碎片内存和缓冲区等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优化措施&#34;&gt;&lt;a href=&#34;#优化措施&#34; class=&#34;headerlink&#34; title=&#34;优化措施&#34;&gt;&lt;/a&gt;优化措施&lt;/h2&gt;&lt;h3 id=&#34;混合精度训练&#34;&gt;&lt;a href=&#34;#混合精度训练&#34; class=&#34;headerlink&#34; title=&#34;混合精度训练&#34;&gt;&lt;/a&gt;混合精度训练&lt;/h3&gt;&lt;p&gt;对于参数，activation，梯度，都使用fp16，对于参数（多存一份）和优化器使用fp32。&lt;br&gt;模型必存数据为$K\phi$,那么最终总存储数据为$K\phi + 4\phi$&lt;br&gt;实际上，activation大小和batch有关，而且是可以抛弃的。&lt;/p&gt;
&lt;h3 id=&#34;ZeRO-DP&#34;&gt;&lt;a href=&#34;#ZeRO-DP&#34; class=&#34;headerlink&#34; title=&#34;ZeRO-DP&#34;&gt;&lt;/a&gt;ZeRO-DP&lt;/h3&gt;&lt;h4 id=&#34;第一步：优化器分割&#34;&gt;&lt;a href=&#34;#第一步：优化器分割&#34; class=&#34;headerlink&#34; title=&#34;第一步：优化器分割&#34;&gt;&lt;/a&gt;第一步：优化器分割&lt;/h4&gt;&lt;p&gt;每张卡只存储一部分优化器参数，在数据并行中，先通过AllReduce得到完整梯度，每个卡都更新自己的一部分梯度和参数，然后再AllGather。产生单卡通讯量$\phi$。&lt;/p&gt;
&lt;h4 id=&#34;第二步：梯度分割&#34;&gt;&lt;a href=&#34;#第二步：梯度分割&#34; class=&#34;headerlink&#34; title=&#34;第二步：梯度分割&#34;&gt;&lt;/a&gt;第二步：梯度分割&lt;/h4&gt;&lt;p&gt;经过FWD和BWD后，对梯度进行Reduce-Scatter，保证每张卡都有自己一份聚合梯度，用分割的优化器和梯度进行更新相应的W，然后再AllGather参数进行更新&lt;/p&gt;
&lt;h4 id=&#34;第三步：参数分割&#34;&gt;&lt;a href=&#34;#第三步：参数分割&#34; class=&#34;headerlink&#34; title=&#34;第三步：参数分割&#34;&gt;&lt;/a&gt;第三步：参数分割&lt;/h4&gt;&lt;p&gt;FWD时，先All Gather一次参数，用完即弃。&lt;br&gt;BWD时，再All Gather一次参数，用完即弃&lt;br&gt;用自己的梯度进行一次All Gather得到完整梯度&lt;br&gt;更新参数，无需通信。&lt;/p&gt;
&lt;h3 id=&#34;ZeRO-R&#34;&gt;&lt;a href=&#34;#ZeRO-R&#34; class=&#34;headerlink&#34; title=&#34;ZeRO-R&#34;&gt;&lt;/a&gt;ZeRO-R&lt;/h3&gt;&lt;p&gt;通过对驻留数据进行优化来实现显存使用减少和通信负载降低。&lt;/p&gt;
&lt;h4 id=&#34;activation&#34;&gt;&lt;a href=&#34;#activation&#34; class=&#34;headerlink&#34; title=&#34;activation&#34;&gt;&lt;/a&gt;activation&lt;/h4&gt;&lt;p&gt;每块GPU上只维护部分的activation，需要时再聚合。或者重新计算。&lt;/p&gt;
&lt;h4 id=&#34;Buffer&#34;&gt;&lt;a href=&#34;#Buffer&#34; class=&#34;headerlink&#34; title=&#34;Buffer&#34;&gt;&lt;/a&gt;Buffer&lt;/h4&gt;&lt;p&gt;通过使用固定大小的Buffer，降低通信次数，减少碎片信息发送，提高带宽利用率&lt;/p&gt;
&lt;h4 id=&#34;碎片内存整合&#34;&gt;&lt;a href=&#34;#碎片内存整合&#34; class=&#34;headerlink&#34; title=&#34;碎片内存整合&#34;&gt;&lt;/a&gt;碎片内存整合&lt;/h4&gt;&lt;h3 id=&#34;ZeRO-Offload&#34;&gt;&lt;a href=&#34;#ZeRO-Offload&#34; class=&#34;headerlink&#34; title=&#34;ZeRO-Offload&#34;&gt;&lt;/a&gt;ZeRO-Offload&lt;/h3&gt;&lt;p&gt;见论文，主要是把显存的优化器参数卸载到CPU内存。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</guid>
            <title>linux学习笔记3</title>
            <link>http://example.com/2024/03/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</link>
            <category>技术</category>
            <category>博客</category>
            <category>Linux</category>
            <pubDate>Tue, 26 Mar 2024 19:14:15 +0800</pubDate>
            <description><![CDATA[  ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B01/</guid>
            <title>大模型通信笔记1</title>
            <link>http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B01/</link>
            <category>技术</category>
            <category>大模型训练</category>
            <category>博客</category>
            <category>通信</category>
            <pubDate>Tue, 26 Mar 2024 17:38:32 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;流水线并行&#34;&gt;&lt;a href=&#34;#流水线并行&#34; class=&#34;headerlink&#34; title=&#34;流水线并行&#34;&gt;&lt;/a&gt;流水线并行&lt;/h2&gt;&lt;h3 id=&#34;朴素层并行&#34;&gt;&lt;a href=&#34;#朴素层并行&#34; class=&#34;headerlink&#34; title=&#34;朴素层并行&#34;&gt;&lt;/a&gt;朴素层并行&lt;/h3&gt;&lt;p&gt;朴素层并行，将模型拆分为多个层，放在不同的GPU上执行&lt;br&gt;但是问题很明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GPU利用率低：任意时刻只有一个GPU在工作，其他GPU都在等待结果&lt;/li&gt;
&lt;li&gt;计算和通信没有重叠&lt;/li&gt;
&lt;li&gt;显存占用高，GPU1需要保存所有激活。等待参数更新完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;GPipe&#34;&gt;&lt;a href=&#34;#GPipe&#34; class=&#34;headerlink&#34; title=&#34;GPipe&#34;&gt;&lt;/a&gt;GPipe&lt;/h3&gt;&lt;p&gt;Gpipe将整个&lt;strong&gt;minibatch分为4个microbatch&lt;/strong&gt;，然后由GPU0进行计算，之后每个microbatch计算完直接传递给GPU1，以此类推，进行整个前向、反向传播。&lt;br&gt;假设pipeline深度n，microbatch数量m，那么浪费的时间占比为：&lt;br&gt;$$&lt;br&gt;1-\frac{m}{m+n-1}&lt;br&gt;$$&lt;br&gt;所以需要增加microbatch数量m&lt;br&gt;Gpipe在计算过程中，把中间激活用完即弃，因此节省了显存，但是增加了计算代价。&lt;/p&gt;
&lt;h3 id=&#34;PipeDream&#34;&gt;&lt;a href=&#34;#PipeDream&#34; class=&#34;headerlink&#34; title=&#34;PipeDream&#34;&gt;&lt;/a&gt;PipeDream&lt;/h3&gt;&lt;p&gt;PipeDream在GPipe的基础上，在每个microbatch前向结束后就开始反向传播，节省了一些显存，bubble和Gpipe是一样的&lt;/p&gt;
&lt;h3 id=&#34;数据并行可以和流水线并行同时进行&#34;&gt;&lt;a href=&#34;#数据并行可以和流水线并行同时进行&#34; class=&#34;headerlink&#34; title=&#34;数据并行可以和流水线并行同时进行&#34;&gt;&lt;/a&gt;数据并行可以和流水线并行同时进行&lt;/h3&gt;&lt;p&gt;对任意给定GPU，有两个通信部份，一部分包含所有相同层GPU进行All_Reduce(数据并行)。另一部分和上下层进行通信（流水线）。&lt;/p&gt;
&lt;h2 id=&#34;张量并行&#34;&gt;&lt;a href=&#34;#张量并行&#34; class=&#34;headerlink&#34; title=&#34;张量并行&#34;&gt;&lt;/a&gt;张量并行&lt;/h2&gt;&lt;p&gt;张量并行分为两种情况：&lt;strong&gt;列划分&lt;/strong&gt;和&lt;strong&gt;行划分&lt;/strong&gt;&lt;br&gt;列划分：&lt;br&gt;$$&lt;br&gt;XA &amp;#x3D; X[A_1,A_2···A_n]&amp;#x3D;[XA_1,XA_2,···,XA_n]&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;行划分：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\mathbf{x}*A &amp;#x3D; \begin{bmatrix} x_1 &amp;amp; x_2 &amp;amp; \cdots &amp;amp; x_n \end{bmatrix} * \begin{bmatrix}A_1\A_2\A_3\··· \A_n\end{bmatrix}&amp;#x3D;X_1A_1+X_2A_2+X_3A_3···&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;对列并行来说，由于GeLU函数并不是线性的，因此需要在输出前进行一次通信来合并。&lt;/p&gt;
&lt;h3 id=&#34;2D并行&#34;&gt;&lt;a href=&#34;#2D并行&#34; class=&#34;headerlink&#34; title=&#34;2D并行&#34;&gt;&lt;/a&gt;2D并行&lt;/h3&gt;&lt;p&gt;具体来说，两个矩阵的结果仍然需要串行的计算。但是，单个矩阵中的4个子矩阵可以使用2*2的处理器来并行计算。&lt;/p&gt;
&lt;h3 id=&#34;2-5D并行&#34;&gt;&lt;a href=&#34;#2-5D并行&#34; class=&#34;headerlink&#34; title=&#34;2.5D并行&#34;&gt;&lt;/a&gt;2.5D并行&lt;/h3&gt;&lt;p&gt;这个就是在2D并行的基础上，左矩阵为两个2*2矩阵垂直拼接，那么这两个矩阵是可以分开计算的，所以可以8处理器并行计算。&lt;/p&gt;
&lt;h2 id=&#34;3D并行&#34;&gt;&lt;a href=&#34;#3D并行&#34; class=&#34;headerlink&#34; title=&#34;3D并行&#34;&gt;&lt;/a&gt;3D并行&lt;/h2&gt;&lt;p&gt;流水线+数据+张量并行&lt;/p&gt;
&lt;p&gt;首先，每个节点8个GPU，共两个节点&lt;/p&gt;
&lt;p&gt;8个GPU，分为两组，每组负责一个Layer，一共四个组进行流水线并行。&lt;br&gt;每个组内，用两张卡进行张量并行，一个组分为两个张量小组。一个张量小组负责一个具体的张量运算。&lt;br&gt;对于两个张量小组之间，分享同一个batch不同的数据，在计算结束后两个小组之间要进行all reduce通信。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</guid>
            <title>操作系统学习笔记2：多线程</title>
            <link>http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</link>
            <category>技术</category>
            <category>博客</category>
            <category>操作系统</category>
            <pubDate>Fri, 22 Mar 2024 17:44:11 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;现代软件大多支持多线程，相比于进程切换，线程共享代码段，数据段以及其他系统资源，但是拥有单独的寄存器和堆栈。&lt;br&gt;服务器采用多线程，可以减少创建进程的资源消耗，同时处理多个并发请求。&lt;/p&gt;
&lt;h3 id=&#34;优点&#34;&gt;&lt;a href=&#34;#优点&#34; class=&#34;headerlink&#34; title=&#34;优点&#34;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;响应性提高&lt;/li&gt;
&lt;li&gt;资源共享&lt;/li&gt;
&lt;li&gt;创建与切换更加经济&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多核编程&#34;&gt;&lt;a href=&#34;#多核编程&#34; class=&#34;headerlink&#34; title=&#34;多核编程&#34;&gt;&lt;/a&gt;多核编程&lt;/h2&gt;&lt;p&gt;并行性 vs 并发性&lt;br&gt;&lt;strong&gt;并行性&lt;/strong&gt;：是同时执行多个任务&lt;br&gt;&lt;strong&gt;并发性&lt;/strong&gt;：是让每个任务都能取得进展，在单处理器上也能实现&lt;/p&gt;
&lt;p&gt;Amdahl定理：程序中只有S%可以串行执行时，优化比&lt;br&gt;$$\eta \leq \frac{1}{S+\frac{1-S}{N}}$$&lt;/p&gt;
&lt;h3 id=&#34;挑战&#34;&gt;&lt;a href=&#34;#挑战&#34; class=&#34;headerlink&#34; title=&#34;挑战&#34;&gt;&lt;/a&gt;挑战&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;分析一个任务是否可以多核&lt;/li&gt;
&lt;li&gt;平衡某些任务适合单独核心执行&lt;/li&gt;
&lt;li&gt;数据分割&lt;/li&gt;
&lt;li&gt;数据依赖，避免同步性受损&lt;/li&gt;
&lt;li&gt;调试程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并行类型&#34;&gt;&lt;a href=&#34;#并行类型&#34; class=&#34;headerlink&#34; title=&#34;并行类型&#34;&gt;&lt;/a&gt;并行类型&lt;/h3&gt;&lt;p&gt;分为数据并行（把一个任务的不同部分数据分配到不同核心）&lt;br&gt;和任务并行（把多个任务分配到不同核心）&lt;/p&gt;
&lt;h2 id=&#34;多线程模型&#34;&gt;&lt;a href=&#34;#多线程模型&#34; class=&#34;headerlink&#34; title=&#34;多线程模型&#34;&gt;&lt;/a&gt;多线程模型&lt;/h2&gt;&lt;p&gt;线程支持有两种方案：&lt;strong&gt;用户线程&lt;/strong&gt;和&lt;strong&gt;内核线程&lt;/strong&gt;。用户和内核线程有多重关系模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多对一模型&lt;ul&gt;
&lt;li&gt;一个内核对应多个用户线程&lt;/li&gt;
&lt;li&gt;线程被用户空间库管理&lt;/li&gt;
&lt;li&gt;效率高&lt;/li&gt;
&lt;li&gt;一个线程阻塞整个进程都会阻塞&lt;/li&gt;
&lt;li&gt;同时只有一个线程访问内核，不支持并行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一对一模型&lt;ul&gt;
&lt;li&gt;相比于多对一，一对一对并行的支持更好&lt;/li&gt;
&lt;li&gt;但是系统内核线程会影响性能&lt;/li&gt;
&lt;li&gt;Linux Windows都实现了这个模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多对多模型  &lt;ul&gt;
&lt;li&gt;对这个模型而言，创建多个用户线程同时保持高性能并发是可能的&lt;/li&gt;
&lt;li&gt;一个变体是允许多对多模型和一对一模型同时存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程库&#34;&gt;&lt;a href=&#34;#线程库&#34; class=&#34;headerlink&#34; title=&#34;线程库&#34;&gt;&lt;/a&gt;线程库&lt;/h2&gt;&lt;p&gt;  线程库的实现，有&lt;strong&gt;纯用户空间&lt;/strong&gt;实现：即所有数据都位于用户空间，调用库函数不涉及系统调用。也有&lt;strong&gt;内核实现&lt;/strong&gt;：库的代码和数据结构位于内核空间。POSIX线程库是在内核和用户空间都能实现的库，Windows则是只能在内核实现。JVM取决于宿主系统的库。&lt;br&gt;   POSIX和Windows的库中可以声明全局变量，供所有线程访问。本地数据存放在堆栈，每个线程有自己的堆栈&lt;br&gt;   线程分为同步和异步执行，同步执行的父线程需要等待子线程结束才能执行。&lt;br&gt;   对于Pthread函数，pthread_t tid，pthread_attr_t 是参数类型，pthread_attr_init是初始化函数，pthread_create(&amp;amp;tid,&amp;amp;attr,&amp;amp;func,int)创建线程，使用pthread_join()等待tid的线程结束，pthread_exit()用于退出进程&lt;/p&gt;
&lt;p&gt;   windows api使用windows.h库&lt;br&gt;   Java多线程使用Runnable接口的run方法实现。类需要实现Runnable接口的方法。&lt;br&gt;     在Java中，把一个有Runnable接口的类通过Thread类进行实现，调用thrd的start方法即可自动启动子线程。&lt;/p&gt;
&lt;h2 id=&#34;隐式多线程&#34;&gt;&lt;a href=&#34;#隐式多线程&#34; class=&#34;headerlink&#34; title=&#34;隐式多线程&#34;&gt;&lt;/a&gt;隐式多线程&lt;/h2&gt;&lt;p&gt;这是把创建线程交给编译器和runtime进行&lt;/p&gt;
&lt;h3 id=&#34;线程池&#34;&gt;&lt;a href=&#34;#线程池&#34; class=&#34;headerlink&#34; title=&#34;线程池&#34;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;这个机制允许提前创建出来等待工作，如果池中没有可用线程，进程将会等待。&lt;br&gt;调用的方法类似QueueUserWorkItem（Function，Param，Flags）&lt;/p&gt;
&lt;h3 id=&#34;OpenMP&#34;&gt;&lt;a href=&#34;#OpenMP&#34; class=&#34;headerlink&#34; title=&#34;OpenMP&#34;&gt;&lt;/a&gt;OpenMP&lt;/h3&gt;&lt;p&gt;openmp使用#pragma 的宏命令来只是openmp识别并行区域来执行代码。&lt;br&gt;例如 &lt;/p&gt;
&lt;figure class=&#34;highlight inform7&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs inform7&#34;&gt;#pragma omp parallel for&lt;br&gt;for (i=0;i&amp;lt;N;i++)&lt;br&gt;&amp;#123;&lt;br&gt;  c&lt;span class=&#34;hljs-comment&#34;&gt;[i]&lt;/span&gt;=a&lt;span class=&#34;hljs-comment&#34;&gt;[i]&lt;/span&gt;+b&lt;span class=&#34;hljs-comment&#34;&gt;[i]&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;大中央调度&#34;&gt;&lt;a href=&#34;#大中央调度&#34; class=&#34;headerlink&#34; title=&#34;大中央调度&#34;&gt;&lt;/a&gt;大中央调度&lt;/h3&gt;&lt;p&gt;GCD，是MacOSX的一种技术，可以使用&lt;br&gt;^{}标记一个块，放置在调度队列（优先队列）来执行，分配给线程池的一个线程。&lt;/p&gt;
&lt;h2 id=&#34;多线程问题&#34;&gt;&lt;a href=&#34;#多线程问题&#34; class=&#34;headerlink&#34; title=&#34;多线程问题&#34;&gt;&lt;/a&gt;多线程问题&lt;/h2&gt;&lt;h3 id=&#34;关于fork和exec&#34;&gt;&lt;a href=&#34;#关于fork和exec&#34; class=&#34;headerlink&#34; title=&#34;关于fork和exec&#34;&gt;&lt;/a&gt;关于fork和exec&lt;/h3&gt;&lt;p&gt;系统调用中，fork有两种形式：fork可以让新进程&lt;strong&gt;复制所有进程&lt;/strong&gt;，或者只&lt;strong&gt;复制调用的进程&lt;/strong&gt;&lt;br&gt;exec会取代所有线程&lt;br&gt;所以如果fork完立刻调用exec，就只复制一个线程就行。 &lt;/p&gt;
&lt;h3 id=&#34;信号处理&#34;&gt;&lt;a href=&#34;#信号处理&#34; class=&#34;headerlink&#34; title=&#34;信号处理&#34;&gt;&lt;/a&gt;信号处理&lt;/h3&gt;&lt;p&gt;信号是一种UNIX用于通知进程的机制，分为&lt;strong&gt;同步信号&lt;/strong&gt;和&lt;strong&gt;异步信号&lt;/strong&gt;，同步信号发送到产生事件的同一进程，异步信号发送到其他进程。&lt;br&gt;信号处理程序分为&lt;strong&gt;缺省信号处理&lt;/strong&gt;和&lt;strong&gt;用户定义处理程序&lt;/strong&gt;。传递信号的函数为kill(pid,signal)。这规定了将信号传递到进程pid，事实上，信号传递到多线程中会有如下可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递到信号适用的thread&lt;/li&gt;
&lt;li&gt;传递到每个thread&lt;/li&gt;
&lt;li&gt;传递到某些thread&lt;/li&gt;
&lt;li&gt;传递到一个指定接受所有信号的thread&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个异步信号，因为信号只能处理一次，所以传递到第一个不拒绝的线程。&lt;br&gt;pthreads有一个函数：pthread_kill(pthread_t tid, int signal)&lt;/p&gt;
&lt;p&gt;Windows支持异步过程调用来模拟信号机制&lt;/p&gt;
&lt;h3 id=&#34;线程撤销&#34;&gt;&lt;a href=&#34;#线程撤销&#34; class=&#34;headerlink&#34; title=&#34;线程撤销&#34;&gt;&lt;/a&gt;线程撤销&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;目标线程&lt;/strong&gt;是被撤销的线程。撤销线程分为&lt;strong&gt;异步撤销&lt;/strong&gt;（立即撤销）和&lt;strong&gt;延迟撤销&lt;/strong&gt;（一个线程检查目标线程何时适合撤销）使用pthread_cancel来撤销。&lt;br&gt;默认pthread是延迟撤销的，创建线程也可以指定是否可以立刻撤销，如果不可以的话，pthread_testcancel()函数可以指定当前可以撤销。&lt;/p&gt;
&lt;h3 id=&#34;TLS&#34;&gt;&lt;a href=&#34;#TLS&#34; class=&#34;headerlink&#34; title=&#34;TLS&#34;&gt;&lt;/a&gt;TLS&lt;/h3&gt;&lt;p&gt;线程本地存储，可以让一个变量作为线程的全局变量，但是其他线程无法访问&lt;/p&gt;
&lt;h3 id=&#34;调度程序&#34;&gt;&lt;a href=&#34;#调度程序&#34; class=&#34;headerlink&#34; title=&#34;调度程序&#34;&gt;&lt;/a&gt;调度程序&lt;/h3&gt;&lt;p&gt;为了保证内核线程的动态调整，系统实现了一个名为轻量级进程LWP的数据结构，对用户线程，其体现为&lt;strong&gt;虚拟处理器&lt;/strong&gt;，每个LWP与一个内核线程相连（真正调用物理处理器）。一个进程的LWP数量有限。&lt;/p&gt;
&lt;p&gt;用户线程和内核的通信是通过调度器激活的机制进行的。&lt;br&gt;内核分配一组LWP给应用程序。应用程序将线程分配给LWP。&lt;br&gt;当有事件发生时，例如阻塞，内核出发回调给应用程序，应用程序中的线程库出发回调处理程序来保存阻塞进程的内容，然后分配一个新的线程给原本阻塞线程所在的LWP。阻塞结束后，也是通过回调程序来恢复运行。&lt;/p&gt;
&lt;h2 id=&#34;实例&#34;&gt;&lt;a href=&#34;#实例&#34; class=&#34;headerlink&#34; title=&#34;实例&#34;&gt;&lt;/a&gt;实例&lt;/h2&gt; ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid>
            <title>操作系统学习笔记1</title>
            <link>http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link>
            <category>技术</category>
            <category>博客</category>
            <category>操作系统</category>
            <pubDate>Fri, 22 Mar 2024 15:52:53 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;内核设计&#34;&gt;&lt;a href=&#34;#内核设计&#34; class=&#34;headerlink&#34; title=&#34;内核设计&#34;&gt;&lt;/a&gt;内核设计&lt;/h2&gt;&lt;h3 id=&#34;微内核&#34;&gt;&lt;a href=&#34;#微内核&#34; class=&#34;headerlink&#34; title=&#34;微内核&#34;&gt;&lt;/a&gt;微内核&lt;/h3&gt;&lt;p&gt;微内核实现了一个功能较少，但是容易扩展的内核架构，客户程序和不同的功能之间提供&lt;strong&gt;消息传递&lt;/strong&gt;功能。除了必须内核功能外，功能组件都作为用户程序来实现。&lt;/p&gt;
&lt;h3 id=&#34;模块化&#34;&gt;&lt;a href=&#34;#模块化&#34; class=&#34;headerlink&#34; title=&#34;模块化&#34;&gt;&lt;/a&gt;模块化&lt;/h3&gt;&lt;p&gt;例如Solaris，有7种可以在运行时加载的模块。&lt;/p&gt;
&lt;h3 id=&#34;混合架构例子&#34;&gt;&lt;a href=&#34;#混合架构例子&#34; class=&#34;headerlink&#34; title=&#34;混合架构例子&#34;&gt;&lt;/a&gt;混合架构例子&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MacOS X，其Mach内核提供了远程过程调用，进程间通信等功能。BSD内核提供了POSIX库和文件系统等功能。&lt;/li&gt;
&lt;li&gt;iOS基于MacOSX，在系统的顶层提供了媒体服务用来支持图形化，Cocoa Touch库提供了有触屏硬件支持的Objective-C API&lt;/li&gt;
&lt;li&gt;Android由Linux内核，增加了一套Dalvik虚拟机和核心库。采用基于Java的Android API用来进行Java开发。运行在Dalvik虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调试&#34;&gt;&lt;a href=&#34;#调试&#34; class=&#34;headerlink&#34; title=&#34;调试&#34;&gt;&lt;/a&gt;调试&lt;/h2&gt;&lt;h3 id=&#34;D-Trace&#34;&gt;&lt;a href=&#34;#D-Trace&#34; class=&#34;headerlink&#34; title=&#34;D Trace&#34;&gt;&lt;/a&gt;D Trace&lt;/h3&gt;&lt;p&gt;使用D语言&lt;/p&gt;
&lt;p&gt;这个工具可以动态探测运行系统。跟踪系统调用以及指令的运行环境（用户or内核）&lt;br&gt;DTrace提供内核探头，拥有内核运行的编译器，生成安全指令。通过调用创建的内核探头，执行&lt;strong&gt;启用控制块&lt;/strong&gt;可以捕获一些数据。&lt;/p&gt;
&lt;h2 id=&#34;操作系统生成&#34;&gt;&lt;a href=&#34;#操作系统生成&#34; class=&#34;headerlink&#34; title=&#34;操作系统生成&#34;&gt;&lt;/a&gt;操作系统生成&lt;/h2&gt;&lt;p&gt;SYSGEN程序用于配置和生成操作系统。系统安装可以有三种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;极端定制：修改源代码，重新编译系统生成&lt;/li&gt;
&lt;li&gt;极端通用：系统描述表已定义好安装的模块，直接激活&lt;/li&gt;
&lt;li&gt;折中：选择模块进行链接来生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编程实例&#34;&gt;&lt;a href=&#34;#编程实例&#34; class=&#34;headerlink&#34; title=&#34;编程实例&#34;&gt;&lt;/a&gt;编程实例&lt;/h2&gt;&lt;h3 id=&#34;基础&#34;&gt;&lt;a href=&#34;#基础&#34; class=&#34;headerlink&#34; title=&#34;基础&#34;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;p&gt;头文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux&amp;#x2F;init.h&lt;/li&gt;
&lt;li&gt;linux&amp;#x2F;kernel.h&lt;/li&gt;
&lt;li&gt;linux.model.h&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重要函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;printk：存储到内核日志缓冲区，用dmesg访问，可以指定优先级&lt;/li&gt;
&lt;li&gt;module_init() &amp;amp; module_exit():用于注册模块。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译好的内核模块，使用sudo insmod simple.ko来插入内核&lt;br&gt;使用sudo ramos simple来移除&lt;/p&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;&lt;a href=&#34;#数据结构&#34; class=&#34;headerlink&#34; title=&#34;数据结构&#34;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;kmalloc：分配内核内存 &lt;/p&gt;
&lt;h1 id=&#34;进程&#34;&gt;&lt;a href=&#34;#进程&#34; class=&#34;headerlink&#34; title=&#34;进程&#34;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&#34;进程概念&#34;&gt;&lt;a href=&#34;#进程概念&#34; class=&#34;headerlink&#34; title=&#34;进程概念&#34;&gt;&lt;/a&gt;进程概念&lt;/h2&gt;&lt;p&gt;进程是一个活动实体，包含代码、程序计数器、堆栈等。&lt;/p&gt;
&lt;h3 id=&#34;进程状态&#34;&gt;&lt;a href=&#34;#进程状态&#34; class=&#34;headerlink&#34; title=&#34;进程状态&#34;&gt;&lt;/a&gt;进程状态&lt;/h3&gt;&lt;p&gt;包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新进程：创建进程&lt;/li&gt;
&lt;li&gt;运行中：指令执行中&lt;/li&gt;
&lt;li&gt;等待：进程等待某个信号&lt;/li&gt;
&lt;li&gt;就绪：等待分配处理器&lt;/li&gt;
&lt;li&gt;终止：进程已完成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程控制块&#34;&gt;&lt;a href=&#34;#进程控制块&#34; class=&#34;headerlink&#34; title=&#34;进程控制块&#34;&gt;&lt;/a&gt;进程控制块&lt;/h3&gt;&lt;p&gt;存储了一个进程的相关信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程状态&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;CPU寄存器&lt;/li&gt;
&lt;li&gt;CPU调度信息&lt;/li&gt;
&lt;li&gt;内存管理信息&lt;/li&gt;
&lt;li&gt;记账信息&lt;/li&gt;
&lt;li&gt;IO状态信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信息采用task_struct来表示，位于&amp;lt;linux&amp;#x2F;sched.h&amp;gt;&lt;br&gt;这个结构还存储了父进程、子进程等。&lt;br&gt;linux系统使用一个current_state结构来指向当前运行的进程。&lt;/p&gt;
&lt;h2 id=&#34;进程调度&#34;&gt;&lt;a href=&#34;#进程调度&#34; class=&#34;headerlink&#34; title=&#34;进程调度&#34;&gt;&lt;/a&gt;进程调度&lt;/h2&gt;&lt;p&gt;被加载运行的进程，进入&lt;strong&gt;任务队列&lt;/strong&gt;，在内存中等待运行的就是&lt;strong&gt;就绪队列&lt;/strong&gt;，等待IO的进程就放在对应的&lt;strong&gt;设备队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于整个流程，进程首先被创建，加入到就绪队列，之后被分配到CPU执行时，会有几种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发出IO请求，进入IO队列&lt;/li&gt;
&lt;li&gt;创建子进程，等待进程执行结束&lt;/li&gt;
&lt;li&gt;中断产生，被放回就绪队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调度程序&#34;&gt;&lt;a href=&#34;#调度程序&#34; class=&#34;headerlink&#34; title=&#34;调度程序&#34;&gt;&lt;/a&gt;调度程序&lt;/h3&gt;&lt;p&gt;调度程序分为短期调度程序和长期调度程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短期调度程序针对的程序IO请求频繁，决策时间较短。&lt;/li&gt;
&lt;li&gt;长期调度程序的创建和杀死速度都较慢，因此有更多时间进行调度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;长期调度程序应选择IO于CPU密集型程序并重的进程。&lt;/p&gt;
&lt;h3 id=&#34;上下文切换&#34;&gt;&lt;a href=&#34;#上下文切换&#34; class=&#34;headerlink&#34; title=&#34;上下文切换&#34;&gt;&lt;/a&gt;上下文切换&lt;/h3&gt;&lt;p&gt;切换进程需要切换状态，典型时间为几毫秒。&lt;/p&gt;
&lt;h2 id=&#34;进程运行&#34;&gt;&lt;a href=&#34;#进程运行&#34; class=&#34;headerlink&#34; title=&#34;进程运行&#34;&gt;&lt;/a&gt;进程运行&lt;/h2&gt;&lt;p&gt;进程可以产生子进程，因此其组织结构是“树”。init进程是pid为1的进程&lt;/p&gt;
&lt;p&gt;重要的init子进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kthreadd：创建额外内核进程。&lt;/li&gt;
&lt;li&gt;sshd：创建ssh连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps -el 列出进程&lt;/p&gt;
&lt;p&gt;fork（）函数创建一个子进程，子进程复制父进程的地址空间。它们都执行fork之后的内容。父进程fork（）返回子进程pid。子进程返回0。父进程可能会需要wait子进程。&lt;/p&gt;
&lt;p&gt;注意：windows的createProcess函数不继承父进程空间，而是需要制定一个特定程序。&lt;/p&gt;
&lt;p&gt;父进程可以调用wait，让子进程（僵尸进程）标识符得到释放。并且如果父进程先被终止，如果没有级连终止的要求下，init进程成为子进程的父。&lt;/p&gt;
&lt;h2 id=&#34;进程间通信&#34;&gt;&lt;a href=&#34;#进程间通信&#34; class=&#34;headerlink&#34; title=&#34;进程间通信&#34;&gt;&lt;/a&gt;进程间通信&lt;/h2&gt;&lt;p&gt;进程和其他进程通信称为协作。进程间协作机制称为IPC，IPC有两种基本模型：&lt;strong&gt;共享内存&lt;/strong&gt;和&lt;strong&gt;消息传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前，在多核系统上，共享内存机制由于高速缓存的不一致性，性能要差于消息传递。&lt;/p&gt;
&lt;h3 id=&#34;共享内存&#34;&gt;&lt;a href=&#34;#共享内存&#34; class=&#34;headerlink&#34; title=&#34;共享内存&#34;&gt;&lt;/a&gt;共享内存&lt;/h3&gt;&lt;p&gt;共享内存区域驻留在创建共享内存段的进程内。并且负责确保内存不会被同时写入。&lt;br&gt;共享内存有一个循环数组，用于共享进程发送信息的缓冲。&lt;/p&gt;
&lt;h3 id=&#34;消息传递&#34;&gt;&lt;a href=&#34;#消息传递&#34; class=&#34;headerlink&#34; title=&#34;消息传递&#34;&gt;&lt;/a&gt;消息传递&lt;/h3&gt;&lt;p&gt;消息传递需要至少提供send()和receive()两个操作。这样要考虑几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接or间接通信&lt;/li&gt;
&lt;li&gt;同步or异步&lt;/li&gt;
&lt;li&gt;自动or显式缓冲&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;通信的直接or间接&#34;&gt;&lt;a href=&#34;#通信的直接or间接&#34; class=&#34;headerlink&#34; title=&#34;通信的直接or间接&#34;&gt;&lt;/a&gt;通信的直接or间接&lt;/h4&gt;&lt;p&gt;采用直接通信的send()和receive()都需要直接指定接收方的地址，可能是对称或非对称的（非对称即接收方只能接受向其发送的进程信息）&lt;/p&gt;
&lt;p&gt;间接通信的方法则通过邮箱或端口来发送信息。通过把邮箱抽象为一个对象，这种方式有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享邮箱才能建立链路&lt;/li&gt;
&lt;li&gt;一个链路与多个进程关联&lt;/li&gt;
&lt;li&gt;两个进程之间可以有多个链路&lt;br&gt;但是一个消息只能被一个进程接收&lt;br&gt;邮箱可以为系统或进程拥有，进程拥有的邮箱必须要确定所有者和使用者。所有者只能接受信息，使用者只能发送信息。&lt;br&gt;进程被终止后，邮箱将消失。操作系统的邮箱是独立存在的。操作系统提供机制允许进程进行创建、删除、使用邮箱。而且通过系统调用，邮箱的所有权可以传给其他进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;同步&#34;&gt;&lt;a href=&#34;#同步&#34; class=&#34;headerlink&#34; title=&#34;同步&#34;&gt;&lt;/a&gt;同步&lt;/h4&gt;&lt;p&gt;关于消息传递的同步性，有以下四种可能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞发送：发送消息后，直到被接收，进程都将阻塞&lt;/li&gt;
&lt;li&gt;非阻塞发送：发送后继续操作&lt;/li&gt;
&lt;li&gt;阻塞接收：阻塞进程，直到能接收信息&lt;/li&gt;
&lt;li&gt;非阻塞接收：接收进程收到有效信息或空信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缓存&#34;&gt;&lt;a href=&#34;#缓存&#34; class=&#34;headerlink&#34; title=&#34;缓存&#34;&gt;&lt;/a&gt;缓存&lt;/h4&gt;&lt;p&gt;缓存有三种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;零容量：要求发送者应当阻塞发送，因为消息队列不能等待。&lt;/li&gt;
&lt;li&gt;有限容量：最多n条消息可以等待，超过这个数量时进程将阻塞&lt;/li&gt;
&lt;li&gt;无限容量：进程不会阻塞发送&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子&#34;&gt;&lt;a href=&#34;#例子&#34; class=&#34;headerlink&#34; title=&#34;例子&#34;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;h4 id=&#34;posix&#34;&gt;&lt;a href=&#34;#posix&#34; class=&#34;headerlink&#34; title=&#34;posix&#34;&gt;&lt;/a&gt;posix&lt;/h4&gt;&lt;p&gt;posix通过内存映射文件共享内存，通过系统调用shm_open(name,O_CREAT|O_RDRW,0666)函数来创建共享内存对象。&lt;br&gt;创建成功后，函数ftruncate(shm_fd,4096)用于配置对象的大小（4096字节）&lt;br&gt;最后，mmap()函数用于将内存映射文件包含共享内存。返回ptr&lt;br&gt;使用sprintf()将message写入ptr。&lt;br&gt;最终消费者使用了共享内存后，调用shm_unlink()移除共享内存&lt;/p&gt;
&lt;h4 id=&#34;Mach&#34;&gt;&lt;a href=&#34;#Mach&#34; class=&#34;headerlink&#34; title=&#34;Mach&#34;&gt;&lt;/a&gt;Mach&lt;/h4&gt;&lt;p&gt;Mach通过消息传递（采用邮箱）实现&lt;br&gt;包括两个邮箱：内核邮箱和通知邮箱。调用msg_send()来发送消息，msg_receive()接收消息，msg_rpc()用来进行远程过程调用。&lt;br&gt;系统调用port_allocate()来创建新邮箱。可以指定最大排队信息，而且消息复制到邮箱中可以保证单个发送者的顺序统一。&lt;br&gt;发送消息如果遇到邮箱满了，可能会等待（无限或n毫秒），或者立刻返回，或者在操作系统中为一个线程存储一个消息。&lt;br&gt;邮箱可以形成一个邮箱集合来服务单个任务。port_status()用于返回指定邮箱的消息数量。&lt;br&gt;Mach本来是为了分布式系统设计，但是为了多核系统，Mach也可以使用虚拟内存，把发送者地址空间映射到接收者地址空间，来提高性能。&lt;/p&gt;
&lt;h4 id=&#34;Windows&#34;&gt;&lt;a href=&#34;#Windows&#34; class=&#34;headerlink&#34; title=&#34;Windows&#34;&gt;&lt;/a&gt;Windows&lt;/h4&gt;&lt;p&gt;windows支持多个操作环境或子系统，应用程序通过消息传递来通信。Windows使用ALPC工具来进行进程间通信。&lt;br&gt;类似于TCP连接，Windows内部也使用了&lt;strong&gt;连接端口&lt;/strong&gt;和&lt;strong&gt;通信端口&lt;/strong&gt;区分的思想。此外，通信回调机制允许服务器和客户端在等待时也能响应接受请求。&lt;br&gt;这个机制包含三种技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于小消息，采用消息队列进行存储，复制传递&lt;/li&gt;
&lt;li&gt;对于大消息（256字节+）：采用区段对象传递，为共享内存。&lt;/li&gt;
&lt;li&gt;对于巨大消息，采用API直接读写目标地址空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：ALPC不属于WinAPI&lt;/p&gt;
&lt;h3 id=&#34;服务器和客户端通信&#34;&gt;&lt;a href=&#34;#服务器和客户端通信&#34; class=&#34;headerlink&#34; title=&#34;服务器和客户端通信&#34;&gt;&lt;/a&gt;服务器和客户端通信&lt;/h3&gt;&lt;h4 id=&#34;套接字&#34;&gt;&lt;a href=&#34;#套接字&#34; class=&#34;headerlink&#34; title=&#34;套接字&#34;&gt;&lt;/a&gt;套接字&lt;/h4&gt;&lt;p&gt;详见计算机网络&lt;/p&gt;
&lt;h4 id=&#34;RPC&#34;&gt;&lt;a href=&#34;#RPC&#34; class=&#34;headerlink&#34; title=&#34;RPC&#34;&gt;&lt;/a&gt;RPC&lt;/h4&gt;&lt;p&gt;RPC：远程过程调用&lt;/p&gt;
&lt;p&gt;RPC和套接字不同，具有明确的数据结构。和本地调用过程相似，RPC隐藏了远程调用的通信细节。&lt;br&gt;对于每个远程过程，客户端都有一个存根用来调用服务器端口，并传递参数。返回值也可以传递回客户端。&lt;br&gt;通过时间戳，系统可以避免RPC被重复执行。而且还需要和客户确认RPC调用已经收到且执行。这要求客户机实现RPC调用的发送后接收到ACK信息。&lt;br&gt;使用交会服务程序，可以让客户请求RPC的端口灵活分配。&lt;br&gt;RPC可用于实现分布式文件系统&lt;/p&gt;
&lt;h4 id=&#34;管道&#34;&gt;&lt;a href=&#34;#管道&#34; class=&#34;headerlink&#34; title=&#34;管道&#34;&gt;&lt;/a&gt;管道&lt;/h4&gt;&lt;p&gt;管道是一个半双工的结构&lt;br&gt;分为&lt;strong&gt;普通管道&lt;/strong&gt;和&lt;strong&gt;命名管道&lt;/strong&gt;&lt;br&gt;UNIX上，管道采用pipe(int fd[])函数来创建，fd[0]为读出端，fd[1]为写入端&lt;br&gt;父子进程通信可以使用管道来进行，因为子进程继承了夫进程的管道，他们共享一个管道但是有两个fd。但是普通管道需要在同一机器上有父子关系的进程。&lt;/p&gt;
&lt;p&gt;命名管道：提供了一个双向的，不必须父子关系的，多进程通信的管道。&lt;br&gt;而且通信结束后，管道依旧存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于UNIX，管道通过mkfifo()系统调用来进行。通过调用对文件的读写函数来进行常规读写。只有显式删除才会关闭管道。这是半双工且单机通信的，除非用套接字来进行远程通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Windows，CreateNamedPipe()支持创建全双工且支持远程的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/15/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</guid>
            <title>Linux学习笔记2</title>
            <link>http://example.com/2024/03/15/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</link>
            <category>技术</category>
            <category>博客</category>
            <category>Linux</category>
            <pubDate>Fri, 15 Mar 2024 10:05:10 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;账号文件&#34;&gt;&lt;a href=&#34;#账号文件&#34; class=&#34;headerlink&#34; title=&#34;账号文件&#34;&gt;&lt;/a&gt;账号文件&lt;/h2&gt;&lt;h3 id=&#34;x2F-etc-x2F-passwd&#34;&gt;&lt;a href=&#34;#x2F-etc-x2F-passwd&#34; class=&#34;headerlink&#34; title=&#34;&amp;#x2F;etc&amp;#x2F;passwd&#34;&gt;&lt;/a&gt;&amp;#x2F;etc&amp;#x2F;passwd&lt;/h3&gt;&lt;p&gt;存储了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;账号信息&lt;/li&gt;
&lt;li&gt;x（密码）&lt;/li&gt;
&lt;li&gt;UID&lt;/li&gt;
&lt;li&gt;GID&lt;/li&gt;
&lt;li&gt;用户信息栏&lt;/li&gt;
&lt;li&gt;家目录&lt;/li&gt;
&lt;li&gt;shell&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;x2F-etc-x2F-shadow&#34;&gt;&lt;a href=&#34;#x2F-etc-x2F-shadow&#34; class=&#34;headerlink&#34; title=&#34;&amp;#x2F;etc&amp;#x2F;shadow&#34;&gt;&lt;/a&gt;&amp;#x2F;etc&amp;#x2F;shadow&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;账号名&lt;/li&gt;
&lt;li&gt;密码&lt;/li&gt;
&lt;li&gt;最近修改&lt;/li&gt;
&lt;li&gt;不可修改天数&lt;/li&gt;
&lt;li&gt;建议修改天数&lt;/li&gt;
&lt;li&gt;警告天数&lt;/li&gt;
&lt;li&gt;过期密码宽限&lt;/li&gt;
&lt;li&gt;失效日期&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;忘记密码&#34;&gt;&lt;a href=&#34;#忘记密码&#34; class=&#34;headerlink&#34; title=&#34;忘记密码&#34;&gt;&lt;/a&gt;忘记密码&lt;/h2&gt;&lt;p&gt;普通用户：passwd&lt;br&gt;root：单人启动模式&lt;/p&gt;
&lt;h2 id=&#34;用户组&#34;&gt;&lt;a href=&#34;#用户组&#34; class=&#34;headerlink&#34; title=&#34;用户组&#34;&gt;&lt;/a&gt;用户组&lt;/h2&gt;&lt;p&gt;&amp;#x2F;etc&amp;#x2F;group&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组名&lt;/li&gt;
&lt;li&gt;用户组密码&lt;/li&gt;
&lt;li&gt;GID&lt;/li&gt;
&lt;li&gt;支持的账号名称 逗号分开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;group：查看用户所属的组，第一个是有效用户组，即为创建文件时代表的组&lt;br&gt;newgrp：切换有效用户组，以另外一个单独的shell生效。&lt;/p&gt;
&lt;p&gt;加入用户组：root用usermod，组管理员用gpasswd&lt;/p&gt;
&lt;h2 id=&#34;账号管理&#34;&gt;&lt;a href=&#34;#账号管理&#34; class=&#34;headerlink&#34; title=&#34;账号管理&#34;&gt;&lt;/a&gt;账号管理&lt;/h2&gt;&lt;p&gt;useradd：新建账户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-g初始用户组&lt;/li&gt;
&lt;li&gt;-G次要用户组&lt;/li&gt;
&lt;li&gt;-e失效日期&lt;/li&gt;
&lt;li&gt;-f密码失效&lt;/li&gt;
&lt;li&gt;-s默认shell&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;userdel：删除账户&lt;br&gt;usermod：修改存在的账户&lt;/p&gt;
&lt;p&gt;id：查询用户信息&lt;br&gt;finger：查询用户动态&lt;br&gt;chfn：改变自身动态&lt;/p&gt;
&lt;h2 id=&#34;用户组管理&#34;&gt;&lt;a href=&#34;#用户组管理&#34; class=&#34;headerlink&#34; title=&#34;用户组管理&#34;&gt;&lt;/a&gt;用户组管理&lt;/h2&gt;&lt;p&gt;groupadd：新增组&lt;br&gt;groupmod：修改组&lt;br&gt;groupdel：删除组&lt;/p&gt;
&lt;h2 id=&#34;ACL&#34;&gt;&lt;a href=&#34;#ACL&#34; class=&#34;headerlink&#34; title=&#34;ACL&#34;&gt;&lt;/a&gt;ACL&lt;/h2&gt;&lt;p&gt;ACL为访问控制列表，针对单一用户、单一目录来进行rwx的权限设置。&lt;/p&gt;
&lt;p&gt;setfacl：设置ACL参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-m为设置参数&lt;/li&gt;
&lt;li&gt;-x为删除参数&lt;/li&gt;
&lt;li&gt;-R递归设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对特定使用者：setfacl -m u:账号列表：rwx&lt;/li&gt;
&lt;li&gt;针对特定组：setfacl -m g:用户组列表：rwx&lt;/li&gt;
&lt;li&gt;针对有效权限：setfacl -m m:[rwx]&lt;br&gt;getfacl：查询文件权限&lt;br&gt;getfacl filename&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户身份切换&#34;&gt;&lt;a href=&#34;#用户身份切换&#34; class=&#34;headerlink&#34; title=&#34;用户身份切换&#34;&gt;&lt;/a&gt;用户身份切换&lt;/h2&gt;&lt;p&gt;su：切换shell执行不同身份&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-：直接变为root，作为login_shell&lt;/li&gt;
&lt;li&gt;-l：指定账号&lt;/li&gt;
&lt;li&gt;如无-，则表示用非login shell登录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别在于：非login shell时，你的环境变量还是使用的原来的用户，而loginshell会使用root的名称。&lt;/p&gt;
&lt;p&gt;sudo：以root权限来执行命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-b：后台执行&lt;/li&gt;
&lt;li&gt;-u：指定希望切换的使用者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;能否执行取决于是否在&amp;#x2F;etc&amp;#x2F;sudoers文件，可用visudo修改。&lt;br&gt;visudo可以通过添加用户，添加用户组，限制命令执行，别名等方式来简化流程。&lt;/p&gt;
&lt;h2 id=&#34;特殊shell：-x2F-sbin-x2F-nologin&#34;&gt;&lt;a href=&#34;#特殊shell：-x2F-sbin-x2F-nologin&#34; class=&#34;headerlink&#34; title=&#34;特殊shell：&amp;#x2F;sbin&amp;#x2F;nologin&#34;&gt;&lt;/a&gt;特殊shell：&amp;#x2F;sbin&amp;#x2F;nologin&lt;/h2&gt;&lt;p&gt;系统账号可以登录，但是不能用shell访问系统资源&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/03/03/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</guid>
            <title>Linux学习笔记1</title>
            <link>http://example.com/2024/03/03/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</link>
            <category>技术</category>
            <category>博客</category>
            <category>Linux</category>
            <pubDate>Sun, 03 Mar 2024 16:29:11 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Linux学习笔记1&#34;&gt;&lt;a href=&#34;#Linux学习笔记1&#34; class=&#34;headerlink&#34; title=&#34;Linux学习笔记1&#34;&gt;&lt;/a&gt;Linux学习笔记1&lt;/h1&gt;&lt;h2 id=&#34;启动运行级&#34;&gt;&lt;a href=&#34;#启动运行级&#34; class=&#34;headerlink&#34; title=&#34;启动运行级&#34;&gt;&lt;/a&gt;启动运行级&lt;/h2&gt;&lt;p&gt;Linux的&amp;#x2F;etc&amp;#x2F;rcX.d目录下存储着各个启动级的运行程序&lt;br&gt;运行级&lt;strong&gt;1&lt;/strong&gt;时进入单用户模式，仅仅进行文件系统维护。标准运行级为&lt;strong&gt;3&lt;/strong&gt;。运行级为&lt;strong&gt;5&lt;/strong&gt;时会启动X Window服务。切换启动级别可以使用runlevel命令来设置&lt;/p&gt;
&lt;h2 id=&#34;内核模块&#34;&gt;&lt;a href=&#34;#内核模块&#34; class=&#34;headerlink&#34; title=&#34;内核模块&#34;&gt;&lt;/a&gt;内核模块&lt;/h2&gt;&lt;p&gt;Linux内有两种方法插入设备驱动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译进内核&lt;/li&gt;
&lt;li&gt;可插入的设备驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux内部有三种设备文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符设备文件：包括终端等&lt;/li&gt;
&lt;li&gt;块设备文件：包括硬盘&lt;/li&gt;
&lt;li&gt;网络设备文件：包括网卡和回环设备&lt;br&gt;每个设备都有一个节点文件，用于唯一标识设备（主设备号，次设备号）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设置终端&#34;&gt;&lt;a href=&#34;#设置终端&#34; class=&#34;headerlink&#34; title=&#34;设置终端&#34;&gt;&lt;/a&gt;设置终端&lt;/h2&gt;&lt;p&gt;可以使用setterm命令执行诸如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;settterm -inversescreen on&lt;/li&gt;
&lt;li&gt;setterm -background white&lt;/li&gt;
&lt;li&gt;setterm -foreground black&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;GNU-nm&#34;&gt;&lt;a href=&#34;#GNU-nm&#34; class=&#34;headerlink&#34; title=&#34;GNU nm&#34;&gt;&lt;/a&gt;GNU nm&lt;/h2&gt;&lt;p&gt;这个命令可以分析obj文件并输出符号列表&lt;/p&gt;
&lt;h2 id=&#34;man&#34;&gt;&lt;a href=&#34;#man&#34; class=&#34;headerlink&#34; title=&#34;man&#34;&gt;&lt;/a&gt;man&lt;/h2&gt;&lt;p&gt;man可以指定手册的部分，分为1-9内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1：命令名&lt;/li&gt;
&lt;li&gt;2：系统调用&lt;/li&gt;
&lt;li&gt;3：库调用&lt;/li&gt;
&lt;li&gt;4：特殊文件&lt;/li&gt;
&lt;li&gt;5：文件格式与约定&lt;/li&gt;
&lt;li&gt;6：游戏&lt;/li&gt;
&lt;li&gt;7：概览，约定&lt;/li&gt;
&lt;li&gt;8：root命令&lt;/li&gt;
&lt;li&gt;9：内核例程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ls&#34;&gt;&lt;a href=&#34;#ls&#34; class=&#34;headerlink&#34; title=&#34;ls&#34;&gt;&lt;/a&gt;ls&lt;/h2&gt;&lt;p&gt;如下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-F：标注文件类型&lt;/li&gt;
&lt;li&gt;-R：递归寻找&lt;/li&gt;
&lt;li&gt;加入字符串：模糊匹配&lt;/li&gt;
&lt;li&gt;–time&amp;#x3D;atime：显示访问时间&lt;/li&gt;
&lt;li&gt;-d：不递归显示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;copy&#34;&gt;&lt;a href=&#34;#copy&#34; class=&#34;headerlink&#34; title=&#34;copy&#34;&gt;&lt;/a&gt;copy&lt;/h2&gt;&lt;p&gt;cp source dest&lt;br&gt;如下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i：询问是否覆盖&lt;/li&gt;
&lt;li&gt;-R：复制目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链接&#34;&gt;&lt;a href=&#34;#链接&#34; class=&#34;headerlink&#34; title=&#34;链接&#34;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;ln srcfile linkfile&lt;/p&gt;
&lt;p&gt;参数；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-s：符号链接&lt;/li&gt;
&lt;li&gt;无参数：硬链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mv&#34;&gt;&lt;a href=&#34;#mv&#34; class=&#34;headerlink&#34; title=&#34;mv&#34;&gt;&lt;/a&gt;mv&lt;/h2&gt;&lt;p&gt;mv src dest&lt;/p&gt;
&lt;p&gt;移动文件是不会改变inode的。&lt;/p&gt;
&lt;h2 id=&#34;目录操作&#34;&gt;&lt;a href=&#34;#目录操作&#34; class=&#34;headerlink&#34; title=&#34;目录操作&#34;&gt;&lt;/a&gt;目录操作&lt;/h2&gt;&lt;p&gt;mkdir ：-p可以创建缺失父目录&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/</guid>
            <title>电赛培训-23-07-05</title>
            <link>http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/</link>
            <category>技术</category>
            <category>博客</category>
            <category>电赛</category>
            <pubDate>Wed, 05 Jul 2023 09:46:48 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;Arduino&#34;&gt;&lt;a href=&#34;#Arduino&#34; class=&#34;headerlink&#34; title=&#34;Arduino&#34;&gt;&lt;/a&gt;Arduino&lt;/h1&gt;&lt;p&gt;软件：使用Arduino IDE，以C++风格语言编写相关库。&lt;br&gt;利用IDE编译固件下载到Arduino的前提条件是有bootloader程序。&lt;br&gt;所以从程序到固件的关键在于bootloader，其他单片机也可以装载bootloader固件，然后使用arduino库。&lt;/p&gt;
&lt;h2 id=&#34;硬件-uno板&#34;&gt;&lt;a href=&#34;#硬件-uno板&#34; class=&#34;headerlink&#34; title=&#34;硬件 uno板&#34;&gt;&lt;/a&gt;硬件 uno板&lt;/h2&gt;&lt;p&gt;工作电压5v,可以typeB，DC5.5，或者跳线接入&lt;br&gt;共有14个数字输入输出（6个PWM口），6个模拟输入输出&lt;/p&gt;
&lt;h2 id=&#34;系统指示灯&#34;&gt;&lt;a href=&#34;#系统指示灯&#34; class=&#34;headerlink&#34; title=&#34;系统指示灯&#34;&gt;&lt;/a&gt;系统指示灯&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ON：系统指示灯&lt;/li&gt;
&lt;li&gt;RX：接收指示灯&lt;/li&gt;
&lt;li&gt;TX：发送指示灯&lt;/li&gt;
&lt;li&gt;L：内置LED，对应13号数字口&lt;h2 id=&#34;开始编写代码&#34;&gt;&lt;a href=&#34;#开始编写代码&#34; class=&#34;headerlink&#34; title=&#34;开始编写代码&#34;&gt;&lt;/a&gt;开始编写代码&lt;/h2&gt;有两个一定会有的函数，void setup()和void loop()，分别是初始化和循环函数。&lt;br&gt;setup会执行一次，loop在setup后会自动循环&lt;h3 id=&#34;setup函数&#34;&gt;&lt;a href=&#34;#setup函数&#34; class=&#34;headerlink&#34; title=&#34;setup函数&#34;&gt;&lt;/a&gt;setup函数&lt;/h3&gt;setup中用pinMode配置管脚模式为输出&lt;br&gt;pinMode(pin编号，INPUT)：高阻态，可认为是100m欧姆，电平不定。&lt;br&gt;pinMode(pinnum,INPUT_PULLUP):内置上拉输入，无外部信号默认高电平。&lt;br&gt;pinMode(pinnum,OUTPUT):输出模式，uno上高电平5v，电流&amp;lt;40mA&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;loop函数&#34;&gt;&lt;a href=&#34;#loop函数&#34; class=&#34;headerlink&#34; title=&#34;loop函数&#34;&gt;&lt;/a&gt;loop函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;digitalWrite(pinnum,HIGH&amp;#x2F;LOW):输出高低电平，只对output模式有效&lt;/li&gt;
&lt;li&gt;digitalRead(pinnum):读取高低电平,返回HIGH&amp;#x2F;LOW两种电平&lt;/li&gt;
&lt;li&gt;analogRead(anaPinNum)：读取模拟输入电平，返回0-1023的数字，对应0-5v的电压&lt;/li&gt;
&lt;li&gt;analogWrite(pwmPinNum,0-255)：输出PWM波，对应0-5v的电压，频率为490Hz(3,9,10,11pin),或980Hz(5,6pin)&lt;/li&gt;
&lt;li&gt;analogReference(AD参考电压输入来源)：切换AD参考电压输入来源，有默认值，一般不用，可以让输出更加精细。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断和轮询&#34;&gt;&lt;a href=&#34;#中断和轮询&#34; class=&#34;headerlink&#34; title=&#34;中断和轮询&#34;&gt;&lt;/a&gt;中断和轮询&lt;/h3&gt;&lt;p&gt;轮询：不断重复读取某个状态值，缺点是占用资源&lt;br&gt;中断：可以通过某个状态改变来发送信号，然后发送信号后可以执行其他操作，之后再恢复到发送信号之前的状态。&lt;br&gt;管脚中断：attachInterrupt(digitalPinToInterrupt(pinnum),ISR,mode),第一个参数是中断管脚号（uno为2，3），第二个参数是中断服务函数（可以自定义），第三个参数是中断模式，有LOW，RISING，FALLING，CHANGE四种模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LOW：低电平触发&lt;/li&gt;
&lt;li&gt;RISING：上升沿触发&lt;/li&gt;
&lt;li&gt;FALLING：下降沿触发&lt;/li&gt;
&lt;li&gt;CHANGE：任意电平变化触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意，终端服务函数应当很短，而且不能使用其他中断实现的函数，延时需要delayMicroseconds(us)&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;修改全局变量应当用volatile修饰，防止编译器优化&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;ESP32&#34;&gt;&lt;a href=&#34;#ESP32&#34; class=&#34;headerlink&#34; title=&#34;ESP32&#34;&gt;&lt;/a&gt;ESP32&lt;/h1&gt;&lt;h2 id=&#34;硬件&#34;&gt;&lt;a href=&#34;#硬件&#34; class=&#34;headerlink&#34; title=&#34;硬件&#34;&gt;&lt;/a&gt;硬件&lt;/h2&gt;&lt;p&gt;esp32-WROOM-32&lt;br&gt;串口芯片：CP2102&lt;br&gt;核心频率240mHz&lt;br&gt;WiFi IEEE 802.11 b&amp;#x2F;g&amp;#x2F;n 2.4GHz&lt;br&gt;BLuetooth 4.2 BR&amp;#x2F;EDR and BLE&lt;br&gt;520k SRAM 448kB ROM&lt;br&gt;2个I2S，RMT远程控制，LED PWM，1个host SD&amp;#x2F;eMMC&amp;#x2F;SDIO，一个slave SDIO&amp;#x2F;SPI. TWAI(CAN),12bitADC,Ethernet&lt;/p&gt;
&lt;h2 id=&#34;开发环境&#34;&gt;&lt;a href=&#34;#开发环境&#34; class=&#34;headerlink&#34; title=&#34;开发环境&#34;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;MicroPython+Thonny&lt;/p&gt;
&lt;h3 id=&#34;常用库&#34;&gt;&lt;a href=&#34;#常用库&#34; class=&#34;headerlink&#34; title=&#34;常用库&#34;&gt;&lt;/a&gt;常用库&lt;/h3&gt;&lt;h3 id=&#34;GPIO&#34;&gt;&lt;a href=&#34;#GPIO&#34; class=&#34;headerlink&#34; title=&#34;GPIO&#34;&gt;&lt;/a&gt;GPIO&lt;/h3&gt;&lt;figure class=&#34;highlight pgsql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs pgsql&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;from&lt;/span&gt; machine &lt;span class=&#34;hljs-keyword&#34;&gt;import&lt;/span&gt; Pin&lt;br&gt;&lt;br&gt;p0 = Pin(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,Pin.&lt;span class=&#34;hljs-keyword&#34;&gt;OUT&lt;/span&gt;) # &lt;span class=&#34;hljs-keyword&#34;&gt;create&lt;/span&gt; output pin &lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt; GPIO0&lt;br&gt;p0.&lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt;() # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &amp;quot;on&amp;quot; (high) &lt;span class=&#34;hljs-keyword&#34;&gt;level&lt;/span&gt;&lt;br&gt;p0.&lt;span class=&#34;hljs-keyword&#34;&gt;off&lt;/span&gt;() # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &amp;quot;off&amp;quot; (low) &lt;span class=&#34;hljs-keyword&#34;&gt;level&lt;/span&gt;&lt;br&gt;p0.&lt;span class=&#34;hljs-keyword&#34;&gt;value&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt;/high&lt;br&gt;p0.init(p0.&lt;span class=&#34;hljs-keyword&#34;&gt;IN&lt;/span&gt;,p0.PULL_DOWN) # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;input&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;with&lt;/span&gt; a pull-down resistor&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;init函数中，id是强制的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;mode指定引脚模式，有IN，OUT，OPEN_DRAIN，AF_OPEN_DRAIN四种模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pull指定引脚是否连接弱上拉电阻，有None，PULL_UP，PULL_DOWN三种模式&lt;br&gt;弱上拉指上拉电阻阻值较大，高电平很容易因为外部电流驱动而拉低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;drive具有不同的最大安全电流的限制，有DRIVE_0-3四种选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;alt为引脚的备用功能，仅对alt和alt_open_drain两种模式有效，有0-7八种选择&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;value函数中，如果不带参数，就是得到当前状态，如果在输出模式，需要带参数，变为设置电平&lt;/p&gt;
&lt;p&gt;配置在引脚的触发源处于活动状态时要调用中断处理程序，如果引脚模式为Pin.IN，可以使用irq函数，如果引脚模式为Pin.IN，可以使用Pin.IRQ_RISING，Pin.IRQ_FALLING，Pin.IRQ_ANY三种模式，分别对应上升沿，下降沿，任意电平变化触发中断。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/05/29/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3WSL-Ubuntu%E6%89%BE%E4%B8%8D%E5%88%B0sys-time-h%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
            <title>关于解决WSL_Ubuntu找不到sys/time.h的问题</title>
            <link>http://example.com/2023/05/29/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3WSL-Ubuntu%E6%89%BE%E4%B8%8D%E5%88%B0sys-time-h%E7%9A%84%E9%97%AE%E9%A2%98/</link>
            <category>技术</category>
            <category>博客</category>
            <category>Linux</category>
            <category>WSL</category>
            <category>编译</category>
            <pubDate>Mon, 29 May 2023 15:24:24 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;问题描述&#34;&gt;&lt;a href=&#34;#问题描述&#34; class=&#34;headerlink&#34; title=&#34;问题描述&#34;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在使用WSL_Ubuntu的时候，编译C代码时，出现了找不到sys&amp;#x2F;time.h的问题&lt;/p&gt;
&lt;h1 id=&#34;解决方法&#34;&gt;&lt;a href=&#34;#解决方法&#34; class=&#34;headerlink&#34; title=&#34;解决方法&#34;&gt;&lt;/a&gt;解决方法&lt;/h1&gt;&lt;h2 id=&#34;第一次失败&#34;&gt;&lt;a href=&#34;#第一次失败&#34; class=&#34;headerlink&#34; title=&#34;第一次失败&#34;&gt;&lt;/a&gt;第一次失败&lt;/h2&gt;&lt;p&gt;网上的一个直接解决方案是安装libc6-dev-amd64&lt;br&gt;但是问题又一次出现，当输入指令&lt;br&gt;&lt;code&gt;sudo apt-get install libc6-dev-amd64&lt;/code&gt;&lt;br&gt;发生报错 unable to locate package&lt;/p&gt;
&lt;h2 id=&#34;第二次失败&#34;&gt;&lt;a href=&#34;#第二次失败&#34; class=&#34;headerlink&#34; title=&#34;第二次失败&#34;&gt;&lt;/a&gt;第二次失败&lt;/h2&gt;&lt;p&gt;于是转而解决无法定位包的问题，根据查找发现需要在&amp;#x2F;etc&amp;#x2F;apt&amp;#x2F;sources.list中添加源,添加了清华源、阿里源后输入&lt;br&gt;&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;br&gt;更新完成后再次尝试安装libc6-dev-amd64，但是问题依旧存在&lt;/p&gt;
&lt;h2 id=&#34;第三次解决&#34;&gt;&lt;a href=&#34;#第三次解决&#34; class=&#34;headerlink&#34; title=&#34;第三次解决&#34;&gt;&lt;/a&gt;第三次解决&lt;/h2&gt;&lt;p&gt;这次发现libc6-dev-amd64是一个需要在i386架构下安装的包，于是尝试添加i386架构，运行指令&lt;br&gt;&lt;code&gt;dpkg --add-architecture i386&lt;/code&gt;&lt;br&gt;添加成功后再次输入&lt;br&gt;&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;br&gt;更新完成后再次尝试安装libc6-dev-amd64，问题解决&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/</guid>
            <title>电赛学习笔记-机器视觉</title>
            <link>http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/</link>
            <category>技术</category>
            <category>博客</category>
            <category>电赛</category>
            <pubDate>Sun, 14 May 2023 17:04:31 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;开发环境&#34;&gt;&lt;a href=&#34;#开发环境&#34; class=&#34;headerlink&#34; title=&#34;开发环境&#34;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;h2 id=&#34;安装opencv&#34;&gt;&lt;a href=&#34;#安装opencv&#34; class=&#34;headerlink&#34; title=&#34;安装opencv&#34;&gt;&lt;/a&gt;安装opencv&lt;/h2&gt;&lt;h2 id=&#34;开发板：STM32F407&#34;&gt;&lt;a href=&#34;#开发板：STM32F407&#34; class=&#34;headerlink&#34; title=&#34;开发板：STM32F407&#34;&gt;&lt;/a&gt;开发板：STM32F407&lt;/h2&gt;&lt;h2 id=&#34;IDE：STM32CubeIDE&#34;&gt;&lt;a href=&#34;#IDE：STM32CubeIDE&#34; class=&#34;headerlink&#34; title=&#34;IDE：STM32CubeIDE&#34;&gt;&lt;/a&gt;IDE：STM32CubeIDE&lt;/h2&gt;&lt;h2 id=&#34;配置过程&#34;&gt;&lt;a href=&#34;#配置过程&#34; class=&#34;headerlink&#34; title=&#34;配置过程&#34;&gt;&lt;/a&gt;配置过程&lt;/h2&gt;&lt;p&gt;配置工程ioc文件，配置好基础外设后，再packs中安装X-CUBE-AI组件包，在软件包外设中添加模型文件，设置压缩倍数，导入测试集验证准确率&lt;/p&gt;
&lt;h2 id=&#34;模型&#34;&gt;&lt;a href=&#34;#模型&#34; class=&#34;headerlink&#34; title=&#34;模型&#34;&gt;&lt;/a&gt;模型&lt;/h2&gt;&lt;h3 id=&#34;yolo&#34;&gt;&lt;a href=&#34;#yolo&#34; class=&#34;headerlink&#34; title=&#34;yolo&#34;&gt;&lt;/a&gt;yolo&lt;/h3&gt;&lt;p&gt;利用mobilenet yolo50k模型可以导入到单片机中，只需要较少内存即可实现实时运行，实现人脸识别的功能&lt;/p&gt;
&lt;h3 id=&#34;openmv&#34;&gt;&lt;a href=&#34;#openmv&#34; class=&#34;headerlink&#34; title=&#34;openmv&#34;&gt;&lt;/a&gt;openmv&lt;/h3&gt;&lt;h2 id=&#34;硬件&#34;&gt;&lt;a href=&#34;#硬件&#34; class=&#34;headerlink&#34; title=&#34;硬件&#34;&gt;&lt;/a&gt;硬件&lt;/h2&gt;&lt;p&gt;正点原子ov7725摄像头&lt;br&gt;yolo50k&lt;/p&gt;
&lt;h1 id=&#34;相关资料&#34;&gt;&lt;a href=&#34;#相关资料&#34; class=&#34;headerlink&#34; title=&#34;相关资料&#34;&gt;&lt;/a&gt;相关资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Bt411w77m/?share_source=copy_web&amp;vd_source=4ed5c2c0429d7681216f506ac1e74065&#34;&gt;稚晖君&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/dog-qiuqiu/MobileNet-Yolo&#34;&gt;yolo50k仓库&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1FL411u72p/?share_source=copy_web&amp;vd_source=4ed5c2c0429d7681216f506ac1e74065&#34;&gt;实时运行案例&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/</guid>
            <title>电赛学习笔记-micropython</title>
            <link>http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/</link>
            <category>技术</category>
            <category>博客</category>
            <category>电赛</category>
            <pubDate>Sun, 14 May 2023 16:47:54 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;micropython简介&#34;&gt;&lt;a href=&#34;#micropython简介&#34; class=&#34;headerlink&#34; title=&#34;micropython简介&#34;&gt;&lt;/a&gt;micropython简介&lt;/h1&gt;&lt;p&gt;micropython是一个能够利用python进行单片机开发的固件，目前主要是在esp32平台上进行的开发&lt;/p&gt;
&lt;h1 id=&#34;micropython安装&#34;&gt;&lt;a href=&#34;#micropython安装&#34; class=&#34;headerlink&#34; title=&#34;micropython安装&#34;&gt;&lt;/a&gt;micropython安装&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在micropython官网找到对应的单片机的型号的固件文件（.bin），下载到对应位置&lt;/li&gt;
&lt;li&gt;pip install esptool&lt;/li&gt;
&lt;li&gt;连接esp32单片机，查看端口号&lt;/li&gt;
&lt;li&gt;根据micropython官网的指示，利用esptool.py文件，清除单片机flash，再部署固件到单片机。&lt;/li&gt;
&lt;li&gt;安装uPyCraft IDE，选择好开发板类型和端口号后，&lt;h1 id=&#34;micropython使用&#34;&gt;&lt;a href=&#34;#micropython使用&#34; class=&#34;headerlink&#34; title=&#34;micropython使用&#34;&gt;&lt;/a&gt;micropython使用&lt;/h1&gt;需要根据单片机自带的库函数，进行python文档的开发&lt;h1 id=&#34;micropython的优点&#34;&gt;&lt;a href=&#34;#micropython的优点&#34; class=&#34;headerlink&#34; title=&#34;micropython的优点&#34;&gt;&lt;/a&gt;micropython的优点&lt;/h1&gt;代码量少，配置简单&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</guid>
            <title>电赛学习笔记（1）——stm32学习笔记</title>
            <link>http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</link>
            <category>技术</category>
            <category>博客</category>
            <category>电赛</category>
            <pubDate>Thu, 11 May 2023 16:19:20 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;stm32基础&#34;&gt;&lt;a href=&#34;#stm32基础&#34; class=&#34;headerlink&#34; title=&#34;stm32基础&#34;&gt;&lt;/a&gt;stm32基础&lt;/h1&gt;&lt;h2 id=&#34;关于stm32产品线&#34;&gt;&lt;a href=&#34;#关于stm32产品线&#34; class=&#34;headerlink&#34; title=&#34;关于stm32产品线&#34;&gt;&lt;/a&gt;关于stm32产品线&lt;/h2&gt;&lt;h3 id=&#34;stm32f1系列-cortex-m3&#34;&gt;&lt;a href=&#34;#stm32f1系列-cortex-m3&#34; class=&#34;headerlink&#34; title=&#34;stm32f1系列 cortex-m3&#34;&gt;&lt;/a&gt;stm32f1系列 cortex-m3&lt;/h3&gt;&lt;h3 id=&#34;stm32f4系列-cortex-m4&#34;&gt;&lt;a href=&#34;#stm32f4系列-cortex-m4&#34; class=&#34;headerlink&#34; title=&#34;stm32f4系列 cortex-m4&#34;&gt;&lt;/a&gt;stm32f4系列 cortex-m4&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内置了rgb lcd驱动&lt;/li&gt;
&lt;li&gt;加入了DSP与FPU模块&lt;h3 id=&#34;stm32f7系列-cortex-m7&#34;&gt;&lt;a href=&#34;#stm32f7系列-cortex-m7&#34; class=&#34;headerlink&#34; title=&#34;stm32f7系列 cortex-m7&#34;&gt;&lt;/a&gt;stm32f7系列 cortex-m7&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;高速内存得到应用 &lt;h2 id=&#34;寄存器编程&#34;&gt;&lt;a href=&#34;#寄存器编程&#34; class=&#34;headerlink&#34; title=&#34;寄存器编程&#34;&gt;&lt;/a&gt;寄存器编程&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键字volatile&lt;/strong&gt;需要在声明寄存器变量的时候添加，因为要防止编译器自行优化。&lt;/p&gt;
&lt;h2 id=&#34;HAL库&#34;&gt;&lt;a href=&#34;#HAL库&#34; class=&#34;headerlink&#34; title=&#34;HAL库&#34;&gt;&lt;/a&gt;HAL库&lt;/h2&gt;&lt;p&gt;硬件抽象层，可以将不同产品线的芯片的寄存器操作抽象为函数，方便移植&lt;br&gt;&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;本笔记使用HAL库进行编程&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;相对的，HAL库会产生大量的判断来降低代码运行效率&lt;br&gt;但是，还有另一个Low Layer库（LL），这个库可以提高效率&lt;/p&gt;
&lt;h2 id=&#34;stm32cubeMX配置&#34;&gt;&lt;a href=&#34;#stm32cubeMX配置&#34; class=&#34;headerlink&#34; title=&#34;stm32cubeMX配置&#34;&gt;&lt;/a&gt;stm32cubeMX配置&lt;/h2&gt;&lt;h2 id=&#34;stm32计时器&#34;&gt;&lt;a href=&#34;#stm32计时器&#34; class=&#34;headerlink&#34; title=&#34;stm32计时器&#34;&gt;&lt;/a&gt;stm32计时器&lt;/h2&gt;&lt;h3 id=&#34;PWM调制输出&#34;&gt;&lt;a href=&#34;#PWM调制输出&#34; class=&#34;headerlink&#34; title=&#34;PWM调制输出&#34;&gt;&lt;/a&gt;PWM调制输出&lt;/h3&gt;&lt;h4 id=&#34;几个重要参数&#34;&gt;&lt;a href=&#34;#几个重要参数&#34; class=&#34;headerlink&#34; title=&#34;几个重要参数&#34;&gt;&lt;/a&gt;几个重要参数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;占空比：高电平占整个周期的比例&lt;/li&gt;
&lt;li&gt;频率：整个PWM周期的倒数&lt;/li&gt;
&lt;li&gt;分辨率：占空比变化步长 &lt;h4 id=&#34;PWM实现方法&#34;&gt;&lt;a href=&#34;#PWM实现方法&#34; class=&#34;headerlink&#34; title=&#34;PWM实现方法&#34;&gt;&lt;/a&gt;PWM实现方法&lt;/h4&gt;输出比较模式，依靠内部计数器cnt和ccr设置的数值的比较来进行输出电平的控制，常用的有匹配时电平翻转和PWM模式&lt;br&gt;PWM占空比：$$DutyCycle&amp;#x3D;\frac{CCR}{ARR}$$&lt;br&gt;PWM频率：$$Freq&amp;#x3D;\frac{F_{clk}}{ARR}$$&lt;br&gt;PWM分辨率：$$Resolution&amp;#x3D;\frac{ARR}{2^{n}}$$&lt;h4 id=&#34;高级定时器&#34;&gt;&lt;a href=&#34;#高级定时器&#34; class=&#34;headerlink&#34; title=&#34;高级定时器&#34;&gt;&lt;/a&gt;高级定时器&lt;/h4&gt;死区生成：可以避免推挽电路上下管同时打开导致短路&lt;h3 id=&#34;PWM控制电机&#34;&gt;&lt;a href=&#34;#PWM控制电机&#34; class=&#34;headerlink&#34; title=&#34;PWM控制电机&#34;&gt;&lt;/a&gt;PWM控制电机&lt;/h3&gt;舵机是根据pwm信号控制舵机转动角度的，内部有直流电机&lt;h4 id=&#34;电机驱动芯片&#34;&gt;&lt;a href=&#34;#电机驱动芯片&#34; class=&#34;headerlink&#34; title=&#34;电机驱动芯片&#34;&gt;&lt;/a&gt;电机驱动芯片&lt;/h4&gt;利用H桥，可以控制电机转动方向。四个开关管可以构成两个推挽电路，使得电机可以获得两个方向的电流。&lt;br&gt;电机需要的电源一般是大功率的，不能直接通过gpio驱动，因此可以通过让stlink的5v口接入电机驱动芯片来获得电源。但是注意，pwm信号的地应当和电机电源的地相连，否则会出现电平不稳定的情况。&lt;h3 id=&#34;PWM代码&#34;&gt;&lt;a href=&#34;#PWM代码&#34; class=&#34;headerlink&#34; title=&#34;PWM代码&#34;&gt;&lt;/a&gt;PWM代码&lt;/h3&gt;pwm的激活结构如下：&lt;br&gt;&lt;img src=&#34;/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/PWM_Structure.jpg&#34; alt=&#34;PWM_Structure&#34;&gt;&lt;/li&gt;
&lt;li&gt;RCC开启时钟&lt;/li&gt;
&lt;li&gt;配置时基单元&lt;/li&gt;
&lt;li&gt;配置输出比较单元&lt;/li&gt;
&lt;li&gt;配置GPIO，设置为复用推挽输出&lt;/li&gt;
&lt;li&gt;运行控制，启动计数器&lt;h4 id=&#34;TIM库函数&#34;&gt;&lt;a href=&#34;#TIM库函数&#34; class=&#34;headerlink&#34; title=&#34;TIM库函数&#34;&gt;&lt;/a&gt;TIM库函数&lt;/h4&gt;在hal库中，tim相关库函数在stm32f1xx_hal_tim.h文件中&lt;br&gt;其中有关输出比较的内容有：&lt;/li&gt;
&lt;li&gt;TIM_OC_InitTypeDef: 输出比较初始化结构体&lt;/li&gt;
&lt;li&gt;HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)：输出比较初始化函数&lt;/li&gt;
&lt;li&gt;HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel)：配置输出通道函数&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/</guid>
            <title>记录：装修博客</title>
            <link>http://example.com/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/</link>
            <category>博客</category>
            <category>记录</category>
            <pubDate>Thu, 21 Apr 2022 17:32:11 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;&lt;font color=&#34;Red&#34; size=&#34;6&#34;&gt;&lt;strong&gt;本文长期更新，后面更新的部分也会插在不同部分&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&#34;目录&#34;&gt;&lt;a href=&#34;#目录&#34; class=&#34;headerlink&#34; title=&#34;目录&#34;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;.#%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE&#34;&gt;功能设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;.#%E4%B8%BB%E9%A2%98%E9%80%89%E5%8F%96&#34;&gt;主题选取&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;.#%E5%BD%92%E6%A1%A3%E4%B8%8E%E6%A0%87%E7%AD%BE&#34;&gt;归档与标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%8F%8B%E9%93%BE%E4%B8%8E%E4%BD%9C%E8%80%85%E9%93%BE%E6%8E%A5&#34;&gt;友链与作者链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C&#34;&gt;一些其他的骚操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E6%87%92%E5%8A%A0%E8%BD%BD&#34;&gt;懒加载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E7%BE%8E%E8%A7%82%E8%AE%BE%E7%BD%AE&#34;&gt;美观设置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;.#%E8%83%8C%E6%99%AF%E5%9B%BE&#34;&gt;背景图&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;.#%E4%B8%BB%E9%A1%B5%E8%83%8C%E6%99%AF%E5%9B%BE&#34;&gt;主页背景图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E6%96%87%E7%AB%A0%E8%83%8C%E6%99%AF%E5%9B%BE&#34;&gt;文章背景图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2%E5%9B%BE&#34;&gt;文章封面图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB&#34;&gt;图片加载动画&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;.#%E6%89%A9%E5%B1%95%E8%AE%BE%E7%BD%AE&#34;&gt;扩展设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;功能设置&#34;&gt;&lt;a href=&#34;#功能设置&#34; class=&#34;headerlink&#34; title=&#34;功能设置&#34;&gt;&lt;/a&gt;功能设置&lt;/h1&gt;&lt;h2 id=&#34;主题选取&#34;&gt;&lt;a href=&#34;#主题选取&#34; class=&#34;headerlink&#34; title=&#34;主题选取&#34;&gt;&lt;/a&gt;主题选取&lt;/h2&gt;&lt;p&gt;一个博客的功能上限，很大程度上是取决于这个主题给你提供的功能，因此一个好的主题很重要&lt;br&gt;主题的选取，可以看我的另一篇文章&lt;a href=&#34;https://lianga1.github.io/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/&#34;&gt;Hexo主题模板切换&lt;/a&gt;&lt;br&gt;但是大部分时候我们用的功能不会很多，而基础的功能，例如归档，友链，个人介绍等功能，绝大部分的主题都具备。所以仅需要挑选好看的主题即可，关于主题的美观问题，我们放在&lt;a href=&#34;.#%E7%BE%8E%E8%A7%82%E8%AE%BE%E7%BD%AE&#34;&gt;美观设置&lt;/a&gt;模块说。&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/theme1.jpg&#34; alt=&#34;theme&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;导航栏&#34;&gt;&lt;a href=&#34;#导航栏&#34; class=&#34;headerlink&#34; title=&#34;导航栏&#34;&gt;&lt;/a&gt;导航栏&lt;/h2&gt;&lt;p&gt;导航栏是一个博客的门面。设置好导航栏，你的博客会非常的有条理。&lt;/p&gt;
&lt;h3 id=&#34;归档与标签&#34;&gt;&lt;a href=&#34;#归档与标签&#34; class=&#34;headerlink&#34; title=&#34;归档与标签&#34;&gt;&lt;/a&gt;归档与标签&lt;/h3&gt;&lt;p&gt;如果读者想找一篇文章,总不能让读者去挨篇文章翻吧，所以，在写文章的时候，做好标签设置和归档工作，是写一篇文章的必要工作。那么，如何归档呢？&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/categories.jpg&#34; alt=&#34;categories&#34;&gt;&lt;br&gt;在md语法中，我们可以在文章顶部的标签部分，加入如下几行&lt;/p&gt;
&lt;figure class=&#34;highlight subunit&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs subunit&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;tags:&lt;/span&gt;&lt;br&gt;- 标签1&lt;br&gt;- 标签2&lt;br&gt;……&lt;br&gt;- 标签n&lt;br&gt;categories: &lt;br&gt;- 一级目录&lt;br&gt;- 二级目录&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/font&gt;：tags和categories必须无缩进，否则在生成html时会报错&lt;/p&gt;
&lt;p&gt;这样，你就拥有了一个可以从标签和分级目录中查询的文章了&lt;/p&gt;
&lt;h3 id=&#34;下一步，友链与作者链接&#34;&gt;&lt;a href=&#34;#下一步，友链与作者链接&#34; class=&#34;headerlink&#34; title=&#34;下一步，友链与作者链接&#34;&gt;&lt;/a&gt;下一步，友链与作者链接&lt;/h3&gt;&lt;p&gt;&lt;font color=&#34;Red&#34; size=&#34;6&#34;&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/font&gt;，本文之后的内容以Fluid主题为准，其他主题大同小异，具体操作可以参照主题的介绍文档。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为什么把友链放到前面说呢，&lt;del&gt;当然是因为我最开始没管作者链接&lt;/del&gt;，是因为友链的设置更加简单&lt;br&gt;我们需要在主题的_config.yml中（以下如果没有特殊说明，都是themes下的配置文件），在navbar：menu里，加入links，如下&lt;br&gt;&lt;code&gt; - &amp;#123; key: &amp;quot;links&amp;quot;, link: &amp;quot;/links/&amp;quot;, icon: &amp;quot;iconfont icon-link-fill&amp;quot; &amp;#125;&lt;/code&gt;&lt;br&gt;这样就可以&lt;br&gt;然后找到links部分&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/links.jpg&#34; alt=&#34;links&#34;&gt;&lt;br&gt;将enable改为true即可，这样，我们的主页导航栏就会出现“友链”了。&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/links2.jpg&#34; alt=&#34;links2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=&#34;4&#34;&gt;如何添加友链呢&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;只需要在config文件中的links模块下的item中，按照如下格式添加即可&lt;/p&gt;
&lt;figure class=&#34;highlight dts&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs dts&#34;&gt;- &amp;#123;&lt;br&gt;&lt;span class=&#34;hljs-symbol&#34;&gt;      title:&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;rittmeister&amp;quot;&lt;/span&gt;,&lt;br&gt;&lt;span class=&#34;hljs-symbol&#34;&gt;      intro:&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;xxx的博客&amp;quot;&lt;/span&gt;,&lt;br&gt;&lt;span class=&#34;hljs-symbol&#34;&gt;      link:&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;https://lianga1.github.io/&amp;quot;&lt;/span&gt;,&lt;br&gt;&lt;span class=&#34;hljs-symbol&#34;&gt;      avatar:&lt;/span&gt; &lt;span class=&#34;hljs-string&#34;&gt;&amp;quot;/img/avatar.png&amp;quot;&lt;/span&gt;&lt;br&gt;    &amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中avatar是图标，存在主题文件夹下&amp;#x2F;source&amp;#x2F;img文件夹中，你可以根据喜好来更改&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来是作者链接，作者链接略微复杂&lt;br&gt;首先，我们需要在config文件中，找到about：模块&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/about1.jpg&#34; alt=&#34;about&#34;&gt;&lt;br&gt;确认是enable状态&lt;br&gt;当然，我们现在博客中点击这个页面，会显示404&lt;br&gt;原因是我们需要创建一个专门的about页面，方法如下，cmd输入代码&lt;br&gt;&lt;code&gt;hexo new page about&lt;/code&gt;&lt;br&gt;即会在source文件夹创建一个about文件夹，里面有一个index.md文件，进入&lt;br&gt;在标签部分，添加&lt;br&gt;&lt;code&gt;layout: about&lt;/code&gt;&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/about2.jpg&#34; alt=&#34;about&#34;&gt;&lt;br&gt;这样，我们就会发现作者链接可以进入了。然后，我们可以在config-about模块，添加自己想要的功能。&lt;br&gt;例如我还添加了微信二维码&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/about3.jpg&#34; alt=&#34;about3&#34;&gt;&lt;br&gt;除此之外，fluid提供了丰富的图标库，可以在其doc中查询css的使用方法，这里不展开介绍了&lt;/p&gt;
&lt;h3 id=&#34;一些其他的骚操作&#34;&gt;&lt;a href=&#34;#一些其他的骚操作&#34; class=&#34;headerlink&#34; title=&#34;一些其他的骚操作&#34;&gt;&lt;/a&gt;一些其他的骚操作&lt;/h3&gt;&lt;p&gt;你还可以直接加一些新的链接，还是在navbar：menu部分里加，比如我就新加了一个tape提问箱，妈妈再也不用担心没人提问了&lt;br&gt;&lt;del&gt;笑死，自闭症患儿罢了，哪有人去你的博客提问啊&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;懒加载&#34;&gt;&lt;a href=&#34;#懒加载&#34; class=&#34;headerlink&#34; title=&#34;懒加载&#34;&gt;&lt;/a&gt;懒加载&lt;/h2&gt;&lt;p&gt;这个功能还是蛮有用的，单独开出来说一下&lt;br&gt;这个是可以让你的网页先加载，图片慢慢加载的功能，毕竟你的github服务器，如果等所有封面图都加载出来，黄花菜都凉了&lt;br&gt;实现方法：&lt;br&gt;config文件中lazyload：模块，enable设为true即可&lt;/p&gt;
&lt;h1 id=&#34;美观设置&#34;&gt;&lt;a href=&#34;#美观设置&#34; class=&#34;headerlink&#34; title=&#34;美观设置&#34;&gt;&lt;/a&gt;美观设置&lt;/h1&gt;&lt;p&gt;我个人很有自知之明，知道我的审美能力一般，这里仅提供一些方法上的指导&lt;/p&gt;
&lt;h2 id=&#34;背景图&#34;&gt;&lt;a href=&#34;#背景图&#34; class=&#34;headerlink&#34; title=&#34;背景图&#34;&gt;&lt;/a&gt;背景图&lt;/h2&gt;&lt;p&gt;（施工中——2022.4.22半夜一点半）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;（4.23更新）&lt;br&gt;背景图是博客的门面，选一张得体的背景图，可以极大的提高博客的氛围感，甚至可以增加阅读体验，以下介绍一下插入背景图的方法&lt;/p&gt;
&lt;h3 id=&#34;主页背景图&#34;&gt;&lt;a href=&#34;#主页背景图&#34; class=&#34;headerlink&#34; title=&#34;主页背景图&#34;&gt;&lt;/a&gt;主页背景图&lt;/h3&gt;&lt;p&gt;主页背景图，我推荐构图简单，色彩主调统一的图片，否则背景图上的字会显示不清。&lt;br&gt;修改背景图的方法很简单，在config文件中，搜索&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;banner_img&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个是所有背景图的关键词，因此你可以搜索到17个词&lt;br&gt;找到index模块下的banner_img&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/banner1.jpg&#34; alt=&#34;banner_img&#34;&gt;&lt;br&gt;其后面的目录是主题的source文件夹下的目录，只需要把你想要的图片放在这个目录下，并在config中替换即可&lt;/p&gt;
&lt;h3 id=&#34;其他背景图&#34;&gt;&lt;a href=&#34;#其他背景图&#34; class=&#34;headerlink&#34; title=&#34;其他背景图&#34;&gt;&lt;/a&gt;其他背景图&lt;/h3&gt;&lt;p&gt;emm，其他的背景图嘛，我希望你可以找到一套图，来和主页的背景映衬而且又各具特色，但是目前我还没有找到这种理想的图包。&lt;/p&gt;
&lt;h2 id=&#34;文章封面图&#34;&gt;&lt;a href=&#34;#文章封面图&#34; class=&#34;headerlink&#34; title=&#34;文章封面图&#34;&gt;&lt;/a&gt;文章封面图&lt;/h2&gt;&lt;p&gt;文章封面图的设置，是在文章的顶部内容栏中加入index_img: 一行&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/index_img1.jpg&#34; alt=&#34;index_img&#34;&gt;&lt;br&gt;然后，图片的位置是你的&lt;font color=&#34;Red&#34; size=&#34;6&#34;&gt;&lt;strong&gt;主题目录下&lt;/strong&gt;&lt;/font&gt;的source&amp;#x2F;img文件夹，这里我建议给你的每篇文章进行归档，方便整理。&lt;br&gt;这样，你的博客文章就有封面图了&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/index_img2.jpg&#34; alt=&#34;index_img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;图片加载动画&#34;&gt;&lt;a href=&#34;#图片加载动画&#34; class=&#34;headerlink&#34; title=&#34;图片加载动画&#34;&gt;&lt;/a&gt;图片加载动画&lt;/h2&gt;&lt;p&gt;如果我们打开了懒加载功能，那么我们就会看到图片加载时会有一个动画，这里的加载其实是一个gif，和图片一样，我们也是可以更换的，比如换成一个跑步的Mario&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/mario.gif&#34; alt=&#34;mario&#34;&gt;&lt;br&gt;下面介绍一下设置方法：&lt;br&gt;在config文件中找到lazyload模块，然后，找到loading_img&lt;br&gt;改为你在主题的source中的路径&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/loading.jpg&#34; alt=&#34;loading&#34;&gt;&lt;br&gt;以上，操作完成。&lt;/p&gt;
&lt;h2 id=&#34;关于导航栏的一些玩法&#34;&gt;&lt;a href=&#34;#关于导航栏的一些玩法&#34; class=&#34;headerlink&#34; title=&#34;关于导航栏的一些玩法&#34;&gt;&lt;/a&gt;关于导航栏的一些玩法&lt;/h2&gt;&lt;p&gt;导航栏，美化是一个可以深入折腾的天地，简单介绍几个玩法&lt;/p&gt;
&lt;h3 id=&#34;毛玻璃特效&#34;&gt;&lt;a href=&#34;#毛玻璃特效&#34; class=&#34;headerlink&#34; title=&#34;毛玻璃特效&#34;&gt;&lt;/a&gt;毛玻璃特效&lt;/h3&gt;&lt;p&gt;这个可以让你的导航栏显示成亚克力效果&lt;br&gt;只需要在config文件的navbar模块下，ground_glass设置为enable：true即可，下面还可以调节模糊的颜色，模糊程度等。&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/navbar1.jpg&#34; alt=&#34;ground_glass&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;自己的名字&#34;&gt;&lt;a href=&#34;#自己的名字&#34; class=&#34;headerlink&#34; title=&#34;自己的名字&#34;&gt;&lt;/a&gt;自己的名字&lt;/h3&gt;&lt;p&gt;你可以在导航栏的左侧标注你的名字，具体操作类似上条：&lt;br&gt;&lt;code&gt;navbar--blog_title&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;菜单图标&#34;&gt;&lt;a href=&#34;#菜单图标&#34; class=&#34;headerlink&#34; title=&#34;菜单图标&#34;&gt;&lt;/a&gt;菜单图标&lt;/h3&gt;&lt;p&gt;菜单上的选项，你可以设置图标&lt;br&gt;方法如下：&lt;br&gt;在navbar–menu模块下，找到对应的菜单栏选项，在icon：位置，根据自己的需要，选择对应的css&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87&#34;&gt;css库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于标签栏的一些玩法&#34;&gt;&lt;a href=&#34;#关于标签栏的一些玩法&#34; class=&#34;headerlink&#34; title=&#34;关于标签栏的一些玩法&#34;&gt;&lt;/a&gt;关于标签栏的一些玩法&lt;/h2&gt;&lt;h3 id=&#34;标签栏中显示的图标&#34;&gt;&lt;a href=&#34;#标签栏中显示的图标&#34; class=&#34;headerlink&#34; title=&#34;标签栏中显示的图标&#34;&gt;&lt;/a&gt;标签栏中显示的图标&lt;/h3&gt;&lt;p&gt;我们当然想让自己的名字显示在浏览器标签栏上来代替那个&lt;del&gt;丑陋的&lt;/del&gt;Hexo标识，我们可以在config文件中的&lt;/p&gt;
&lt;figure class=&#34;highlight avrasm&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs avrasm&#34;&gt;&lt;span class=&#34;hljs-symbol&#34;&gt;favicon:&lt;/span&gt;&lt;br&gt;以及&lt;br&gt;&lt;span class=&#34;hljs-symbol&#34;&gt;apple_touch_icon:&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这两项中，改变自己想要的图片，同样，图片的位置是&amp;#x2F;img&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/favicon.jpg&#34; alt=&#34;favicon&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;标签栏的名字&#34;&gt;&lt;a href=&#34;#标签栏的名字&#34; class=&#34;headerlink&#34; title=&#34;标签栏的名字&#34;&gt;&lt;/a&gt;标签栏的名字&lt;/h3&gt;&lt;p&gt;改了图标，我们当然想要把“Hexo”改变为自己想要的名字&lt;br&gt;&lt;font color=&#34;Red&#34; size=&#34;6&#34;&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/font&gt;，这个是要在blog目录下的config文件更改，不要在主题配置里找！&lt;br&gt;在config文件中，找到site模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/sitename.jpg&#34; alt=&#34;sitename&#34;&gt;&lt;br&gt;将其title设置为你想要的内容即可&lt;/p&gt;
&lt;h3 id=&#34;标签栏的连接符&#34;&gt;&lt;a href=&#34;#标签栏的连接符&#34; class=&#34;headerlink&#34; title=&#34;标签栏的连接符&#34;&gt;&lt;/a&gt;标签栏的连接符&lt;/h3&gt;&lt;p&gt;当你打开一个文章页面或其他页面时，你会发现：标签栏名称变为&lt;br&gt;&lt;code&gt;“页面名”-“站点名”&lt;/code&gt;&lt;br&gt;其实，中间的这个衔接符号，我们也是可以更改的，只需要在主题config文件中&lt;br&gt;找到“tab_title_separator:”模块&lt;br&gt;即可将其改为你想要的内容&lt;br&gt;&lt;img src=&#34;/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/linker.jpg&#34; alt=&#34;linker&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;（4.24施工完毕，还有一些内容，回头再说了）&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
            <title>关于解决无法上传图片的问题</title>
            <link>http://example.com/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/</link>
            <category>技术</category>
            <category>博客</category>
            <category>markdown</category>
            <pubDate>Mon, 18 Apr 2022 23:45:02 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;问题&#34;&gt;&lt;a href=&#34;#问题&#34; class=&#34;headerlink&#34; title=&#34;问题&#34;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;事情是这样的，我在写博客的时候发现，我的图片即使以正确的格式引用，依旧会出现无法加载的问题&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/problem.jpg&#34; alt=&#34;问题如图&#34;&gt;&lt;/p&gt;
&lt;p&gt;众所周知，没有图片，你写个啥都没法直观地展示，就好像pre时用txt做演示，大家嘴上不说什么，心里肯定知道&lt;del&gt;你是忘了做ppt了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;总之，根据我一晚上的研究成果，整理出来了几个解决图片无法显示的问题的方法供大家参考。&lt;/p&gt;
&lt;h1 id=&#34;解决方法&#34;&gt;&lt;a href=&#34;#解决方法&#34; class=&#34;headerlink&#34; title=&#34;解决方法&#34;&gt;&lt;/a&gt;解决方法&lt;/h1&gt;&lt;h2 id=&#34;目录&#34;&gt;&lt;a href=&#34;#目录&#34; class=&#34;headerlink&#34; title=&#34;目录&#34;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;一共有这么几个方法，大家可以都试试，挑一个自己最喜欢的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./#%E5%9B%BE%E5%BA%8A%E6%B3%95&#34;&gt;图床法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github&amp;amp;gitee图床&lt;/li&gt;
&lt;li&gt;图床网站&lt;/li&gt;
&lt;li&gt;PicGo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./#%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%BC%A0%E6%B3%95&#34;&gt;本地上传法&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图床法&#34;&gt;&lt;a href=&#34;#图床法&#34; class=&#34;headerlink&#34; title=&#34;图床法&#34;&gt;&lt;/a&gt;图床法&lt;/h2&gt;&lt;p&gt;是这样的，一般来说，你的hexo博客在部署到服务器时，不会给你上传那些文章里链接的图片的，所以你的md文章里链接的图片一般情况下是无法上传的，自然就无法加载出来，但是你的图片如果是网络图片，直接链接网址，就可以通过联网加载的方式显示有如下几种方法&lt;/p&gt;
&lt;h3 id=&#34;Github-amp-Gitee仓库图床&#34;&gt;&lt;a href=&#34;#Github-amp-Gitee仓库图床&#34; class=&#34;headerlink&#34; title=&#34;Github&amp;amp;Gitee仓库图床&#34;&gt;&lt;/a&gt;Github&amp;amp;Gitee仓库图床&lt;/h3&gt;&lt;p&gt;这个的原理就是让你的公有仓库变成图床，白嫖存储空间&lt;/p&gt;
&lt;h4 id=&#34;操作流程&#34;&gt;&lt;a href=&#34;#操作流程&#34; class=&#34;headerlink&#34; title=&#34;操作流程&#34;&gt;&lt;/a&gt;操作流程&lt;/h4&gt;&lt;p&gt;具体来说，github和gitee方法相似，这里仅介绍github，gitee方法类似&lt;br&gt;gitee的访问速度会更快一点，github的容量没有限制，可以自己取舍&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册一个github账户&lt;/li&gt;
&lt;li&gt;创建一个新的公有库，注意一定是&lt;strong&gt;公有&lt;/strong&gt;，否则外部无法访问&lt;/li&gt;
&lt;li&gt;在库存中创建一个文件夹&lt;br&gt; &lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/github.jpg&#34; alt=&#34;add_a_file&#34;&gt;&lt;/li&gt;
&lt;li&gt;把你的图片上传&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/upload.jpg&#34; alt=&#34;upload&#34;&gt;&lt;/li&gt;
&lt;li&gt;点击你的图片，复制地址框中的地址，注意要把bolb改为raw&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/raw.jpg&#34; alt=&#34;raw&#34;&gt;&lt;/li&gt;
&lt;li&gt;然后就可以在你的博客里引用这个地址了！&lt;blockquote&gt;
&lt;p&gt;你可以用cdn加速github，比如Jsdelivr，加速方法不在本文讨论范围&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;图床网站&#34;&gt;&lt;a href=&#34;#图床网站&#34; class=&#34;headerlink&#34; title=&#34;图床网站&#34;&gt;&lt;/a&gt;图床网站&lt;/h3&gt;&lt;p&gt;上面说的只是把github当作一个公开访问的图片网站，当然，市面上还有很多的专用图床网站，免费的付费的都有，这里介绍一个免费的网站&lt;a href=&#34;https://imgtu.com/&#34;&gt;imgtu.com&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开网站，上传图片&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/image.jpg&#34; alt=&#34;image&#34;&gt;&lt;blockquote&gt;
&lt;p&gt;注意不能挂梯子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;上传完成后，在底部链接栏，找到md链接，复制粘贴到你的文章插图位置就ok了&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/save_the_link.jpg&#34; alt=&#34;save_the_link&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个方法还是比较简单的,基本上有手就行，没手的话，&lt;del&gt;那你也别搞博客了&lt;/del&gt;&lt;/p&gt;
&lt;h3 id=&#34;PicGo&#34;&gt;&lt;a href=&#34;#PicGo&#34; class=&#34;headerlink&#34; title=&#34;PicGo&#34;&gt;&lt;/a&gt;PicGo&lt;/h3&gt;&lt;p&gt;除了以上介绍的两种方法，还有一个比较“软件化”的方案，就是&lt;a href=&#34;https://molunerfinn.com/PicGo/&#34;&gt;PicGo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PicGo是一个开源的软件，它的优点是方便快捷，不用登网站，操作比较easy，而且集成了很多平台。&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/PicGo.jpg&#34; alt=&#34;PicGo&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;操作方法&#34;&gt;&lt;a href=&#34;#操作方法&#34; class=&#34;headerlink&#34; title=&#34;操作方法&#34;&gt;&lt;/a&gt;操作方法&lt;/h4&gt;&lt;p&gt;还是以GitHub为例，首先我们进入&lt;strong&gt;图床设置&lt;/strong&gt;-&amp;gt;&lt;strong&gt;Github&lt;/strong&gt;&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/picgo_github.jpg&#34; alt=&#34;picgo_github&#34;&gt;&lt;br&gt;在对应的框里输入信息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储路径是你的GitHub仓库里的路径，没有时会创建&lt;br&gt;自定义域名就是你可以用cdn加速访问图片，最后两级就是你的用户名和仓库名&lt;br&gt;下面介绍一下token的获取方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;获取Github-Token&#34;&gt;&lt;a href=&#34;#获取Github-Token&#34; class=&#34;headerlink&#34; title=&#34;获取Github Token&#34;&gt;&lt;/a&gt;获取Github Token&lt;/h5&gt;&lt;p&gt;首先从个人列表进入settings&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token1.jpg&#34; alt=&#34;token1&#34;&gt;&lt;br&gt;然后进入最底部的developer settings&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token2.jpg&#34; alt=&#34;token2&#34;&gt;&lt;br&gt;然后进入Personal access tokens，点generate new token&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token3.jpg&#34; alt=&#34;token3&#34;&gt;&lt;br&gt;按照如下操作&lt;br&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token4.jpg&#34; alt=&#34;token4&#34;&gt;&lt;br&gt;生成后记得复制，这个token&lt;font color=&#34;Red&#34; size=&#34;6&#34;&gt;&lt;strong&gt;只会出现一次&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;至此，PicGo的使用介绍就完成了&lt;/p&gt;
&lt;h2 id=&#34;本地上传法&#34;&gt;&lt;a href=&#34;#本地上传法&#34; class=&#34;headerlink&#34; title=&#34;本地上传法&#34;&gt;&lt;/a&gt;本地上传法&lt;/h2&gt;&lt;h2 id=&#34;（施工中，累了，明天再说）&#34;&gt;&lt;a href=&#34;#（施工中，累了，明天再说）&#34; class=&#34;headerlink&#34; title=&#34;（施工中，累了，明天再说）&#34;&gt;&lt;/a&gt;（施工中，累了，明天再说）&lt;/h2&gt;&lt;p&gt;2022.4.20更新&lt;/p&gt;
&lt;p&gt;继续说本地上传法&lt;/p&gt;
&lt;p&gt;我们之前说过，本地的图片是不会被hexo上传的，其实这个说法不严谨&lt;br&gt;严格来说，是你凭空放一张图片，无法上传&lt;br&gt;但是，我们可以通过一个方法来上传本地图片，那就是hexo-asset-image。&lt;/p&gt;
&lt;h3 id=&#34;操作方法-1&#34;&gt;&lt;a href=&#34;#操作方法-1&#34; class=&#34;headerlink&#34; title=&#34;操作方法&#34;&gt;&lt;/a&gt;操作方法&lt;/h3&gt;&lt;p&gt;首先安装hexo-asset-image&lt;br&gt;&lt;code&gt;npm install https://github.com/CodeFalling/hexo-asset-image --save&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意，如果你安装速度慢的话，可以讲npm换为淘宝镜像，切换方法如下：&lt;br&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org&lt;/code&gt;&lt;br&gt;安装完成后，我们要在_config.yml中作如下更改&lt;blockquote&gt;
&lt;p&gt; 将 post_asset_folder 设置为true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/post.jpg&#34; alt=&#34;post&#34;&gt;&lt;br&gt;然后，每当我们新建一篇博客时，就会有一个同名文件夹在_post文件夹中生成了&lt;br&gt;我们把需要插入的图片放到这个文件夹里面，在文章中引用格式如下&lt;br&gt;&lt;code&gt;![图片描述]（./包名/NO.01.001.jpg）&lt;/code&gt;&lt;br&gt;&lt;font size=&#34;5&#34;&gt;或者&lt;/font&gt;&lt;br&gt;&lt;code&gt;![logo](logo.jpg)&lt;/code&gt;&lt;br&gt;就可以了，这个方法也是我在用的方法，非常方便，缺点是对服务器压力比较大。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;&lt;a href=&#34;#总结&#34; class=&#34;headerlink&#34; title=&#34;总结&#34;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;上述的几个方法，各有优缺点，可以结合自己的特点来使用&lt;br&gt;注意图片描述必须是全英文，否则无法显示图片&lt;br&gt;希望有所帮助&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/</guid>
            <title>Hexo主题模板切换</title>
            <link>http://example.com/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/</link>
            <category>技术</category>
            <category>博客</category>
            <category>markdown</category>
            <pubDate>Mon, 18 Apr 2022 20:56:34 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;下载主题&#34;&gt;&lt;a href=&#34;#下载主题&#34; class=&#34;headerlink&#34; title=&#34;下载主题&#34;&gt;&lt;/a&gt;下载主题&lt;/h1&gt;&lt;p&gt;首先，我们找一个比较好看的主题，比如我找的Fluid&lt;br&gt;&lt;img src=&#34;/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/fluid.jpg&#34; alt=&#34;fluid网址：https://hexo.fluid-dev.com &#34;&gt;&lt;/p&gt;
&lt;p&gt;找到了这个主题的&lt;a href=&#34;https://github.com/fluid-dev/hexo-theme-fluid&#34;&gt;github网址&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;然后呢，我们需要在cmd中输入一行神秘代码&lt;br&gt;&lt;code&gt;git clone https://github.com/fluid-dev/hexo-theme-fluid themes\fluid&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;git clone 是在GitHub上下载的命令，中间的部分是这个主题的网址，最后是你在blog目录下需要把这个下载的主题存到的位置，系统会自动创建空的文件夹。&lt;/p&gt;
&lt;p&gt;然后静待下载，下载完成后，我们的工作就成功了一大半了！&lt;/p&gt;
&lt;h1 id=&#34;应用主题&#34;&gt;&lt;a href=&#34;#应用主题&#34; class=&#34;headerlink&#34; title=&#34;应用主题&#34;&gt;&lt;/a&gt;应用主题&lt;/h1&gt;&lt;p&gt;应用主题的方法很简单，只需要打开blog目录下的_config.yml文件，把倒数第二个部分的“theme：”改为你的主题所在文件夹的名字就OK了。&lt;br&gt;&lt;img src=&#34;/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/config.jpg&#34; alt=&#34;这样&#34;&gt;&lt;/p&gt;
&lt;p&gt;别忘了部署到服务器！&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2021/08/24/md%E8%AF%AD%E6%B3%95%E8%AF%95%E9%AA%8C/</guid>
            <title>md语法试验</title>
            <link>http://example.com/2021/08/24/md%E8%AF%AD%E6%B3%95%E8%AF%95%E9%AA%8C/</link>
            <category>技术</category>
            <category>博客</category>
            <category>markdown</category>
            <pubDate>Tue, 24 Aug 2021 15:32:52 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;分层&#34;&gt;&lt;a href=&#34;#分层&#34; class=&#34;headerlink&#34; title=&#34;分层&#34;&gt;&lt;/a&gt;分层&lt;/h1&gt;&lt;h2 id=&#34;二级目录&#34;&gt;&lt;a href=&#34;#二级目录&#34; class=&#34;headerlink&#34; title=&#34;二级目录&#34;&gt;&lt;/a&gt;二级目录&lt;/h2&gt;&lt;h3 id=&#34;列表&#34;&gt;&lt;a href=&#34;#列表&#34; class=&#34;headerlink&#34; title=&#34;列表&#34;&gt;&lt;/a&gt;列表&lt;/h3&gt;&lt;h4 id=&#34;无序列表&#34;&gt;&lt;a href=&#34;#无序列表&#34; class=&#34;headerlink&#34; title=&#34;无序列表&#34;&gt;&lt;/a&gt;无序列表&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;小标&lt;/li&gt;
&lt;li&gt;无序&lt;/li&gt;
&lt;li&gt;各种符号都行&lt;ul&gt;
&lt;li&gt;第二层嵌套&lt;ul&gt;
&lt;li&gt;第n层嵌套&lt;h4 id=&#34;有序列表&#34;&gt;&lt;a href=&#34;#有序列表&#34; class=&#34;headerlink&#34; title=&#34;有序列表&#34;&gt;&lt;/a&gt;有序列表&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;有序列表&lt;/li&gt;
&lt;li&gt;第一行序号为起始序号&lt;/li&gt;
&lt;li&gt;即使后面序号错误也会顺序下排&lt;ol&gt;
&lt;li&gt;嵌套效果&lt;h2 id=&#34;内容&#34;&gt;&lt;a href=&#34;#内容&#34; class=&#34;headerlink&#34; title=&#34;内容&#34;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;h3 id=&#34;引用说明&#34;&gt;&lt;a href=&#34;#引用说明&#34; class=&#34;headerlink&#34; title=&#34;引用说明&#34;&gt;&lt;/a&gt;引用说明&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;引用内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二级引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三级引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;代码块&#34;&gt;&lt;a href=&#34;#代码块&#34; class=&#34;headerlink&#34; title=&#34;代码块&#34;&gt;&lt;/a&gt;代码块&lt;/h3&gt;&lt;p&gt;&lt;code&gt;少量代码，单行使用，用·包裹&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&#34;highlight&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs&#34;&gt;&lt;br&gt;大量代码多行使用，用三个·包裹&lt;br&gt;大量代码多行使用，用三个·包裹&lt;br&gt;大量代码多行使用，用三个·包裹&lt;br&gt;大量代码多行使用，用三个·包裹&lt;br&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;链接&#34;&gt;&lt;a href=&#34;#链接&#34; class=&#34;headerlink&#34; title=&#34;链接&#34;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;h3 id=&#34;网页链接&#34;&gt;&lt;a href=&#34;#网页链接&#34; class=&#34;headerlink&#34; title=&#34;网页链接&#34;&gt;&lt;/a&gt;网页链接&lt;/h3&gt;&lt;h4 id=&#34;行内式&#34;&gt;&lt;a href=&#34;#行内式&#34; class=&#34;headerlink&#34; title=&#34;行内式&#34;&gt;&lt;/a&gt;行内式&lt;/h4&gt;&lt;p&gt;链接放在【】中，地址放在后面的小括号中，引号内是title&lt;br&gt;&lt;a href=&#34;www.baidu.com&#34; title=&#34;百度一下，你就知道&#34;&gt;百度&lt;/a&gt;&lt;br&gt;[百度]是一个搜索引擎&lt;/p&gt;
&lt;h4 id=&#34;参数式&#34;&gt;&lt;a href=&#34;#参数式&#34; class=&#34;headerlink&#34; title=&#34;参数式&#34;&gt;&lt;/a&gt;参数式&lt;/h4&gt;&lt;p&gt;链接在【】内，地址在冒号后面，title用引号&lt;br&gt;[百度]:&lt;a href=&#34;http://www.baidu.com/&#34;&gt;www.baidu.com&lt;/a&gt; “百度一下，你就知道”&lt;br&gt;[百度]是一个搜索引擎&lt;/p&gt;
&lt;h3 id=&#34;图片&#34;&gt;&lt;a href=&#34;#图片&#34; class=&#34;headerlink&#34; title=&#34;图片&#34;&gt;&lt;/a&gt;图片&lt;/h3&gt;&lt;p&gt;与链接基本一致，注意在引用图片时【】前加上！&lt;br&gt;&lt;img src=&#34;/2021/08/24/md%E8%AF%AD%E6%B3%95%E8%AF%95%E9%AA%8C/download\edge\13623636-6d878e3d3ef63825&#34; alt=&#34;logo&#34;&gt; “my logo”&lt;/p&gt;
&lt;h2 id=&#34;工整&#34;&gt;&lt;a href=&#34;#工整&#34; class=&#34;headerlink&#34; title=&#34;工整&#34;&gt;&lt;/a&gt;工整&lt;/h2&gt;&lt;h3 id=&#34;分割线&#34;&gt;&lt;a href=&#34;#分割线&#34; class=&#34;headerlink&#34; title=&#34;分割线&#34;&gt;&lt;/a&gt;分割线&lt;/h3&gt;&lt;h2 id=&#34;由-这三种之一的三个符号表示&#34;&gt;&lt;a href=&#34;#由-这三种之一的三个符号表示&#34; class=&#34;headerlink&#34; title=&#34;由* - _这三种之一的三个符号表示&#34;&gt;&lt;/a&gt;由* - _这三种之一的三个符号表示&lt;/h2&gt;&lt;p&gt;这就是分割线&lt;/p&gt;
&lt;h3 id=&#34;表格&#34;&gt;&lt;a href=&#34;#表格&#34; class=&#34;headerlink&#34; title=&#34;表格&#34;&gt;&lt;/a&gt;表格&lt;/h3&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F;例子&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;123&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;234&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;345&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;abc&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bcd&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;cde&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&#34;其他&#34;&gt;&lt;a href=&#34;#其他&#34; class=&#34;headerlink&#34; title=&#34;其他&#34;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;h3 id=&#34;强调字体&#34;&gt;&lt;a href=&#34;#强调字体&#34; class=&#34;headerlink&#34; title=&#34;强调字体&#34;&gt;&lt;/a&gt;强调字体&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;强调字体&lt;br&gt; 用星号包裹，如&lt;em&gt;md&lt;/em&gt;,&lt;strong&gt;md&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;转义&lt;br&gt; 用\&lt;/li&gt;
&lt;li&gt;删除线&lt;br&gt; &lt;del&gt;删除&lt;/del&gt;&lt;/li&gt;
&lt;/ol&gt;
 ]]></description>
        </item>
    </channel>
</rss>
