{
    "version": "https://jsonfeed.org/version/1",
    "title": "意大利炮打友军 • All posts by \"博客\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B02/",
            "url": "http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B02/",
            "title": "大模型通信笔记2",
            "date_published": "2024-03-26T11:54:58.000Z",
            "content_html": "<h2 id=\"数据并行\"><a href=\"#数据并行\" class=\"headerlink\" title=\"数据并行\"></a>数据并行</h2><p>传统的数据并行是让每个GPU分别进行FWD和BWD，然后把梯度进行聚合操作，然后再下发给每个GPU，称为All Reduce。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>存储开销大。每块GPU上都存了一份完整的模型，造成冗余</li>\n<li>通讯开销大。Server需要和每一个Worker进行梯度传输。当Server和Worker不在一台机器上时，Server的带宽将会成为整个系统的计算效率瓶颈。</li>\n</ul>\n<h3 id=\"异步梯度更新\"><a href=\"#异步梯度更新\" class=\"headerlink\" title=\"异步梯度更新\"></a>异步梯度更新</h3><ul>\n<li>Worker不等待梯度更新，用旧的参数进行下一轮训练，可能会延迟一步更新梯度，整体收敛速度变慢，但是提升通讯计算比。</li>\n<li>延迟步数会指定</li>\n</ul>\n<h3 id=\"分布式数据并行\"><a href=\"#分布式数据并行\" class=\"headerlink\" title=\"分布式数据并行\"></a>分布式数据并行</h3><p>核心目标是降低通信压力，因此要将Server的通信压力转到Worker上，最简单的就是Ring-AllReduce。</p>\n<h4 id=\"Ring-Allreduce\"><a href=\"#Ring-Allreduce\" class=\"headerlink\" title=\"Ring Allreduce\"></a>Ring Allreduce</h4><p>核心思路是实现Reduce Scatter和All-Gather。GPU每次之和前后两个GPU通信，1卡给2卡发a号数据，2给3发b号，以此类推。三次更新后每张卡都有1个号的完整的数据。</p>\n<p>之后在进行All-Gather，依旧环形通信，把每个部分全聚合的都发给下一个，然后依此类推，3轮通信就可以覆盖所有。</p>\n<h2 id=\"显存开销\"><a href=\"#显存开销\" class=\"headerlink\" title=\"显存开销\"></a>显存开销</h2><p>数据并行中，每个卡都存储了所有参数，怎么办？</p>\n<p>在实际存储中，分为两部分存储：</p>\n<ul>\n<li>模型状态：包括参数，优化器，梯度等</li>\n<li>驻留数据：包括activation，碎片内存和缓冲区等。</li>\n</ul>\n<h2 id=\"优化措施\"><a href=\"#优化措施\" class=\"headerlink\" title=\"优化措施\"></a>优化措施</h2><h3 id=\"混合精度训练\"><a href=\"#混合精度训练\" class=\"headerlink\" title=\"混合精度训练\"></a>混合精度训练</h3><p>对于参数，activation，梯度，都使用fp16，对于参数（多存一份）和优化器使用fp32。<br>模型必存数据为$K\\phi$,那么最终总存储数据为$K\\phi + 4\\phi$<br>实际上，activation大小和batch有关，而且是可以抛弃的。</p>\n<h3 id=\"ZeRO-DP\"><a href=\"#ZeRO-DP\" class=\"headerlink\" title=\"ZeRO-DP\"></a>ZeRO-DP</h3><h4 id=\"第一步：优化器分割\"><a href=\"#第一步：优化器分割\" class=\"headerlink\" title=\"第一步：优化器分割\"></a>第一步：优化器分割</h4><p>每张卡只存储一部分优化器参数，在数据并行中，先通过AllReduce得到完整梯度，每个卡都更新自己的一部分梯度和参数，然后再AllGather。产生单卡通讯量$\\phi$。</p>\n<h4 id=\"第二步：梯度分割\"><a href=\"#第二步：梯度分割\" class=\"headerlink\" title=\"第二步：梯度分割\"></a>第二步：梯度分割</h4><p>经过FWD和BWD后，对梯度进行Reduce-Scatter，保证每张卡都有自己一份聚合梯度，用分割的优化器和梯度进行更新相应的W，然后再AllGather参数进行更新</p>\n<h4 id=\"第三步：参数分割\"><a href=\"#第三步：参数分割\" class=\"headerlink\" title=\"第三步：参数分割\"></a>第三步：参数分割</h4><p>FWD时，先All Gather一次参数，用完即弃。<br>BWD时，再All Gather一次参数，用完即弃<br>用自己的梯度进行一次All Gather得到完整梯度<br>更新参数，无需通信。</p>\n<h3 id=\"ZeRO-R\"><a href=\"#ZeRO-R\" class=\"headerlink\" title=\"ZeRO-R\"></a>ZeRO-R</h3><p>通过对驻留数据进行优化来实现显存使用减少和通信负载降低。</p>\n<h4 id=\"activation\"><a href=\"#activation\" class=\"headerlink\" title=\"activation\"></a>activation</h4><p>每块GPU上只维护部分的activation，需要时再聚合。或者重新计算。</p>\n<h4 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h4><p>通过使用固定大小的Buffer，降低通信次数，减少碎片信息发送，提高带宽利用率</p>\n<h4 id=\"碎片内存整合\"><a href=\"#碎片内存整合\" class=\"headerlink\" title=\"碎片内存整合\"></a>碎片内存整合</h4><h3 id=\"ZeRO-Offload\"><a href=\"#ZeRO-Offload\" class=\"headerlink\" title=\"ZeRO-Offload\"></a>ZeRO-Offload</h3><p>见论文，主要是把显存的优化器参数卸载到CPU内存。</p>\n",
            "tags": [
                "技术",
                "大模型训练",
                "博客",
                "通信"
            ]
        },
        {
            "id": "http://example.com/2024/03/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/",
            "url": "http://example.com/2024/03/26/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/",
            "title": "linux学习笔记3",
            "date_published": "2024-03-26T11:14:15.000Z",
            "content_html": "",
            "tags": [
                "技术",
                "博客",
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B01/",
            "url": "http://example.com/2024/03/26/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E4%BF%A1%E7%AC%94%E8%AE%B01/",
            "title": "大模型通信笔记1",
            "date_published": "2024-03-26T09:38:32.000Z",
            "content_html": "<h2 id=\"流水线并行\"><a href=\"#流水线并行\" class=\"headerlink\" title=\"流水线并行\"></a>流水线并行</h2><h3 id=\"朴素层并行\"><a href=\"#朴素层并行\" class=\"headerlink\" title=\"朴素层并行\"></a>朴素层并行</h3><p>朴素层并行，将模型拆分为多个层，放在不同的GPU上执行<br>但是问题很明显：</p>\n<ul>\n<li>GPU利用率低：任意时刻只有一个GPU在工作，其他GPU都在等待结果</li>\n<li>计算和通信没有重叠</li>\n<li>显存占用高，GPU1需要保存所有激活。等待参数更新完成</li>\n</ul>\n<h3 id=\"GPipe\"><a href=\"#GPipe\" class=\"headerlink\" title=\"GPipe\"></a>GPipe</h3><p>Gpipe将整个<strong>minibatch分为4个microbatch</strong>，然后由GPU0进行计算，之后每个microbatch计算完直接传递给GPU1，以此类推，进行整个前向、反向传播。<br>假设pipeline深度n，microbatch数量m，那么浪费的时间占比为：<br>$$<br>1-\\frac{m}{m+n-1}<br>$$<br>所以需要增加microbatch数量m<br>Gpipe在计算过程中，把中间激活用完即弃，因此节省了显存，但是增加了计算代价。</p>\n<h3 id=\"PipeDream\"><a href=\"#PipeDream\" class=\"headerlink\" title=\"PipeDream\"></a>PipeDream</h3><p>PipeDream在GPipe的基础上，在每个microbatch前向结束后就开始反向传播，节省了一些显存，bubble和Gpipe是一样的</p>\n<h3 id=\"数据并行可以和流水线并行同时进行\"><a href=\"#数据并行可以和流水线并行同时进行\" class=\"headerlink\" title=\"数据并行可以和流水线并行同时进行\"></a>数据并行可以和流水线并行同时进行</h3><p>对任意给定GPU，有两个通信部份，一部分包含所有相同层GPU进行All_Reduce(数据并行)。另一部分和上下层进行通信（流水线）。</p>\n<h2 id=\"张量并行\"><a href=\"#张量并行\" class=\"headerlink\" title=\"张量并行\"></a>张量并行</h2><p>张量并行分为两种情况：<strong>列划分</strong>和<strong>行划分</strong><br>列划分：<br>$$<br>XA &#x3D; X[A_1,A_2···A_n]&#x3D;[XA_1,XA_2,···,XA_n]<br>$$</p>\n<p>行划分：</p>\n<p>$$<br>\\mathbf{x}*A &#x3D; \\begin{bmatrix} x_1 &amp; x_2 &amp; \\cdots &amp; x_n \\end{bmatrix} * \\begin{bmatrix}A_1\\A_2\\A_3\\··· \\A_n\\end{bmatrix}&#x3D;X_1A_1+X_2A_2+X_3A_3···<br>$$</p>\n<p>对列并行来说，由于GeLU函数并不是线性的，因此需要在输出前进行一次通信来合并。</p>\n<h3 id=\"2D并行\"><a href=\"#2D并行\" class=\"headerlink\" title=\"2D并行\"></a>2D并行</h3><p>具体来说，两个矩阵的结果仍然需要串行的计算。但是，单个矩阵中的4个子矩阵可以使用2*2的处理器来并行计算。</p>\n<h3 id=\"2-5D并行\"><a href=\"#2-5D并行\" class=\"headerlink\" title=\"2.5D并行\"></a>2.5D并行</h3><p>这个就是在2D并行的基础上，左矩阵为两个2*2矩阵垂直拼接，那么这两个矩阵是可以分开计算的，所以可以8处理器并行计算。</p>\n<h2 id=\"3D并行\"><a href=\"#3D并行\" class=\"headerlink\" title=\"3D并行\"></a>3D并行</h2><p>流水线+数据+张量并行</p>\n<p>首先，每个节点8个GPU，共两个节点</p>\n<p>8个GPU，分为两组，每组负责一个Layer，一共四个组进行流水线并行。<br>每个组内，用两张卡进行张量并行，一个组分为两个张量小组。一个张量小组负责一个具体的张量运算。<br>对于两个张量小组之间，分享同一个batch不同的数据，在计算结束后两个小组之间要进行all reduce通信。</p>\n",
            "tags": [
                "技术",
                "大模型训练",
                "博客",
                "通信"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "url": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "title": "操作系统学习笔记2：多线程",
            "date_published": "2024-03-22T09:44:11.000Z",
            "content_html": "<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>现代软件大多支持多线程，相比于进程切换，线程共享代码段，数据段以及其他系统资源，但是拥有单独的寄存器和堆栈。<br>服务器采用多线程，可以减少创建进程的资源消耗，同时处理多个并发请求。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>响应性提高</li>\n<li>资源共享</li>\n<li>创建与切换更加经济</li>\n</ul>\n<h2 id=\"多核编程\"><a href=\"#多核编程\" class=\"headerlink\" title=\"多核编程\"></a>多核编程</h2><p>并行性 vs 并发性<br><strong>并行性</strong>：是同时执行多个任务<br><strong>并发性</strong>：是让每个任务都能取得进展，在单处理器上也能实现</p>\n<p>Amdahl定理：程序中只有S%可以串行执行时，优化比<br>$$\\eta \\leq \\frac{1}{S+\\frac{1-S}{N}}$$</p>\n<h3 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h3><ul>\n<li>分析一个任务是否可以多核</li>\n<li>平衡某些任务适合单独核心执行</li>\n<li>数据分割</li>\n<li>数据依赖，避免同步性受损</li>\n<li>调试程序</li>\n</ul>\n<h3 id=\"并行类型\"><a href=\"#并行类型\" class=\"headerlink\" title=\"并行类型\"></a>并行类型</h3>",
            "tags": [
                "技术",
                "博客",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "url": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "title": "操作系统学习笔记1",
            "date_published": "2024-03-22T07:52:53.000Z",
            "content_html": "<h2 id=\"内核设计\"><a href=\"#内核设计\" class=\"headerlink\" title=\"内核设计\"></a>内核设计</h2><h3 id=\"微内核\"><a href=\"#微内核\" class=\"headerlink\" title=\"微内核\"></a>微内核</h3><p>微内核实现了一个功能较少，但是容易扩展的内核架构，客户程序和不同的功能之间提供<strong>消息传递</strong>功能。除了必须内核功能外，功能组件都作为用户程序来实现。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>例如Solaris，有7种可以在运行时加载的模块。</p>\n<h3 id=\"混合架构例子\"><a href=\"#混合架构例子\" class=\"headerlink\" title=\"混合架构例子\"></a>混合架构例子</h3><ul>\n<li>MacOS X，其Mach内核提供了远程过程调用，进程间通信等功能。BSD内核提供了POSIX库和文件系统等功能。</li>\n<li>iOS基于MacOSX，在系统的顶层提供了媒体服务用来支持图形化，Cocoa Touch库提供了有触屏硬件支持的Objective-C API</li>\n<li>Android由Linux内核，增加了一套Dalvik虚拟机和核心库。采用基于Java的Android API用来进行Java开发。运行在Dalvik虚拟机。</li>\n</ul>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><h3 id=\"D-Trace\"><a href=\"#D-Trace\" class=\"headerlink\" title=\"D Trace\"></a>D Trace</h3><p>使用D语言</p>\n<p>这个工具可以动态探测运行系统。跟踪系统调用以及指令的运行环境（用户or内核）<br>DTrace提供内核探头，拥有内核运行的编译器，生成安全指令。通过调用创建的内核探头，执行<strong>启用控制块</strong>可以捕获一些数据。</p>\n<h2 id=\"操作系统生成\"><a href=\"#操作系统生成\" class=\"headerlink\" title=\"操作系统生成\"></a>操作系统生成</h2><p>SYSGEN程序用于配置和生成操作系统。系统安装可以有三种情况</p>\n<ul>\n<li>极端定制：修改源代码，重新编译系统生成</li>\n<li>极端通用：系统描述表已定义好安装的模块，直接激活</li>\n<li>折中：选择模块进行链接来生成</li>\n</ul>\n<h2 id=\"编程实例\"><a href=\"#编程实例\" class=\"headerlink\" title=\"编程实例\"></a>编程实例</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>头文件：</p>\n<ul>\n<li>linux&#x2F;init.h</li>\n<li>linux&#x2F;kernel.h</li>\n<li>linux.model.h</li>\n</ul>\n<p>重要函数：</p>\n<ul>\n<li>printk：存储到内核日志缓冲区，用dmesg访问，可以指定优先级</li>\n<li>module_init() &amp; module_exit():用于注册模块。</li>\n</ul>\n<p>编译好的内核模块，使用sudo insmod simple.ko来插入内核<br>使用sudo ramos simple来移除</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>kmalloc：分配内核内存 </p>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h2><p>进程是一个活动实体，包含代码、程序计数器、堆栈等。</p>\n<h3 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h3><p>包括：</p>\n<ul>\n<li>新进程：创建进程</li>\n<li>运行中：指令执行中</li>\n<li>等待：进程等待某个信号</li>\n<li>就绪：等待分配处理器</li>\n<li>终止：进程已完成</li>\n</ul>\n<h3 id=\"进程控制块\"><a href=\"#进程控制块\" class=\"headerlink\" title=\"进程控制块\"></a>进程控制块</h3><p>存储了一个进程的相关信息：</p>\n<ul>\n<li>进程状态</li>\n<li>程序计数器</li>\n<li>CPU寄存器</li>\n<li>CPU调度信息</li>\n<li>内存管理信息</li>\n<li>记账信息</li>\n<li>IO状态信息</li>\n</ul>\n<p>信息采用task_struct来表示，位于&lt;linux&#x2F;sched.h&gt;<br>这个结构还存储了父进程、子进程等。<br>linux系统使用一个current_state结构来指向当前运行的进程。</p>\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p>被加载运行的进程，进入<strong>任务队列</strong>，在内存中等待运行的就是<strong>就绪队列</strong>，等待IO的进程就放在对应的<strong>设备队列</strong>。</p>\n<p>对于整个流程，进程首先被创建，加入到就绪队列，之后被分配到CPU执行时，会有几种可能：</p>\n<ul>\n<li>发出IO请求，进入IO队列</li>\n<li>创建子进程，等待进程执行结束</li>\n<li>中断产生，被放回就绪队列</li>\n</ul>\n<h3 id=\"调度程序\"><a href=\"#调度程序\" class=\"headerlink\" title=\"调度程序\"></a>调度程序</h3><p>调度程序分为短期调度程序和长期调度程序。</p>\n<ul>\n<li>短期调度程序针对的程序IO请求频繁，决策时间较短。</li>\n<li>长期调度程序的创建和杀死速度都较慢，因此有更多时间进行调度。</li>\n</ul>\n<p>长期调度程序应选择IO于CPU密集型程序并重的进程。</p>\n<h3 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h3><p>切换进程需要切换状态，典型时间为几毫秒。</p>\n<h2 id=\"进程运行\"><a href=\"#进程运行\" class=\"headerlink\" title=\"进程运行\"></a>进程运行</h2><p>进程可以产生子进程，因此其组织结构是“树”。init进程是pid为1的进程</p>\n<p>重要的init子进程：</p>\n<ul>\n<li>kthreadd：创建额外内核进程。</li>\n<li>sshd：创建ssh连接</li>\n</ul>\n<p>ps -el 列出进程</p>\n<p>fork（）函数创建一个子进程，子进程复制父进程的地址空间。它们都执行fork之后的内容。父进程fork（）返回子进程pid。子进程返回0。父进程可能会需要wait子进程。</p>\n<p>注意：windows的createProcess函数不继承父进程空间，而是需要制定一个特定程序。</p>\n<p>父进程可以调用wait，让子进程（僵尸进程）标识符得到释放。并且如果父进程先被终止，如果没有级连终止的要求下，init进程成为子进程的父。</p>\n<h2 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2><p>进程和其他进程通信称为协作。进程间协作机制称为IPC，IPC有两种基本模型：<strong>共享内存</strong>和<strong>消息传递</strong></p>\n<p>目前，在多核系统上，共享内存机制由于高速缓存的不一致性，性能要差于消息传递。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存区域驻留在创建共享内存段的进程内。并且负责确保内存不会被同时写入。<br>共享内存有一个循环数组，用于共享进程发送信息的缓冲。</p>\n<h3 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h3><p>消息传递需要至少提供send()和receive()两个操作。这样要考虑几个问题：</p>\n<ul>\n<li>直接or间接通信</li>\n<li>同步or异步</li>\n<li>自动or显式缓冲</li>\n</ul>\n<h4 id=\"通信的直接or间接\"><a href=\"#通信的直接or间接\" class=\"headerlink\" title=\"通信的直接or间接\"></a>通信的直接or间接</h4><p>采用直接通信的send()和receive()都需要直接指定接收方的地址，可能是对称或非对称的（非对称即接收方只能接受向其发送的进程信息）</p>\n<p>间接通信的方法则通过邮箱或端口来发送信息。通过把邮箱抽象为一个对象，这种方式有如下特点：</p>\n<ul>\n<li>共享邮箱才能建立链路</li>\n<li>一个链路与多个进程关联</li>\n<li>两个进程之间可以有多个链路<br>但是一个消息只能被一个进程接收<br>邮箱可以为系统或进程拥有，进程拥有的邮箱必须要确定所有者和使用者。所有者只能接受信息，使用者只能发送信息。<br>进程被终止后，邮箱将消失。操作系统的邮箱是独立存在的。操作系统提供机制允许进程进行创建、删除、使用邮箱。而且通过系统调用，邮箱的所有权可以传给其他进程。</li>\n</ul>\n<h4 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h4><p>关于消息传递的同步性，有以下四种可能：</p>\n<ul>\n<li>阻塞发送：发送消息后，直到被接收，进程都将阻塞</li>\n<li>非阻塞发送：发送后继续操作</li>\n<li>阻塞接收：阻塞进程，直到能接收信息</li>\n<li>非阻塞接收：接收进程收到有效信息或空信息</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>缓存有三种形式：</p>\n<ul>\n<li>零容量：要求发送者应当阻塞发送，因为消息队列不能等待。</li>\n<li>有限容量：最多n条消息可以等待，超过这个数量时进程将阻塞</li>\n<li>无限容量：进程不会阻塞发送</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"posix\"><a href=\"#posix\" class=\"headerlink\" title=\"posix\"></a>posix</h4><p>posix通过内存映射文件共享内存，通过系统调用shm_open(name,O_CREAT|O_RDRW,0666)函数来创建共享内存对象。<br>创建成功后，函数ftruncate(shm_fd,4096)用于配置对象的大小（4096字节）<br>最后，mmap()函数用于将内存映射文件包含共享内存。返回ptr<br>使用sprintf()将message写入ptr。<br>最终消费者使用了共享内存后，调用shm_unlink()移除共享内存</p>\n<h4 id=\"Mach\"><a href=\"#Mach\" class=\"headerlink\" title=\"Mach\"></a>Mach</h4><p>Mach通过消息传递（采用邮箱）实现<br>包括两个邮箱：内核邮箱和通知邮箱。调用msg_send()来发送消息，msg_receive()接收消息，msg_rpc()用来进行远程过程调用。<br>系统调用port_allocate()来创建新邮箱。可以指定最大排队信息，而且消息复制到邮箱中可以保证单个发送者的顺序统一。<br>发送消息如果遇到邮箱满了，可能会等待（无限或n毫秒），或者立刻返回，或者在操作系统中为一个线程存储一个消息。<br>邮箱可以形成一个邮箱集合来服务单个任务。port_status()用于返回指定邮箱的消息数量。<br>Mach本来是为了分布式系统设计，但是为了多核系统，Mach也可以使用虚拟内存，把发送者地址空间映射到接收者地址空间，来提高性能。</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>windows支持多个操作环境或子系统，应用程序通过消息传递来通信。Windows使用ALPC工具来进行进程间通信。<br>类似于TCP连接，Windows内部也使用了<strong>连接端口</strong>和<strong>通信端口</strong>区分的思想。此外，通信回调机制允许服务器和客户端在等待时也能响应接受请求。<br>这个机制包含三种技术：</p>\n<ul>\n<li>对于小消息，采用消息队列进行存储，复制传递</li>\n<li>对于大消息（256字节+）：采用区段对象传递，为共享内存。</li>\n<li>对于巨大消息，采用API直接读写目标地址空间。</li>\n</ul>\n<p>注意：ALPC不属于WinAPI</p>\n<h3 id=\"服务器和客户端通信\"><a href=\"#服务器和客户端通信\" class=\"headerlink\" title=\"服务器和客户端通信\"></a>服务器和客户端通信</h3><h4 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字\"></a>套接字</h4><p>详见计算机网络</p>\n<h4 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h4><p>RPC：远程过程调用</p>\n<p>RPC和套接字不同，具有明确的数据结构。和本地调用过程相似，RPC隐藏了远程调用的通信细节。<br>对于每个远程过程，客户端都有一个存根用来调用服务器端口，并传递参数。返回值也可以传递回客户端。<br>通过时间戳，系统可以避免RPC被重复执行。而且还需要和客户确认RPC调用已经收到且执行。这要求客户机实现RPC调用的发送后接收到ACK信息。<br>使用交会服务程序，可以让客户请求RPC的端口灵活分配。<br>RPC可用于实现分布式文件系统</p>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><p>管道是一个半双工的结构<br>分为<strong>普通管道</strong>和<strong>命名管道</strong><br>UNIX上，管道采用pipe(int fd[])函数来创建，fd[0]为读出端，fd[1]为写入端<br>父子进程通信可以使用管道来进行，因为子进程继承了夫进程的管道，他们共享一个管道但是有两个fd。但是普通管道需要在同一机器上有父子关系的进程。</p>\n<p>命名管道：提供了一个双向的，不必须父子关系的，多进程通信的管道。<br>而且通信结束后，管道依旧存在。</p>\n<ul>\n<li><p>对于UNIX，管道通过mkfifo()系统调用来进行。通过调用对文件的读写函数来进行常规读写。只有显式删除才会关闭管道。这是半双工且单机通信的，除非用套接字来进行远程通信。</p>\n</li>\n<li><p>对于Windows，CreateNamedPipe()支持创建全双工且支持远程的通信。</p>\n</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2024/03/15/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "url": "http://example.com/2024/03/15/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "title": "Linux学习笔记2",
            "date_published": "2024-03-15T02:05:10.000Z",
            "content_html": "<h2 id=\"账号文件\"><a href=\"#账号文件\" class=\"headerlink\" title=\"账号文件\"></a>账号文件</h2><h3 id=\"x2F-etc-x2F-passwd\"><a href=\"#x2F-etc-x2F-passwd\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;passwd\"></a>&#x2F;etc&#x2F;passwd</h3><p>存储了</p>\n<ul>\n<li>账号信息</li>\n<li>x（密码）</li>\n<li>UID</li>\n<li>GID</li>\n<li>用户信息栏</li>\n<li>家目录</li>\n<li>shell</li>\n</ul>\n<h3 id=\"x2F-etc-x2F-shadow\"><a href=\"#x2F-etc-x2F-shadow\" class=\"headerlink\" title=\"&#x2F;etc&#x2F;shadow\"></a>&#x2F;etc&#x2F;shadow</h3><ul>\n<li>账号名</li>\n<li>密码</li>\n<li>最近修改</li>\n<li>不可修改天数</li>\n<li>建议修改天数</li>\n<li>警告天数</li>\n<li>过期密码宽限</li>\n<li>失效日期</li>\n</ul>\n<h2 id=\"忘记密码\"><a href=\"#忘记密码\" class=\"headerlink\" title=\"忘记密码\"></a>忘记密码</h2><p>普通用户：passwd<br>root：单人启动模式</p>\n<h2 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h2><p>&#x2F;etc&#x2F;group</p>\n<ul>\n<li>组名</li>\n<li>用户组密码</li>\n<li>GID</li>\n<li>支持的账号名称 逗号分开</li>\n</ul>\n<p>group：查看用户所属的组，第一个是有效用户组，即为创建文件时代表的组<br>newgrp：切换有效用户组，以另外一个单独的shell生效。</p>\n<p>加入用户组：root用usermod，组管理员用gpasswd</p>\n<h2 id=\"账号管理\"><a href=\"#账号管理\" class=\"headerlink\" title=\"账号管理\"></a>账号管理</h2><p>useradd：新建账户</p>\n<ul>\n<li>-g初始用户组</li>\n<li>-G次要用户组</li>\n<li>-e失效日期</li>\n<li>-f密码失效</li>\n<li>-s默认shell</li>\n</ul>\n<p>userdel：删除账户<br>usermod：修改存在的账户</p>\n<p>id：查询用户信息<br>finger：查询用户动态<br>chfn：改变自身动态</p>\n<h2 id=\"用户组管理\"><a href=\"#用户组管理\" class=\"headerlink\" title=\"用户组管理\"></a>用户组管理</h2><p>groupadd：新增组<br>groupmod：修改组<br>groupdel：删除组</p>\n<h2 id=\"ACL\"><a href=\"#ACL\" class=\"headerlink\" title=\"ACL\"></a>ACL</h2><p>ACL为访问控制列表，针对单一用户、单一目录来进行rwx的权限设置。</p>\n<p>setfacl：设置ACL参数</p>\n<ul>\n<li>-m为设置参数</li>\n<li>-x为删除参数</li>\n<li>-R递归设置</li>\n</ul>\n<p>使用方式：</p>\n<ul>\n<li>针对特定使用者：setfacl -m u:账号列表：rwx</li>\n<li>针对特定组：setfacl -m g:用户组列表：rwx</li>\n<li>针对有效权限：setfacl -m m:[rwx]<br>getfacl：查询文件权限<br>getfacl filename</li>\n</ul>\n<h2 id=\"用户身份切换\"><a href=\"#用户身份切换\" class=\"headerlink\" title=\"用户身份切换\"></a>用户身份切换</h2><p>su：切换shell执行不同身份</p>\n<ul>\n<li>-：直接变为root，作为login_shell</li>\n<li>-l：指定账号</li>\n<li>如无-，则表示用非login shell登录</li>\n</ul>\n<p>区别在于：非login shell时，你的环境变量还是使用的原来的用户，而loginshell会使用root的名称。</p>\n<p>sudo：以root权限来执行命令</p>\n<ul>\n<li>-b：后台执行</li>\n<li>-u：指定希望切换的使用者</li>\n</ul>\n<p>能否执行取决于是否在&#x2F;etc&#x2F;sudoers文件，可用visudo修改。<br>visudo可以通过添加用户，添加用户组，限制命令执行，别名等方式来简化流程。</p>\n<h2 id=\"特殊shell：-x2F-sbin-x2F-nologin\"><a href=\"#特殊shell：-x2F-sbin-x2F-nologin\" class=\"headerlink\" title=\"特殊shell：&#x2F;sbin&#x2F;nologin\"></a>特殊shell：&#x2F;sbin&#x2F;nologin</h2><p>系统账号可以登录，但是不能用shell访问系统资源</p>\n",
            "tags": [
                "技术",
                "博客",
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2024/03/03/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "url": "http://example.com/2024/03/03/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "title": "Linux学习笔记1",
            "date_published": "2024-03-03T08:29:11.000Z",
            "content_html": "<h1 id=\"Linux学习笔记1\"><a href=\"#Linux学习笔记1\" class=\"headerlink\" title=\"Linux学习笔记1\"></a>Linux学习笔记1</h1><h2 id=\"启动运行级\"><a href=\"#启动运行级\" class=\"headerlink\" title=\"启动运行级\"></a>启动运行级</h2><p>Linux的&#x2F;etc&#x2F;rcX.d目录下存储着各个启动级的运行程序<br>运行级<strong>1</strong>时进入单用户模式，仅仅进行文件系统维护。标准运行级为<strong>3</strong>。运行级为<strong>5</strong>时会启动X Window服务。切换启动级别可以使用runlevel命令来设置</p>\n<h2 id=\"内核模块\"><a href=\"#内核模块\" class=\"headerlink\" title=\"内核模块\"></a>内核模块</h2><p>Linux内有两种方法插入设备驱动：</p>\n<ul>\n<li>编译进内核</li>\n<li>可插入的设备驱动</li>\n</ul>\n<p>linux内部有三种设备文件：</p>\n<ul>\n<li>字符设备文件：包括终端等</li>\n<li>块设备文件：包括硬盘</li>\n<li>网络设备文件：包括网卡和回环设备<br>每个设备都有一个节点文件，用于唯一标识设备（主设备号，次设备号）</li>\n</ul>\n<h2 id=\"设置终端\"><a href=\"#设置终端\" class=\"headerlink\" title=\"设置终端\"></a>设置终端</h2><p>可以使用setterm命令执行诸如：</p>\n<ul>\n<li>settterm -inversescreen on</li>\n<li>setterm -background white</li>\n<li>setterm -foreground black</li>\n</ul>\n<h2 id=\"GNU-nm\"><a href=\"#GNU-nm\" class=\"headerlink\" title=\"GNU nm\"></a>GNU nm</h2><p>这个命令可以分析obj文件并输出符号列表</p>\n<h2 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h2><p>man可以指定手册的部分，分为1-9内容</p>\n<ul>\n<li>1：命令名</li>\n<li>2：系统调用</li>\n<li>3：库调用</li>\n<li>4：特殊文件</li>\n<li>5：文件格式与约定</li>\n<li>6：游戏</li>\n<li>7：概览，约定</li>\n<li>8：root命令</li>\n<li>9：内核例程</li>\n</ul>\n<h2 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h2><p>如下参数：</p>\n<ul>\n<li>-F：标注文件类型</li>\n<li>-R：递归寻找</li>\n<li>加入字符串：模糊匹配</li>\n<li>–time&#x3D;atime：显示访问时间</li>\n<li>-d：不递归显示</li>\n</ul>\n<h2 id=\"copy\"><a href=\"#copy\" class=\"headerlink\" title=\"copy\"></a>copy</h2><p>cp source dest<br>如下参数：</p>\n<ul>\n<li>-i：询问是否覆盖</li>\n<li>-R：复制目录</li>\n</ul>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>ln srcfile linkfile</p>\n<p>参数；</p>\n<ul>\n<li>-s：符号链接</li>\n<li>无参数：硬链接</li>\n</ul>\n<h2 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h2><p>mv src dest</p>\n<p>移动文件是不会改变inode的。</p>\n<h2 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h2><p>mkdir ：-p可以创建缺失父目录</p>\n",
            "tags": [
                "技术",
                "博客",
                "Linux"
            ]
        },
        {
            "id": "http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/",
            "url": "http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/",
            "title": "电赛培训-23-07-05",
            "date_published": "2023-07-05T01:46:48.000Z",
            "content_html": "<h1 id=\"Arduino\"><a href=\"#Arduino\" class=\"headerlink\" title=\"Arduino\"></a>Arduino</h1><p>软件：使用Arduino IDE，以C++风格语言编写相关库。<br>利用IDE编译固件下载到Arduino的前提条件是有bootloader程序。<br>所以从程序到固件的关键在于bootloader，其他单片机也可以装载bootloader固件，然后使用arduino库。</p>\n<h2 id=\"硬件-uno板\"><a href=\"#硬件-uno板\" class=\"headerlink\" title=\"硬件 uno板\"></a>硬件 uno板</h2><p>工作电压5v,可以typeB，DC5.5，或者跳线接入<br>共有14个数字输入输出（6个PWM口），6个模拟输入输出</p>\n<h2 id=\"系统指示灯\"><a href=\"#系统指示灯\" class=\"headerlink\" title=\"系统指示灯\"></a>系统指示灯</h2><ul>\n<li>ON：系统指示灯</li>\n<li>RX：接收指示灯</li>\n<li>TX：发送指示灯</li>\n<li>L：内置LED，对应13号数字口<h2 id=\"开始编写代码\"><a href=\"#开始编写代码\" class=\"headerlink\" title=\"开始编写代码\"></a>开始编写代码</h2>有两个一定会有的函数，void setup()和void loop()，分别是初始化和循环函数。<br>setup会执行一次，loop在setup后会自动循环<h3 id=\"setup函数\"><a href=\"#setup函数\" class=\"headerlink\" title=\"setup函数\"></a>setup函数</h3>setup中用pinMode配置管脚模式为输出<br>pinMode(pin编号，INPUT)：高阻态，可认为是100m欧姆，电平不定。<br>pinMode(pinnum,INPUT_PULLUP):内置上拉输入，无外部信号默认高电平。<br>pinMode(pinnum,OUTPUT):输出模式，uno上高电平5v，电流&lt;40mA</li>\n</ul>\n<h3 id=\"loop函数\"><a href=\"#loop函数\" class=\"headerlink\" title=\"loop函数\"></a>loop函数</h3><ul>\n<li>digitalWrite(pinnum,HIGH&#x2F;LOW):输出高低电平，只对output模式有效</li>\n<li>digitalRead(pinnum):读取高低电平,返回HIGH&#x2F;LOW两种电平</li>\n<li>analogRead(anaPinNum)：读取模拟输入电平，返回0-1023的数字，对应0-5v的电压</li>\n<li>analogWrite(pwmPinNum,0-255)：输出PWM波，对应0-5v的电压，频率为490Hz(3,9,10,11pin),或980Hz(5,6pin)</li>\n<li>analogReference(AD参考电压输入来源)：切换AD参考电压输入来源，有默认值，一般不用，可以让输出更加精细。</li>\n</ul>\n<h3 id=\"中断和轮询\"><a href=\"#中断和轮询\" class=\"headerlink\" title=\"中断和轮询\"></a>中断和轮询</h3><p>轮询：不断重复读取某个状态值，缺点是占用资源<br>中断：可以通过某个状态改变来发送信号，然后发送信号后可以执行其他操作，之后再恢复到发送信号之前的状态。<br>管脚中断：attachInterrupt(digitalPinToInterrupt(pinnum),ISR,mode),第一个参数是中断管脚号（uno为2，3），第二个参数是中断服务函数（可以自定义），第三个参数是中断模式，有LOW，RISING，FALLING，CHANGE四种模式。</p>\n<ul>\n<li>LOW：低电平触发</li>\n<li>RISING：上升沿触发</li>\n<li>FALLING：下降沿触发</li>\n<li>CHANGE：任意电平变化触发</li>\n</ul>\n<p><strong>注意，终端服务函数应当很短，而且不能使用其他中断实现的函数，延时需要delayMicroseconds(us)</strong><br><strong>修改全局变量应当用volatile修饰，防止编译器优化</strong></p>\n<h1 id=\"ESP32\"><a href=\"#ESP32\" class=\"headerlink\" title=\"ESP32\"></a>ESP32</h1><h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>esp32-WROOM-32<br>串口芯片：CP2102<br>核心频率240mHz<br>WiFi IEEE 802.11 b&#x2F;g&#x2F;n 2.4GHz<br>BLuetooth 4.2 BR&#x2F;EDR and BLE<br>520k SRAM 448kB ROM<br>2个I2S，RMT远程控制，LED PWM，1个host SD&#x2F;eMMC&#x2F;SDIO，一个slave SDIO&#x2F;SPI. TWAI(CAN),12bitADC,Ethernet</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>MicroPython+Thonny</p>\n<h3 id=\"常用库\"><a href=\"#常用库\" class=\"headerlink\" title=\"常用库\"></a>常用库</h3><h3 id=\"GPIO\"><a href=\"#GPIO\" class=\"headerlink\" title=\"GPIO\"></a>GPIO</h3><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">from</span> machine <span class=\"hljs-keyword\">import</span> Pin<br><br>p0 = Pin(<span class=\"hljs-number\">0</span>,Pin.<span class=\"hljs-keyword\">OUT</span>) # <span class=\"hljs-keyword\">create</span> output pin <span class=\"hljs-keyword\">on</span> GPIO0<br>p0.<span class=\"hljs-keyword\">on</span>() # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> &quot;on&quot; (high) <span class=\"hljs-keyword\">level</span><br>p0.<span class=\"hljs-keyword\">off</span>() # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> &quot;off&quot; (low) <span class=\"hljs-keyword\">level</span><br>p0.<span class=\"hljs-keyword\">value</span>(<span class=\"hljs-number\">1</span>) # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">on</span>/high<br>p0.init(p0.<span class=\"hljs-keyword\">IN</span>,p0.PULL_DOWN) # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">with</span> a pull-down resistor<br></code></pre></td></tr></table></figure>\n<p>init函数中，id是强制的</p>\n<ul>\n<li><p>mode指定引脚模式，有IN，OUT，OPEN_DRAIN，AF_OPEN_DRAIN四种模式</p>\n</li>\n<li><p>pull指定引脚是否连接弱上拉电阻，有None，PULL_UP，PULL_DOWN三种模式<br>弱上拉指上拉电阻阻值较大，高电平很容易因为外部电流驱动而拉低。</p>\n</li>\n<li><p>drive具有不同的最大安全电流的限制，有DRIVE_0-3四种选择</p>\n</li>\n<li><p>alt为引脚的备用功能，仅对alt和alt_open_drain两种模式有效，有0-7八种选择</p>\n</li>\n</ul>\n<p>value函数中，如果不带参数，就是得到当前状态，如果在输出模式，需要带参数，变为设置电平</p>\n<p>配置在引脚的触发源处于活动状态时要调用中断处理程序，如果引脚模式为Pin.IN，可以使用irq函数，如果引脚模式为Pin.IN，可以使用Pin.IRQ_RISING，Pin.IRQ_FALLING，Pin.IRQ_ANY三种模式，分别对应上升沿，下降沿，任意电平变化触发中断。</p>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/29/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3WSL-Ubuntu%E6%89%BE%E4%B8%8D%E5%88%B0sys-time-h%E7%9A%84%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2023/05/29/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3WSL-Ubuntu%E6%89%BE%E4%B8%8D%E5%88%B0sys-time-h%E7%9A%84%E9%97%AE%E9%A2%98/",
            "title": "关于解决WSL_Ubuntu找不到sys/time.h的问题",
            "date_published": "2023-05-29T07:24:24.000Z",
            "content_html": "<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>在使用WSL_Ubuntu的时候，编译C代码时，出现了找不到sys&#x2F;time.h的问题</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><h2 id=\"第一次失败\"><a href=\"#第一次失败\" class=\"headerlink\" title=\"第一次失败\"></a>第一次失败</h2><p>网上的一个直接解决方案是安装libc6-dev-amd64<br>但是问题又一次出现，当输入指令<br><code>sudo apt-get install libc6-dev-amd64</code><br>发生报错 unable to locate package</p>\n<h2 id=\"第二次失败\"><a href=\"#第二次失败\" class=\"headerlink\" title=\"第二次失败\"></a>第二次失败</h2><p>于是转而解决无法定位包的问题，根据查找发现需要在&#x2F;etc&#x2F;apt&#x2F;sources.list中添加源,添加了清华源、阿里源后输入<br><code>sudo apt-get update</code><br>更新完成后再次尝试安装libc6-dev-amd64，但是问题依旧存在</p>\n<h2 id=\"第三次解决\"><a href=\"#第三次解决\" class=\"headerlink\" title=\"第三次解决\"></a>第三次解决</h2><p>这次发现libc6-dev-amd64是一个需要在i386架构下安装的包，于是尝试添加i386架构，运行指令<br><code>dpkg --add-architecture i386</code><br>添加成功后再次输入<br><code>sudo apt-get update</code><br>更新完成后再次尝试安装libc6-dev-amd64，问题解决</p>\n",
            "tags": [
                "技术",
                "博客",
                "Linux",
                "WSL",
                "编译"
            ]
        },
        {
            "id": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",
            "url": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",
            "title": "电赛学习笔记-机器视觉",
            "date_published": "2023-05-14T09:04:31.000Z",
            "content_html": "<h1 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h1><h2 id=\"安装opencv\"><a href=\"#安装opencv\" class=\"headerlink\" title=\"安装opencv\"></a>安装opencv</h2><h2 id=\"开发板：STM32F407\"><a href=\"#开发板：STM32F407\" class=\"headerlink\" title=\"开发板：STM32F407\"></a>开发板：STM32F407</h2><h2 id=\"IDE：STM32CubeIDE\"><a href=\"#IDE：STM32CubeIDE\" class=\"headerlink\" title=\"IDE：STM32CubeIDE\"></a>IDE：STM32CubeIDE</h2><h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><p>配置工程ioc文件，配置好基础外设后，再packs中安装X-CUBE-AI组件包，在软件包外设中添加模型文件，设置压缩倍数，导入测试集验证准确率</p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><h3 id=\"yolo\"><a href=\"#yolo\" class=\"headerlink\" title=\"yolo\"></a>yolo</h3><p>利用mobilenet yolo50k模型可以导入到单片机中，只需要较少内存即可实现实时运行，实现人脸识别的功能</p>\n<h3 id=\"openmv\"><a href=\"#openmv\" class=\"headerlink\" title=\"openmv\"></a>openmv</h3><h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>正点原子ov7725摄像头<br>yolo50k</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p><a href=\"https://www.bilibili.com/video/BV1Bt411w77m/?share_source=copy_web&vd_source=4ed5c2c0429d7681216f506ac1e74065\">稚晖君</a><br><a href=\"https://github.com/dog-qiuqiu/MobileNet-Yolo\">yolo50k仓库</a><br><a href=\"https://www.bilibili.com/video/BV1FL411u72p/?share_source=copy_web&vd_source=4ed5c2c0429d7681216f506ac1e74065\">实时运行案例</a></p>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/",
            "url": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/",
            "title": "电赛学习笔记-micropython",
            "date_published": "2023-05-14T08:47:54.000Z",
            "content_html": "<h1 id=\"micropython简介\"><a href=\"#micropython简介\" class=\"headerlink\" title=\"micropython简介\"></a>micropython简介</h1><p>micropython是一个能够利用python进行单片机开发的固件，目前主要是在esp32平台上进行的开发</p>\n<h1 id=\"micropython安装\"><a href=\"#micropython安装\" class=\"headerlink\" title=\"micropython安装\"></a>micropython安装</h1><ul>\n<li>在micropython官网找到对应的单片机的型号的固件文件（.bin），下载到对应位置</li>\n<li>pip install esptool</li>\n<li>连接esp32单片机，查看端口号</li>\n<li>根据micropython官网的指示，利用esptool.py文件，清除单片机flash，再部署固件到单片机。</li>\n<li>安装uPyCraft IDE，选择好开发板类型和端口号后，<h1 id=\"micropython使用\"><a href=\"#micropython使用\" class=\"headerlink\" title=\"micropython使用\"></a>micropython使用</h1>需要根据单片机自带的库函数，进行python文档的开发<h1 id=\"micropython的优点\"><a href=\"#micropython的优点\" class=\"headerlink\" title=\"micropython的优点\"></a>micropython的优点</h1>代码量少，配置简单</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/",
            "url": "http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/",
            "title": "电赛学习笔记（1）——stm32学习笔记",
            "date_published": "2023-05-11T08:19:20.000Z",
            "content_html": "<h1 id=\"stm32基础\"><a href=\"#stm32基础\" class=\"headerlink\" title=\"stm32基础\"></a>stm32基础</h1><h2 id=\"关于stm32产品线\"><a href=\"#关于stm32产品线\" class=\"headerlink\" title=\"关于stm32产品线\"></a>关于stm32产品线</h2><h3 id=\"stm32f1系列-cortex-m3\"><a href=\"#stm32f1系列-cortex-m3\" class=\"headerlink\" title=\"stm32f1系列 cortex-m3\"></a>stm32f1系列 cortex-m3</h3><h3 id=\"stm32f4系列-cortex-m4\"><a href=\"#stm32f4系列-cortex-m4\" class=\"headerlink\" title=\"stm32f4系列 cortex-m4\"></a>stm32f4系列 cortex-m4</h3><ul>\n<li>内置了rgb lcd驱动</li>\n<li>加入了DSP与FPU模块<h3 id=\"stm32f7系列-cortex-m7\"><a href=\"#stm32f7系列-cortex-m7\" class=\"headerlink\" title=\"stm32f7系列 cortex-m7\"></a>stm32f7系列 cortex-m7</h3></li>\n<li>高速内存得到应用 <h2 id=\"寄存器编程\"><a href=\"#寄存器编程\" class=\"headerlink\" title=\"寄存器编程\"></a>寄存器编程</h2></li>\n</ul>\n<p><strong>关键字volatile</strong>需要在声明寄存器变量的时候添加，因为要防止编译器自行优化。</p>\n<h2 id=\"HAL库\"><a href=\"#HAL库\" class=\"headerlink\" title=\"HAL库\"></a>HAL库</h2><p>硬件抽象层，可以将不同产品线的芯片的寄存器操作抽象为函数，方便移植<br><strong><font color=\"red\">本笔记使用HAL库进行编程</font></strong><br>相对的，HAL库会产生大量的判断来降低代码运行效率<br>但是，还有另一个Low Layer库（LL），这个库可以提高效率</p>\n<h2 id=\"stm32cubeMX配置\"><a href=\"#stm32cubeMX配置\" class=\"headerlink\" title=\"stm32cubeMX配置\"></a>stm32cubeMX配置</h2><h2 id=\"stm32计时器\"><a href=\"#stm32计时器\" class=\"headerlink\" title=\"stm32计时器\"></a>stm32计时器</h2><h3 id=\"PWM调制输出\"><a href=\"#PWM调制输出\" class=\"headerlink\" title=\"PWM调制输出\"></a>PWM调制输出</h3><h4 id=\"几个重要参数\"><a href=\"#几个重要参数\" class=\"headerlink\" title=\"几个重要参数\"></a>几个重要参数</h4><ul>\n<li>占空比：高电平占整个周期的比例</li>\n<li>频率：整个PWM周期的倒数</li>\n<li>分辨率：占空比变化步长 <h4 id=\"PWM实现方法\"><a href=\"#PWM实现方法\" class=\"headerlink\" title=\"PWM实现方法\"></a>PWM实现方法</h4>输出比较模式，依靠内部计数器cnt和ccr设置的数值的比较来进行输出电平的控制，常用的有匹配时电平翻转和PWM模式<br>PWM占空比：$$DutyCycle&#x3D;\\frac{CCR}{ARR}$$<br>PWM频率：$$Freq&#x3D;\\frac{F_{clk}}{ARR}$$<br>PWM分辨率：$$Resolution&#x3D;\\frac{ARR}{2^{n}}$$<h4 id=\"高级定时器\"><a href=\"#高级定时器\" class=\"headerlink\" title=\"高级定时器\"></a>高级定时器</h4>死区生成：可以避免推挽电路上下管同时打开导致短路<h3 id=\"PWM控制电机\"><a href=\"#PWM控制电机\" class=\"headerlink\" title=\"PWM控制电机\"></a>PWM控制电机</h3>舵机是根据pwm信号控制舵机转动角度的，内部有直流电机<h4 id=\"电机驱动芯片\"><a href=\"#电机驱动芯片\" class=\"headerlink\" title=\"电机驱动芯片\"></a>电机驱动芯片</h4>利用H桥，可以控制电机转动方向。四个开关管可以构成两个推挽电路，使得电机可以获得两个方向的电流。<br>电机需要的电源一般是大功率的，不能直接通过gpio驱动，因此可以通过让stlink的5v口接入电机驱动芯片来获得电源。但是注意，pwm信号的地应当和电机电源的地相连，否则会出现电平不稳定的情况。<h3 id=\"PWM代码\"><a href=\"#PWM代码\" class=\"headerlink\" title=\"PWM代码\"></a>PWM代码</h3>pwm的激活结构如下：<br><img src=\"/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/PWM_Structure.jpg\" alt=\"PWM_Structure\"></li>\n<li>RCC开启时钟</li>\n<li>配置时基单元</li>\n<li>配置输出比较单元</li>\n<li>配置GPIO，设置为复用推挽输出</li>\n<li>运行控制，启动计数器<h4 id=\"TIM库函数\"><a href=\"#TIM库函数\" class=\"headerlink\" title=\"TIM库函数\"></a>TIM库函数</h4>在hal库中，tim相关库函数在stm32f1xx_hal_tim.h文件中<br>其中有关输出比较的内容有：</li>\n<li>TIM_OC_InitTypeDef: 输出比较初始化结构体</li>\n<li>HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)：输出比较初始化函数</li>\n<li>HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel)：配置输出通道函数</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/",
            "url": "http://example.com/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/",
            "title": "记录：装修博客",
            "date_published": "2022-04-21T09:32:11.000Z",
            "content_html": "<p><font color=\"Red\" size=\"6\"><strong>本文长期更新，后面更新的部分也会插在不同部分</strong></font></p>\n<h1 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h1><ul>\n<li><a href=\".#%E5%8A%9F%E8%83%BD%E8%AE%BE%E7%BD%AE\">功能设置</a><ul>\n<li><a href=\".#%E4%B8%BB%E9%A2%98%E9%80%89%E5%8F%96\">主题选取</a><ul>\n<li><a href=\".#%E5%BD%92%E6%A1%A3%E4%B8%8E%E6%A0%87%E7%AD%BE\">归档与标签</a></li>\n<li><a href=\".#%E4%B8%8B%E4%B8%80%E6%AD%A5%EF%BC%8C%E5%8F%8B%E9%93%BE%E4%B8%8E%E4%BD%9C%E8%80%85%E9%93%BE%E6%8E%A5\">友链与作者链接</a></li>\n<li><a href=\".#%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C\">一些其他的骚操作</a></li>\n</ul>\n</li>\n<li><a href=\".#%E6%87%92%E5%8A%A0%E8%BD%BD\">懒加载</a></li>\n</ul>\n</li>\n<li><a href=\".#%E7%BE%8E%E8%A7%82%E8%AE%BE%E7%BD%AE\">美观设置</a><ul>\n<li><a href=\".#%E8%83%8C%E6%99%AF%E5%9B%BE\">背景图</a><ul>\n<li><a href=\".#%E4%B8%BB%E9%A1%B5%E8%83%8C%E6%99%AF%E5%9B%BE\">主页背景图</a></li>\n<li><a href=\".#%E6%96%87%E7%AB%A0%E8%83%8C%E6%99%AF%E5%9B%BE\">文章背景图</a></li>\n</ul>\n</li>\n<li><a href=\".#%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2%E5%9B%BE\">文章封面图</a></li>\n<li><a href=\".#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB\">图片加载动画</a></li>\n</ul>\n</li>\n<li><a href=\".#%E6%89%A9%E5%B1%95%E8%AE%BE%E7%BD%AE\">扩展设置</a></li>\n</ul>\n<h1 id=\"功能设置\"><a href=\"#功能设置\" class=\"headerlink\" title=\"功能设置\"></a>功能设置</h1><h2 id=\"主题选取\"><a href=\"#主题选取\" class=\"headerlink\" title=\"主题选取\"></a>主题选取</h2><p>一个博客的功能上限，很大程度上是取决于这个主题给你提供的功能，因此一个好的主题很重要<br>主题的选取，可以看我的另一篇文章<a href=\"https://lianga1.github.io/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/\">Hexo主题模板切换</a><br>但是大部分时候我们用的功能不会很多，而基础的功能，例如归档，友链，个人介绍等功能，绝大部分的主题都具备。所以仅需要挑选好看的主题即可，关于主题的美观问题，我们放在<a href=\".#%E7%BE%8E%E8%A7%82%E8%AE%BE%E7%BD%AE\">美观设置</a>模块说。<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/theme1.jpg\" alt=\"theme\"></p>\n<h2 id=\"导航栏\"><a href=\"#导航栏\" class=\"headerlink\" title=\"导航栏\"></a>导航栏</h2><p>导航栏是一个博客的门面。设置好导航栏，你的博客会非常的有条理。</p>\n<h3 id=\"归档与标签\"><a href=\"#归档与标签\" class=\"headerlink\" title=\"归档与标签\"></a>归档与标签</h3><p>如果读者想找一篇文章,总不能让读者去挨篇文章翻吧，所以，在写文章的时候，做好标签设置和归档工作，是写一篇文章的必要工作。那么，如何归档呢？<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/categories.jpg\" alt=\"categories\"><br>在md语法中，我们可以在文章顶部的标签部分，加入如下几行</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs subunit\"><span class=\"hljs-keyword\">tags:</span><br>- 标签1<br>- 标签2<br>……<br>- 标签n<br>categories: <br>- 一级目录<br>- 二级目录<br></code></pre></td></tr></table></figure>\n<p><font size=\"4\"><strong>注意</strong></font>：tags和categories必须无缩进，否则在生成html时会报错</p>\n<p>这样，你就拥有了一个可以从标签和分级目录中查询的文章了</p>\n<h3 id=\"下一步，友链与作者链接\"><a href=\"#下一步，友链与作者链接\" class=\"headerlink\" title=\"下一步，友链与作者链接\"></a>下一步，友链与作者链接</h3><p><font color=\"Red\" size=\"6\"><strong>注意</strong></font>，本文之后的内容以Fluid主题为准，其他主题大同小异，具体操作可以参照主题的介绍文档。</p>\n<hr>\n<p>为什么把友链放到前面说呢，<del>当然是因为我最开始没管作者链接</del>，是因为友链的设置更加简单<br>我们需要在主题的_config.yml中（以下如果没有特殊说明，都是themes下的配置文件），在navbar：menu里，加入links，如下<br><code> - &#123; key: &quot;links&quot;, link: &quot;/links/&quot;, icon: &quot;iconfont icon-link-fill&quot; &#125;</code><br>这样就可以<br>然后找到links部分<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/links.jpg\" alt=\"links\"><br>将enable改为true即可，这样，我们的主页导航栏就会出现“友链”了。<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/links2.jpg\" alt=\"links2\"></p>\n<p><font size=\"4\">如何添加友链呢</font></p>\n<p>只需要在config文件中的links模块下的item中，按照如下格式添加即可</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dts\">- &#123;<br><span class=\"hljs-symbol\">      title:</span> <span class=\"hljs-string\">&quot;rittmeister&quot;</span>,<br><span class=\"hljs-symbol\">      intro:</span> <span class=\"hljs-string\">&quot;xxx的博客&quot;</span>,<br><span class=\"hljs-symbol\">      link:</span> <span class=\"hljs-string\">&quot;https://lianga1.github.io/&quot;</span>,<br><span class=\"hljs-symbol\">      avatar:</span> <span class=\"hljs-string\">&quot;/img/avatar.png&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>其中avatar是图标，存在主题文件夹下&#x2F;source&#x2F;img文件夹中，你可以根据喜好来更改</p>\n<hr>\n<p>接下来是作者链接，作者链接略微复杂<br>首先，我们需要在config文件中，找到about：模块<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/about1.jpg\" alt=\"about\"><br>确认是enable状态<br>当然，我们现在博客中点击这个页面，会显示404<br>原因是我们需要创建一个专门的about页面，方法如下，cmd输入代码<br><code>hexo new page about</code><br>即会在source文件夹创建一个about文件夹，里面有一个index.md文件，进入<br>在标签部分，添加<br><code>layout: about</code><br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/about2.jpg\" alt=\"about\"><br>这样，我们就会发现作者链接可以进入了。然后，我们可以在config-about模块，添加自己想要的功能。<br>例如我还添加了微信二维码<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/about3.jpg\" alt=\"about3\"><br>除此之外，fluid提供了丰富的图标库，可以在其doc中查询css的使用方法，这里不展开介绍了</p>\n<h3 id=\"一些其他的骚操作\"><a href=\"#一些其他的骚操作\" class=\"headerlink\" title=\"一些其他的骚操作\"></a>一些其他的骚操作</h3><p>你还可以直接加一些新的链接，还是在navbar：menu部分里加，比如我就新加了一个tape提问箱，妈妈再也不用担心没人提问了<br><del>笑死，自闭症患儿罢了，哪有人去你的博客提问啊</del></p>\n<h2 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h2><p>这个功能还是蛮有用的，单独开出来说一下<br>这个是可以让你的网页先加载，图片慢慢加载的功能，毕竟你的github服务器，如果等所有封面图都加载出来，黄花菜都凉了<br>实现方法：<br>config文件中lazyload：模块，enable设为true即可</p>\n<h1 id=\"美观设置\"><a href=\"#美观设置\" class=\"headerlink\" title=\"美观设置\"></a>美观设置</h1><p>我个人很有自知之明，知道我的审美能力一般，这里仅提供一些方法上的指导</p>\n<h2 id=\"背景图\"><a href=\"#背景图\" class=\"headerlink\" title=\"背景图\"></a>背景图</h2><p>（施工中——2022.4.22半夜一点半）</p>\n<hr>\n<p>（4.23更新）<br>背景图是博客的门面，选一张得体的背景图，可以极大的提高博客的氛围感，甚至可以增加阅读体验，以下介绍一下插入背景图的方法</p>\n<h3 id=\"主页背景图\"><a href=\"#主页背景图\" class=\"headerlink\" title=\"主页背景图\"></a>主页背景图</h3><p>主页背景图，我推荐构图简单，色彩主调统一的图片，否则背景图上的字会显示不清。<br>修改背景图的方法很简单，在config文件中，搜索</p>\n<blockquote>\n<p>banner_img</p>\n</blockquote>\n<p>这个是所有背景图的关键词，因此你可以搜索到17个词<br>找到index模块下的banner_img<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/banner1.jpg\" alt=\"banner_img\"><br>其后面的目录是主题的source文件夹下的目录，只需要把你想要的图片放在这个目录下，并在config中替换即可</p>\n<h3 id=\"其他背景图\"><a href=\"#其他背景图\" class=\"headerlink\" title=\"其他背景图\"></a>其他背景图</h3><p>emm，其他的背景图嘛，我希望你可以找到一套图，来和主页的背景映衬而且又各具特色，但是目前我还没有找到这种理想的图包。</p>\n<h2 id=\"文章封面图\"><a href=\"#文章封面图\" class=\"headerlink\" title=\"文章封面图\"></a>文章封面图</h2><p>文章封面图的设置，是在文章的顶部内容栏中加入index_img: 一行<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/index_img1.jpg\" alt=\"index_img\"><br>然后，图片的位置是你的<font color=\"Red\" size=\"6\"><strong>主题目录下</strong></font>的source&#x2F;img文件夹，这里我建议给你的每篇文章进行归档，方便整理。<br>这样，你的博客文章就有封面图了<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/index_img2.jpg\" alt=\"index_img\"></p>\n<h2 id=\"图片加载动画\"><a href=\"#图片加载动画\" class=\"headerlink\" title=\"图片加载动画\"></a>图片加载动画</h2><p>如果我们打开了懒加载功能，那么我们就会看到图片加载时会有一个动画，这里的加载其实是一个gif，和图片一样，我们也是可以更换的，比如换成一个跑步的Mario<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/mario.gif\" alt=\"mario\"><br>下面介绍一下设置方法：<br>在config文件中找到lazyload模块，然后，找到loading_img<br>改为你在主题的source中的路径<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/loading.jpg\" alt=\"loading\"><br>以上，操作完成。</p>\n<h2 id=\"关于导航栏的一些玩法\"><a href=\"#关于导航栏的一些玩法\" class=\"headerlink\" title=\"关于导航栏的一些玩法\"></a>关于导航栏的一些玩法</h2><p>导航栏，美化是一个可以深入折腾的天地，简单介绍几个玩法</p>\n<h3 id=\"毛玻璃特效\"><a href=\"#毛玻璃特效\" class=\"headerlink\" title=\"毛玻璃特效\"></a>毛玻璃特效</h3><p>这个可以让你的导航栏显示成亚克力效果<br>只需要在config文件的navbar模块下，ground_glass设置为enable：true即可，下面还可以调节模糊的颜色，模糊程度等。<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/navbar1.jpg\" alt=\"ground_glass\"></p>\n<h3 id=\"自己的名字\"><a href=\"#自己的名字\" class=\"headerlink\" title=\"自己的名字\"></a>自己的名字</h3><p>你可以在导航栏的左侧标注你的名字，具体操作类似上条：<br><code>navbar--blog_title</code></p>\n<h3 id=\"菜单图标\"><a href=\"#菜单图标\" class=\"headerlink\" title=\"菜单图标\"></a>菜单图标</h3><p>菜单上的选项，你可以设置图标<br>方法如下：<br>在navbar–menu模块下，找到对应的菜单栏选项，在icon：位置，根据自己的需要，选择对应的css</p>\n<blockquote>\n<p><a href=\"https://hexo.fluid-dev.com/docs/icon/#%E5%86%85%E7%BD%AE%E7%A4%BE%E4%BA%A4%E5%9B%BE%E6%A0%87\">css库</a></p>\n</blockquote>\n<h2 id=\"关于标签栏的一些玩法\"><a href=\"#关于标签栏的一些玩法\" class=\"headerlink\" title=\"关于标签栏的一些玩法\"></a>关于标签栏的一些玩法</h2><h3 id=\"标签栏中显示的图标\"><a href=\"#标签栏中显示的图标\" class=\"headerlink\" title=\"标签栏中显示的图标\"></a>标签栏中显示的图标</h3><p>我们当然想让自己的名字显示在浏览器标签栏上来代替那个<del>丑陋的</del>Hexo标识，我们可以在config文件中的</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\"><span class=\"hljs-symbol\">favicon:</span><br>以及<br><span class=\"hljs-symbol\">apple_touch_icon:</span><br></code></pre></td></tr></table></figure>\n<p>这两项中，改变自己想要的图片，同样，图片的位置是&#x2F;img<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/favicon.jpg\" alt=\"favicon\"></p>\n<h3 id=\"标签栏的名字\"><a href=\"#标签栏的名字\" class=\"headerlink\" title=\"标签栏的名字\"></a>标签栏的名字</h3><p>改了图标，我们当然想要把“Hexo”改变为自己想要的名字<br><font color=\"Red\" size=\"6\"><strong>注意</strong></font>，这个是要在blog目录下的config文件更改，不要在主题配置里找！<br>在config文件中，找到site模块</p>\n<p><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/sitename.jpg\" alt=\"sitename\"><br>将其title设置为你想要的内容即可</p>\n<h3 id=\"标签栏的连接符\"><a href=\"#标签栏的连接符\" class=\"headerlink\" title=\"标签栏的连接符\"></a>标签栏的连接符</h3><p>当你打开一个文章页面或其他页面时，你会发现：标签栏名称变为<br><code>“页面名”-“站点名”</code><br>其实，中间的这个衔接符号，我们也是可以更改的，只需要在主题config文件中<br>找到“tab_title_separator:”模块<br>即可将其改为你想要的内容<br><img src=\"/2022/04/21/%E8%AE%B0%E5%BD%95%EF%BC%9A%E8%A3%85%E4%BF%AE%E5%8D%9A%E5%AE%A2/linker.jpg\" alt=\"linker\"></p>\n<hr>\n<p>（4.24施工完毕，还有一些内容，回头再说了）</p>\n",
            "tags": [
                "博客",
                "记录"
            ]
        },
        {
            "id": "http://example.com/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/",
            "title": "关于解决无法上传图片的问题",
            "date_published": "2022-04-18T15:45:02.000Z",
            "content_html": "<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>事情是这样的，我在写博客的时候发现，我的图片即使以正确的格式引用，依旧会出现无法加载的问题<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/problem.jpg\" alt=\"问题如图\"></p>\n<p>众所周知，没有图片，你写个啥都没法直观地展示，就好像pre时用txt做演示，大家嘴上不说什么，心里肯定知道<del>你是忘了做ppt了</del></p>\n<p>总之，根据我一晚上的研究成果，整理出来了几个解决图片无法显示的问题的方法供大家参考。</p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>一共有这么几个方法，大家可以都试试，挑一个自己最喜欢的</p>\n<ul>\n<li><p><a href=\"./#%E5%9B%BE%E5%BA%8A%E6%B3%95\">图床法</a></p>\n<ul>\n<li>github&amp;gitee图床</li>\n<li>图床网站</li>\n<li>PicGo</li>\n</ul>\n</li>\n<li><p><a href=\"./#%E6%9C%AC%E5%9C%B0%E4%B8%8A%E4%BC%A0%E6%B3%95\">本地上传法</a></p>\n</li>\n</ul>\n<h2 id=\"图床法\"><a href=\"#图床法\" class=\"headerlink\" title=\"图床法\"></a>图床法</h2><p>是这样的，一般来说，你的hexo博客在部署到服务器时，不会给你上传那些文章里链接的图片的，所以你的md文章里链接的图片一般情况下是无法上传的，自然就无法加载出来，但是你的图片如果是网络图片，直接链接网址，就可以通过联网加载的方式显示有如下几种方法</p>\n<h3 id=\"Github-amp-Gitee仓库图床\"><a href=\"#Github-amp-Gitee仓库图床\" class=\"headerlink\" title=\"Github&amp;Gitee仓库图床\"></a>Github&amp;Gitee仓库图床</h3><p>这个的原理就是让你的公有仓库变成图床，白嫖存储空间</p>\n<h4 id=\"操作流程\"><a href=\"#操作流程\" class=\"headerlink\" title=\"操作流程\"></a>操作流程</h4><p>具体来说，github和gitee方法相似，这里仅介绍github，gitee方法类似<br>gitee的访问速度会更快一点，github的容量没有限制，可以自己取舍</p>\n<ol>\n<li>注册一个github账户</li>\n<li>创建一个新的公有库，注意一定是<strong>公有</strong>，否则外部无法访问</li>\n<li>在库存中创建一个文件夹<br> <img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/github.jpg\" alt=\"add_a_file\"></li>\n<li>把你的图片上传<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/upload.jpg\" alt=\"upload\"></li>\n<li>点击你的图片，复制地址框中的地址，注意要把bolb改为raw<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/raw.jpg\" alt=\"raw\"></li>\n<li>然后就可以在你的博客里引用这个地址了！<blockquote>\n<p>你可以用cdn加速github，比如Jsdelivr，加速方法不在本文讨论范围</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"图床网站\"><a href=\"#图床网站\" class=\"headerlink\" title=\"图床网站\"></a>图床网站</h3><p>上面说的只是把github当作一个公开访问的图片网站，当然，市面上还有很多的专用图床网站，免费的付费的都有，这里介绍一个免费的网站<a href=\"https://imgtu.com/\">imgtu.com</a></p>\n<ol>\n<li>打开网站，上传图片<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/image.jpg\" alt=\"image\"><blockquote>\n<p>注意不能挂梯子</p>\n</blockquote>\n</li>\n<li>上传完成后，在底部链接栏，找到md链接，复制粘贴到你的文章插图位置就ok了<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/save_the_link.jpg\" alt=\"save_the_link\"></li>\n</ol>\n<p>这个方法还是比较简单的,基本上有手就行，没手的话，<del>那你也别搞博客了</del></p>\n<h3 id=\"PicGo\"><a href=\"#PicGo\" class=\"headerlink\" title=\"PicGo\"></a>PicGo</h3><p>除了以上介绍的两种方法，还有一个比较“软件化”的方案，就是<a href=\"https://molunerfinn.com/PicGo/\">PicGo</a></p>\n<p>PicGo是一个开源的软件，它的优点是方便快捷，不用登网站，操作比较easy，而且集成了很多平台。<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/PicGo.jpg\" alt=\"PicGo\"></p>\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><p>还是以GitHub为例，首先我们进入<strong>图床设置</strong>-&gt;<strong>Github</strong><br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/picgo_github.jpg\" alt=\"picgo_github\"><br>在对应的框里输入信息</p>\n<blockquote>\n<p>存储路径是你的GitHub仓库里的路径，没有时会创建<br>自定义域名就是你可以用cdn加速访问图片，最后两级就是你的用户名和仓库名<br>下面介绍一下token的获取方法</p>\n</blockquote>\n<h5 id=\"获取Github-Token\"><a href=\"#获取Github-Token\" class=\"headerlink\" title=\"获取Github Token\"></a>获取Github Token</h5><p>首先从个人列表进入settings<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token1.jpg\" alt=\"token1\"><br>然后进入最底部的developer settings<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token2.jpg\" alt=\"token2\"><br>然后进入Personal access tokens，点generate new token<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token3.jpg\" alt=\"token3\"><br>按照如下操作<br><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/token4.jpg\" alt=\"token4\"><br>生成后记得复制，这个token<font color=\"Red\" size=\"6\"><strong>只会出现一次</strong></font></p>\n<p>至此，PicGo的使用介绍就完成了</p>\n<h2 id=\"本地上传法\"><a href=\"#本地上传法\" class=\"headerlink\" title=\"本地上传法\"></a>本地上传法</h2><h2 id=\"（施工中，累了，明天再说）\"><a href=\"#（施工中，累了，明天再说）\" class=\"headerlink\" title=\"（施工中，累了，明天再说）\"></a>（施工中，累了，明天再说）</h2><p>2022.4.20更新</p>\n<p>继续说本地上传法</p>\n<p>我们之前说过，本地的图片是不会被hexo上传的，其实这个说法不严谨<br>严格来说，是你凭空放一张图片，无法上传<br>但是，我们可以通过一个方法来上传本地图片，那就是hexo-asset-image。</p>\n<h3 id=\"操作方法-1\"><a href=\"#操作方法-1\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h3><p>首先安装hexo-asset-image<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>\n<ul>\n<li>注意，如果你安装速度慢的话，可以讲npm换为淘宝镜像，切换方法如下：<br><code>npm config set registry https://registry.npm.taobao.org</code><br>安装完成后，我们要在_config.yml中作如下更改<blockquote>\n<p> 将 post_asset_folder 设置为true</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/2022/04/18/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/post.jpg\" alt=\"post\"><br>然后，每当我们新建一篇博客时，就会有一个同名文件夹在_post文件夹中生成了<br>我们把需要插入的图片放到这个文件夹里面，在文章中引用格式如下<br><code>![图片描述]（./包名/NO.01.001.jpg）</code><br><font size=\"5\">或者</font><br><code>![logo](logo.jpg)</code><br>就可以了，这个方法也是我在用的方法，非常方便，缺点是对服务器压力比较大。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>上述的几个方法，各有优缺点，可以结合自己的特点来使用<br>注意图片描述必须是全英文，否则无法显示图片<br>希望有所帮助</p>\n",
            "tags": [
                "技术",
                "博客",
                "markdown"
            ]
        },
        {
            "id": "http://example.com/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/",
            "url": "http://example.com/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/",
            "title": "Hexo主题模板切换",
            "date_published": "2022-04-18T12:56:34.000Z",
            "content_html": "<h1 id=\"下载主题\"><a href=\"#下载主题\" class=\"headerlink\" title=\"下载主题\"></a>下载主题</h1><p>首先，我们找一个比较好看的主题，比如我找的Fluid<br><img src=\"/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/fluid.jpg\" alt=\"fluid网址：https://hexo.fluid-dev.com \"></p>\n<p>找到了这个主题的<a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">github网址</a> </p>\n<p>然后呢，我们需要在cmd中输入一行神秘代码<br><code>git clone https://github.com/fluid-dev/hexo-theme-fluid themes\\fluid</code></p>\n<p>git clone 是在GitHub上下载的命令，中间的部分是这个主题的网址，最后是你在blog目录下需要把这个下载的主题存到的位置，系统会自动创建空的文件夹。</p>\n<p>然后静待下载，下载完成后，我们的工作就成功了一大半了！</p>\n<h1 id=\"应用主题\"><a href=\"#应用主题\" class=\"headerlink\" title=\"应用主题\"></a>应用主题</h1><p>应用主题的方法很简单，只需要打开blog目录下的_config.yml文件，把倒数第二个部分的“theme：”改为你的主题所在文件夹的名字就OK了。<br><img src=\"/2022/04/18/Hexo%E4%B8%BB%E9%A2%98%E6%A8%A1%E6%9D%BF%E5%88%87%E6%8D%A2/config.jpg\" alt=\"这样\"></p>\n<p>别忘了部署到服务器！</p>\n",
            "tags": [
                "技术",
                "博客",
                "markdown"
            ]
        },
        {
            "id": "http://example.com/2021/08/24/md%E8%AF%AD%E6%B3%95%E8%AF%95%E9%AA%8C/",
            "url": "http://example.com/2021/08/24/md%E8%AF%AD%E6%B3%95%E8%AF%95%E9%AA%8C/",
            "title": "md语法试验",
            "date_published": "2021-08-24T07:32:52.000Z",
            "content_html": "<h1 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h1><h2 id=\"二级目录\"><a href=\"#二级目录\" class=\"headerlink\" title=\"二级目录\"></a>二级目录</h2><h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h4 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h4><ul>\n<li>小标</li>\n<li>无序</li>\n<li>各种符号都行<ul>\n<li>第二层嵌套<ul>\n<li>第n层嵌套<h4 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h4></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>有序列表</li>\n<li>第一行序号为起始序号</li>\n<li>即使后面序号错误也会顺序下排<ol>\n<li>嵌套效果<h2 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2><h3 id=\"引用说明\"><a href=\"#引用说明\" class=\"headerlink\" title=\"引用说明\"></a>引用说明</h3><blockquote>\n<p>引用内容</p>\n<blockquote>\n<p>二级引用</p>\n<blockquote>\n<p>三级引用</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p><code>少量代码，单行使用，用·包裹</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs\"><br>大量代码多行使用，用三个·包裹<br>大量代码多行使用，用三个·包裹<br>大量代码多行使用，用三个·包裹<br>大量代码多行使用，用三个·包裹<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><h3 id=\"网页链接\"><a href=\"#网页链接\" class=\"headerlink\" title=\"网页链接\"></a>网页链接</h3><h4 id=\"行内式\"><a href=\"#行内式\" class=\"headerlink\" title=\"行内式\"></a>行内式</h4><p>链接放在【】中，地址放在后面的小括号中，引号内是title<br><a href=\"www.baidu.com\" title=\"百度一下，你就知道\">百度</a><br>[百度]是一个搜索引擎</p>\n<h4 id=\"参数式\"><a href=\"#参数式\" class=\"headerlink\" title=\"参数式\"></a>参数式</h4><p>链接在【】内，地址在冒号后面，title用引号<br>[百度]:<a href=\"http://www.baidu.com/\">www.baidu.com</a> “百度一下，你就知道”<br>[百度]是一个搜索引擎</p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>与链接基本一致，注意在引用图片时【】前加上！<br><img src=\"/2021/08/24/md%E8%AF%AD%E6%B3%95%E8%AF%95%E9%AA%8C/download\\edge\\13623636-6d878e3d3ef63825\" alt=\"logo\"> “my logo”</p>\n<h2 id=\"工整\"><a href=\"#工整\" class=\"headerlink\" title=\"工整\"></a>工整</h2><h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><h2 id=\"由-这三种之一的三个符号表示\"><a href=\"#由-这三种之一的三个符号表示\" class=\"headerlink\" title=\"由* - _这三种之一的三个符号表示\"></a>由* - _这三种之一的三个符号表示</h2><p>这就是分割线</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>&#x2F;&#x2F;例子</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">123</th>\n<th align=\"center\">234</th>\n<th align=\"right\">345</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">abc</td>\n<td align=\"center\">bcd</td>\n<td align=\"right\">cde</td>\n</tr>\n</tbody></table>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"强调字体\"><a href=\"#强调字体\" class=\"headerlink\" title=\"强调字体\"></a>强调字体</h3><ol>\n<li>强调字体<br> 用星号包裹，如<em>md</em>,<strong>md</strong> </li>\n<li>转义<br> 用\\</li>\n<li>删除线<br> <del>删除</del></li>\n</ol>\n",
            "tags": [
                "技术",
                "博客",
                "markdown"
            ]
        }
    ]
}