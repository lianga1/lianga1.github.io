{
    "version": "https://jsonfeed.org/version/1",
    "title": "意大利炮打友军 • All posts by \"操作系统\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "url": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/",
            "title": "操作系统学习笔记2：多线程",
            "date_published": "2024-03-22T09:44:11.000Z",
            "content_html": "<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>现代软件大多支持多线程，相比于进程切换，线程共享代码段，数据段以及其他系统资源，但是拥有单独的寄存器和堆栈。<br>服务器采用多线程，可以减少创建进程的资源消耗，同时处理多个并发请求。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>响应性提高</li>\n<li>资源共享</li>\n<li>创建与切换更加经济</li>\n</ul>\n<h2 id=\"多核编程\"><a href=\"#多核编程\" class=\"headerlink\" title=\"多核编程\"></a>多核编程</h2><p>并行性 vs 并发性<br><strong>并行性</strong>：是同时执行多个任务<br><strong>并发性</strong>：是让每个任务都能取得进展，在单处理器上也能实现</p>\n<p>Amdahl定理：程序中只有S%可以串行执行时，优化比<br>$$\\eta \\leq \\frac{1}{S+\\frac{1-S}{N}}$$</p>\n<h3 id=\"挑战\"><a href=\"#挑战\" class=\"headerlink\" title=\"挑战\"></a>挑战</h3><ul>\n<li>分析一个任务是否可以多核</li>\n<li>平衡某些任务适合单独核心执行</li>\n<li>数据分割</li>\n<li>数据依赖，避免同步性受损</li>\n<li>调试程序</li>\n</ul>\n<h3 id=\"并行类型\"><a href=\"#并行类型\" class=\"headerlink\" title=\"并行类型\"></a>并行类型</h3><p>分为数据并行（把一个任务的不同部分数据分配到不同核心）<br>和任务并行（把多个任务分配到不同核心）</p>\n<h2 id=\"多线程模型\"><a href=\"#多线程模型\" class=\"headerlink\" title=\"多线程模型\"></a>多线程模型</h2><p>线程支持有两种方案：<strong>用户线程</strong>和<strong>内核线程</strong>。用户和内核线程有多重关系模型：</p>\n<ul>\n<li>多对一模型<ul>\n<li>一个内核对应多个用户线程</li>\n<li>线程被用户空间库管理</li>\n<li>效率高</li>\n<li>一个线程阻塞整个进程都会阻塞</li>\n<li>同时只有一个线程访问内核，不支持并行</li>\n</ul>\n</li>\n<li>一对一模型<ul>\n<li>相比于多对一，一对一对并行的支持更好</li>\n<li>但是系统内核线程会影响性能</li>\n<li>Linux Windows都实现了这个模型</li>\n</ul>\n</li>\n<li>多对多模型  <ul>\n<li>对这个模型而言，创建多个用户线程同时保持高性能并发是可能的</li>\n<li>一个变体是允许多对多模型和一对一模型同时存在</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程库\"><a href=\"#线程库\" class=\"headerlink\" title=\"线程库\"></a>线程库</h2><p>  线程库的实现，有<strong>纯用户空间</strong>实现：即所有数据都位于用户空间，调用库函数不涉及系统调用。也有<strong>内核实现</strong>：库的代码和数据结构位于内核空间。POSIX线程库是在内核和用户空间都能实现的库，Windows则是只能在内核实现。JVM取决于宿主系统的库。<br>   POSIX和Windows的库中可以声明全局变量，供所有线程访问。本地数据存放在堆栈，每个线程有自己的堆栈<br>   线程分为同步和异步执行，同步执行的父线程需要等待子线程结束才能执行。<br>   对于Pthread函数，pthread_t tid，pthread_attr_t 是参数类型，pthread_attr_init是初始化函数，pthread_create(&amp;tid,&amp;attr,&amp;func,int)创建线程，使用pthread_join()等待tid的线程结束，pthread_exit()用于退出进程</p>\n<p>   windows api使用windows.h库<br>   Java多线程使用Runnable接口的run方法实现。类需要实现Runnable接口的方法。<br>     在Java中，把一个有Runnable接口的类通过Thread类进行实现，调用thrd的start方法即可自动启动子线程。</p>\n<h2 id=\"隐式多线程\"><a href=\"#隐式多线程\" class=\"headerlink\" title=\"隐式多线程\"></a>隐式多线程</h2><p>这是把创建线程交给编译器和runtime进行</p>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>这个机制允许提前创建出来等待工作，如果池中没有可用线程，进程将会等待。<br>调用的方法类似QueueUserWorkItem（Function，Param，Flags）</p>\n<h3 id=\"OpenMP\"><a href=\"#OpenMP\" class=\"headerlink\" title=\"OpenMP\"></a>OpenMP</h3><p>openmp使用#pragma 的宏命令来只是openmp识别并行区域来执行代码。<br>例如 </p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs inform7\">#pragma omp parallel for<br>for (i=0;i&lt;N;i++)<br>&#123;<br>  c<span class=\"hljs-comment\">[i]</span>=a<span class=\"hljs-comment\">[i]</span>+b<span class=\"hljs-comment\">[i]</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"大中央调度\"><a href=\"#大中央调度\" class=\"headerlink\" title=\"大中央调度\"></a>大中央调度</h3><p>GCD，是MacOSX的一种技术，可以使用<br>^{}标记一个块，放置在调度队列（优先队列）来执行，分配给线程池的一个线程。</p>\n<h2 id=\"多线程问题\"><a href=\"#多线程问题\" class=\"headerlink\" title=\"多线程问题\"></a>多线程问题</h2><h3 id=\"关于fork和exec\"><a href=\"#关于fork和exec\" class=\"headerlink\" title=\"关于fork和exec\"></a>关于fork和exec</h3><p>系统调用中，fork有两种形式：fork可以让新进程<strong>复制所有进程</strong>，或者只<strong>复制调用的进程</strong><br>exec会取代所有线程<br>所以如果fork完立刻调用exec，就只复制一个线程就行。 </p>\n<h3 id=\"信号处理\"><a href=\"#信号处理\" class=\"headerlink\" title=\"信号处理\"></a>信号处理</h3><p>信号是一种UNIX用于通知进程的机制，分为<strong>同步信号</strong>和<strong>异步信号</strong>，同步信号发送到产生事件的同一进程，异步信号发送到其他进程。<br>信号处理程序分为<strong>缺省信号处理</strong>和<strong>用户定义处理程序</strong>。传递信号的函数为kill(pid,signal)。这规定了将信号传递到进程pid，事实上，信号传递到多线程中会有如下可能：</p>\n<ul>\n<li>传递到信号适用的thread</li>\n<li>传递到每个thread</li>\n<li>传递到某些thread</li>\n<li>传递到一个指定接受所有信号的thread</li>\n</ul>\n<p>对于一个异步信号，因为信号只能处理一次，所以传递到第一个不拒绝的线程。<br>pthreads有一个函数：pthread_kill(pthread_t tid, int signal)</p>\n<p>Windows支持异步过程调用来模拟信号机制</p>\n<h3 id=\"线程撤销\"><a href=\"#线程撤销\" class=\"headerlink\" title=\"线程撤销\"></a>线程撤销</h3><p><strong>目标线程</strong>是被撤销的线程。撤销线程分为<strong>异步撤销</strong>（立即撤销）和<strong>延迟撤销</strong>（一个线程检查目标线程何时适合撤销）使用pthread_cancel来撤销。<br>默认pthread是延迟撤销的，创建线程也可以指定是否可以立刻撤销，如果不可以的话，pthread_testcancel()函数可以指定当前可以撤销。</p>\n<h3 id=\"TLS\"><a href=\"#TLS\" class=\"headerlink\" title=\"TLS\"></a>TLS</h3><p>线程本地存储，可以让一个变量作为线程的全局变量，但是其他线程无法访问</p>\n<h3 id=\"调度程序\"><a href=\"#调度程序\" class=\"headerlink\" title=\"调度程序\"></a>调度程序</h3><p>为了保证内核线程的动态调整，系统实现了一个名为轻量级进程LWP的数据结构，对用户线程，其体现为<strong>虚拟处理器</strong>，每个LWP与一个内核线程相连（真正调用物理处理器）。一个进程的LWP数量有限。</p>\n<p>用户线程和内核的通信是通过调度器激活的机制进行的。<br>内核分配一组LWP给应用程序。应用程序将线程分配给LWP。<br>当有事件发生时，例如阻塞，内核出发回调给应用程序，应用程序中的线程库出发回调处理程序来保存阻塞进程的内容，然后分配一个新的线程给原本阻塞线程所在的LWP。阻塞结束后，也是通过回调程序来恢复运行。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2>",
            "tags": [
                "技术",
                "博客",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "url": "http://example.com/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/",
            "title": "操作系统学习笔记1",
            "date_published": "2024-03-22T07:52:53.000Z",
            "content_html": "<h2 id=\"内核设计\"><a href=\"#内核设计\" class=\"headerlink\" title=\"内核设计\"></a>内核设计</h2><h3 id=\"微内核\"><a href=\"#微内核\" class=\"headerlink\" title=\"微内核\"></a>微内核</h3><p>微内核实现了一个功能较少，但是容易扩展的内核架构，客户程序和不同的功能之间提供<strong>消息传递</strong>功能。除了必须内核功能外，功能组件都作为用户程序来实现。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>例如Solaris，有7种可以在运行时加载的模块。</p>\n<h3 id=\"混合架构例子\"><a href=\"#混合架构例子\" class=\"headerlink\" title=\"混合架构例子\"></a>混合架构例子</h3><ul>\n<li>MacOS X，其Mach内核提供了远程过程调用，进程间通信等功能。BSD内核提供了POSIX库和文件系统等功能。</li>\n<li>iOS基于MacOSX，在系统的顶层提供了媒体服务用来支持图形化，Cocoa Touch库提供了有触屏硬件支持的Objective-C API</li>\n<li>Android由Linux内核，增加了一套Dalvik虚拟机和核心库。采用基于Java的Android API用来进行Java开发。运行在Dalvik虚拟机。</li>\n</ul>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><h3 id=\"D-Trace\"><a href=\"#D-Trace\" class=\"headerlink\" title=\"D Trace\"></a>D Trace</h3><p>使用D语言</p>\n<p>这个工具可以动态探测运行系统。跟踪系统调用以及指令的运行环境（用户or内核）<br>DTrace提供内核探头，拥有内核运行的编译器，生成安全指令。通过调用创建的内核探头，执行<strong>启用控制块</strong>可以捕获一些数据。</p>\n<h2 id=\"操作系统生成\"><a href=\"#操作系统生成\" class=\"headerlink\" title=\"操作系统生成\"></a>操作系统生成</h2><p>SYSGEN程序用于配置和生成操作系统。系统安装可以有三种情况</p>\n<ul>\n<li>极端定制：修改源代码，重新编译系统生成</li>\n<li>极端通用：系统描述表已定义好安装的模块，直接激活</li>\n<li>折中：选择模块进行链接来生成</li>\n</ul>\n<h2 id=\"编程实例\"><a href=\"#编程实例\" class=\"headerlink\" title=\"编程实例\"></a>编程实例</h2><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p>头文件：</p>\n<ul>\n<li>linux&#x2F;init.h</li>\n<li>linux&#x2F;kernel.h</li>\n<li>linux.model.h</li>\n</ul>\n<p>重要函数：</p>\n<ul>\n<li>printk：存储到内核日志缓冲区，用dmesg访问，可以指定优先级</li>\n<li>module_init() &amp; module_exit():用于注册模块。</li>\n</ul>\n<p>编译好的内核模块，使用sudo insmod simple.ko来插入内核<br>使用sudo ramos simple来移除</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>kmalloc：分配内核内存 </p>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h2><p>进程是一个活动实体，包含代码、程序计数器、堆栈等。</p>\n<h3 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h3><p>包括：</p>\n<ul>\n<li>新进程：创建进程</li>\n<li>运行中：指令执行中</li>\n<li>等待：进程等待某个信号</li>\n<li>就绪：等待分配处理器</li>\n<li>终止：进程已完成</li>\n</ul>\n<h3 id=\"进程控制块\"><a href=\"#进程控制块\" class=\"headerlink\" title=\"进程控制块\"></a>进程控制块</h3><p>存储了一个进程的相关信息：</p>\n<ul>\n<li>进程状态</li>\n<li>程序计数器</li>\n<li>CPU寄存器</li>\n<li>CPU调度信息</li>\n<li>内存管理信息</li>\n<li>记账信息</li>\n<li>IO状态信息</li>\n</ul>\n<p>信息采用task_struct来表示，位于&lt;linux&#x2F;sched.h&gt;<br>这个结构还存储了父进程、子进程等。<br>linux系统使用一个current_state结构来指向当前运行的进程。</p>\n<h2 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h2><p>被加载运行的进程，进入<strong>任务队列</strong>，在内存中等待运行的就是<strong>就绪队列</strong>，等待IO的进程就放在对应的<strong>设备队列</strong>。</p>\n<p>对于整个流程，进程首先被创建，加入到就绪队列，之后被分配到CPU执行时，会有几种可能：</p>\n<ul>\n<li>发出IO请求，进入IO队列</li>\n<li>创建子进程，等待进程执行结束</li>\n<li>中断产生，被放回就绪队列</li>\n</ul>\n<h3 id=\"调度程序\"><a href=\"#调度程序\" class=\"headerlink\" title=\"调度程序\"></a>调度程序</h3><p>调度程序分为短期调度程序和长期调度程序。</p>\n<ul>\n<li>短期调度程序针对的程序IO请求频繁，决策时间较短。</li>\n<li>长期调度程序的创建和杀死速度都较慢，因此有更多时间进行调度。</li>\n</ul>\n<p>长期调度程序应选择IO于CPU密集型程序并重的进程。</p>\n<h3 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h3><p>切换进程需要切换状态，典型时间为几毫秒。</p>\n<h2 id=\"进程运行\"><a href=\"#进程运行\" class=\"headerlink\" title=\"进程运行\"></a>进程运行</h2><p>进程可以产生子进程，因此其组织结构是“树”。init进程是pid为1的进程</p>\n<p>重要的init子进程：</p>\n<ul>\n<li>kthreadd：创建额外内核进程。</li>\n<li>sshd：创建ssh连接</li>\n</ul>\n<p>ps -el 列出进程</p>\n<p>fork（）函数创建一个子进程，子进程复制父进程的地址空间。它们都执行fork之后的内容。父进程fork（）返回子进程pid。子进程返回0。父进程可能会需要wait子进程。</p>\n<p>注意：windows的createProcess函数不继承父进程空间，而是需要制定一个特定程序。</p>\n<p>父进程可以调用wait，让子进程（僵尸进程）标识符得到释放。并且如果父进程先被终止，如果没有级连终止的要求下，init进程成为子进程的父。</p>\n<h2 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2><p>进程和其他进程通信称为协作。进程间协作机制称为IPC，IPC有两种基本模型：<strong>共享内存</strong>和<strong>消息传递</strong></p>\n<p>目前，在多核系统上，共享内存机制由于高速缓存的不一致性，性能要差于消息传递。</p>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存区域驻留在创建共享内存段的进程内。并且负责确保内存不会被同时写入。<br>共享内存有一个循环数组，用于共享进程发送信息的缓冲。</p>\n<h3 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h3><p>消息传递需要至少提供send()和receive()两个操作。这样要考虑几个问题：</p>\n<ul>\n<li>直接or间接通信</li>\n<li>同步or异步</li>\n<li>自动or显式缓冲</li>\n</ul>\n<h4 id=\"通信的直接or间接\"><a href=\"#通信的直接or间接\" class=\"headerlink\" title=\"通信的直接or间接\"></a>通信的直接or间接</h4><p>采用直接通信的send()和receive()都需要直接指定接收方的地址，可能是对称或非对称的（非对称即接收方只能接受向其发送的进程信息）</p>\n<p>间接通信的方法则通过邮箱或端口来发送信息。通过把邮箱抽象为一个对象，这种方式有如下特点：</p>\n<ul>\n<li>共享邮箱才能建立链路</li>\n<li>一个链路与多个进程关联</li>\n<li>两个进程之间可以有多个链路<br>但是一个消息只能被一个进程接收<br>邮箱可以为系统或进程拥有，进程拥有的邮箱必须要确定所有者和使用者。所有者只能接受信息，使用者只能发送信息。<br>进程被终止后，邮箱将消失。操作系统的邮箱是独立存在的。操作系统提供机制允许进程进行创建、删除、使用邮箱。而且通过系统调用，邮箱的所有权可以传给其他进程。</li>\n</ul>\n<h4 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h4><p>关于消息传递的同步性，有以下四种可能：</p>\n<ul>\n<li>阻塞发送：发送消息后，直到被接收，进程都将阻塞</li>\n<li>非阻塞发送：发送后继续操作</li>\n<li>阻塞接收：阻塞进程，直到能接收信息</li>\n<li>非阻塞接收：接收进程收到有效信息或空信息</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>缓存有三种形式：</p>\n<ul>\n<li>零容量：要求发送者应当阻塞发送，因为消息队列不能等待。</li>\n<li>有限容量：最多n条消息可以等待，超过这个数量时进程将阻塞</li>\n<li>无限容量：进程不会阻塞发送</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"posix\"><a href=\"#posix\" class=\"headerlink\" title=\"posix\"></a>posix</h4><p>posix通过内存映射文件共享内存，通过系统调用shm_open(name,O_CREAT|O_RDRW,0666)函数来创建共享内存对象。<br>创建成功后，函数ftruncate(shm_fd,4096)用于配置对象的大小（4096字节）<br>最后，mmap()函数用于将内存映射文件包含共享内存。返回ptr<br>使用sprintf()将message写入ptr。<br>最终消费者使用了共享内存后，调用shm_unlink()移除共享内存</p>\n<h4 id=\"Mach\"><a href=\"#Mach\" class=\"headerlink\" title=\"Mach\"></a>Mach</h4><p>Mach通过消息传递（采用邮箱）实现<br>包括两个邮箱：内核邮箱和通知邮箱。调用msg_send()来发送消息，msg_receive()接收消息，msg_rpc()用来进行远程过程调用。<br>系统调用port_allocate()来创建新邮箱。可以指定最大排队信息，而且消息复制到邮箱中可以保证单个发送者的顺序统一。<br>发送消息如果遇到邮箱满了，可能会等待（无限或n毫秒），或者立刻返回，或者在操作系统中为一个线程存储一个消息。<br>邮箱可以形成一个邮箱集合来服务单个任务。port_status()用于返回指定邮箱的消息数量。<br>Mach本来是为了分布式系统设计，但是为了多核系统，Mach也可以使用虚拟内存，把发送者地址空间映射到接收者地址空间，来提高性能。</p>\n<h4 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h4><p>windows支持多个操作环境或子系统，应用程序通过消息传递来通信。Windows使用ALPC工具来进行进程间通信。<br>类似于TCP连接，Windows内部也使用了<strong>连接端口</strong>和<strong>通信端口</strong>区分的思想。此外，通信回调机制允许服务器和客户端在等待时也能响应接受请求。<br>这个机制包含三种技术：</p>\n<ul>\n<li>对于小消息，采用消息队列进行存储，复制传递</li>\n<li>对于大消息（256字节+）：采用区段对象传递，为共享内存。</li>\n<li>对于巨大消息，采用API直接读写目标地址空间。</li>\n</ul>\n<p>注意：ALPC不属于WinAPI</p>\n<h3 id=\"服务器和客户端通信\"><a href=\"#服务器和客户端通信\" class=\"headerlink\" title=\"服务器和客户端通信\"></a>服务器和客户端通信</h3><h4 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字\"></a>套接字</h4><p>详见计算机网络</p>\n<h4 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h4><p>RPC：远程过程调用</p>\n<p>RPC和套接字不同，具有明确的数据结构。和本地调用过程相似，RPC隐藏了远程调用的通信细节。<br>对于每个远程过程，客户端都有一个存根用来调用服务器端口，并传递参数。返回值也可以传递回客户端。<br>通过时间戳，系统可以避免RPC被重复执行。而且还需要和客户确认RPC调用已经收到且执行。这要求客户机实现RPC调用的发送后接收到ACK信息。<br>使用交会服务程序，可以让客户请求RPC的端口灵活分配。<br>RPC可用于实现分布式文件系统</p>\n<h4 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h4><p>管道是一个半双工的结构<br>分为<strong>普通管道</strong>和<strong>命名管道</strong><br>UNIX上，管道采用pipe(int fd[])函数来创建，fd[0]为读出端，fd[1]为写入端<br>父子进程通信可以使用管道来进行，因为子进程继承了夫进程的管道，他们共享一个管道但是有两个fd。但是普通管道需要在同一机器上有父子关系的进程。</p>\n<p>命名管道：提供了一个双向的，不必须父子关系的，多进程通信的管道。<br>而且通信结束后，管道依旧存在。</p>\n<ul>\n<li><p>对于UNIX，管道通过mkfifo()系统调用来进行。通过调用对文件的读写函数来进行常规读写。只有显式删除才会关闭管道。这是半双工且单机通信的，除非用套接字来进行远程通信。</p>\n</li>\n<li><p>对于Windows，CreateNamedPipe()支持创建全双工且支持远程的通信。</p>\n</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "操作系统"
            ]
        }
    ]
}