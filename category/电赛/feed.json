{
    "version": "https://jsonfeed.org/version/1",
    "title": "意大利炮打友军 • All posts by \"电赛\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/07/07/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-07/",
            "url": "http://example.com/2023/07/07/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-07/",
            "title": "电赛培训-23-07-07",
            "date_published": "2023-07-07T01:34:49.000Z",
            "content_html": "<h1 id=\"串口通信\"><a href=\"#串口通信\" class=\"headerlink\" title=\"串口通信\"></a>串口通信</h1><h2 id=\"串行vs并行\"><a href=\"#串行vs并行\" class=\"headerlink\" title=\"串行vs并行\"></a>串行vs并行</h2><p>并行优点：快，效率高<br>缺点：需要端口多<br>串行优点：只需要一个端口<br>缺点：慢，效率低，且需要明确数据拍成一串的规则<br>（大端法vs小端法）</p>\n<h2 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h2><p>串行通信每次只发送一个字节，对于字节内部发送bit的顺序，每个通讯协议都是相同的，但是字节的顺序却不一定相同，这就是大端法和小端法的区别。</p>\n<h3 id=\"I2C通信\"><a href=\"#I2C通信\" class=\"headerlink\" title=\"I2C通信\"></a>I2C通信</h3><p>一个通信口可以和多个设备进行传输，只需要SDA和SCL两个数据线即可，SDA为数据线，SCL为时钟线，时钟线由主设备控制，主设备为发送方，从设备为接收方，从设备的地址由主设备指定，主设备发送数据时，从设备会返回一个ACK信号，表示接收成功，如果没有返回ACK信号，主设备会认为发送失败，重新发送。<br>但是，I2C驱动能力较弱，需要在数据线加上拉电阻，且所有设备必须有不同地址。</p>\n<h3 id=\"SPI通信\"><a href=\"#SPI通信\" class=\"headerlink\" title=\"SPI通信\"></a>SPI通信</h3><p>不需要考虑地址为问题，可以一个Master带多个slave。<br>缺点：每多一个从机，就需要有一个IO口作为片选信号，且需要一个时钟信号，所以需要的IO口较多。</p>\n<h3 id=\"UART通信\"><a href=\"#UART通信\" class=\"headerlink\" title=\"UART通信\"></a>UART通信</h3><p>接线非常简单，且双方对等，谁都可以随时发送信息。<br>缺点：容易接错，且难实现多个设备同时通信。而且功耗较大，所以很多传感器上不配备。<br>波特率：每个位对应时间长度的倒数<br>uart通信有起始位，数据位，校验位，停止位，所以每个字节需要10个bit，所以波特率为115200时，每秒可以传输11520个字节。</p>\n<h4 id=\"电平标准\"><a href=\"#电平标准\" class=\"headerlink\" title=\"电平标准\"></a>电平标准</h4><p>usb标准：看D+和D-的电平差，差大是1，小是0<br>TTL电平：0v是低电平，5&#x2F;3.3v是高电平<br>RS232电平：-3v<del>-15v是低电平，3v</del>15v是高电平</p>\n<h4 id=\"Arduino的uart\"><a href=\"#Arduino的uart\" class=\"headerlink\" title=\"Arduino的uart\"></a>Arduino的uart</h4><p>ttl电平5v<br>1为tx<br>0为rx<br>内部已通过ch340g串口转usb，与usb相连，arduino用uart串口发送信息时，会通过ch340g转换为usb信号，所以可以通过usb接收信息。<br>函数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span><span class=\"hljs-keyword\">begin</span>(baudrate)：设置波特率<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serianl</span>.</span></span>print(content,选项)：发送信息,可以是数字，字符串，数组，对象，选项可以是DEC，BIN，OCT，HEX，BYTE，WORD，FLOAT，STRING，可以指定发送的进制，或者发送字符串。<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>println(content,选项)：发送信息，与print不同的是，会在最后加上换行符。<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>available<span class=\"hljs-literal\">()</span>：返回接收缓冲区中的字节数<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>read<span class=\"hljs-constructor\">Bytes(<span class=\"hljs-params\">char</span>类型数组名，最大读取长度)</span><br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>write(<span class=\"hljs-built_in\">char</span>类型数组名，写入长度)：总共能发送数据长度个字节。按照数组中每个原始值诸葛发送，可以借助这个功能，对<span class=\"hljs-keyword\">struct</span>结构体中相关数据作为一个整体，将结构体指针强制转型为byte*类型，后面数据长度用sizeof(<span class=\"hljs-keyword\">struct</span>),这样就可以将结构体作为一个整体发送。<br></code></pre></td></tr></table></figure>\n<h4 id=\"Arduino的uart工具\"><a href=\"#Arduino的uart工具\" class=\"headerlink\" title=\"Arduino的uart工具\"></a>Arduino的uart工具</h4><ul>\n<li>串口绘图仪：可以发送数据时利用数据名：数据的格式，将以时间为横轴，数值为纵轴，根据格式中构成的变量数量，以不同颜色的线段，随时间变化的情况进行绘图。</li>\n<li>BYSerial<br>串口不能同时被多个程序打开。<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2>基本概念：</li>\n<li>TCP&#x2F;IP协议：定义了设备如何连接如互联网</li>\n<li>TCP：信息必须齐全的网络通信的基础</li>\n<li>UDP：信息可以缺少或者需要广播的网络通信的基础</li>\n<li>IP：计算机之间用于识别身份的临时位置编号</li>\n<li>ICMP：网络控制信号协议</li>\n<li>DHCP：动态分配ip地址协议</li>\n<li>一个能连接互联网的网课出厂自带的编号。<h3 id=\"ipv4\"><a href=\"#ipv4\" class=\"headerlink\" title=\"ipv4\"></a>ipv4</h3>ipv4定义了32位二进制地址<br>同时，ipv4定义了一些只会用于内部网络的地址编号，称为私网ip段，剩下的都是用于全球公网ip。<br>例如</li>\n</ul>\n<p>10.0.0.0-10.255.255.255<br>172.16.0.0-172.31.255.255<br>192.168.0.0-192.168.255.255</p>\n<h3 id=\"ipv6\"><a href=\"#ipv6\" class=\"headerlink\" title=\"ipv6\"></a>ipv6</h3><p>ipv6定义了128位二进制地址</p>\n<h3 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h3><p>子网掩码用于判断ip地址的前几位是网络号，后几位是主机号。<br>32个二进制位表示ip地址截止到哪里，只要相同就认为在同一个子网内，可以直接通信无需交给网关做转发。要求必须1卡头，连续多个1，剩下的是0。255.255.255.0对于这个设备，前面三个点分十进制数相同，那就认为是在同一个网络下，因此会直接连接而不会寻求网关。</p>\n<h3 id=\"tcp协议\"><a href=\"#tcp协议\" class=\"headerlink\" title=\"tcp协议\"></a>tcp协议</h3><p>传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议，一个tcp连接需要有：</p>\n<ol>\n<li>在一个网络色悲伤，特定的网络端口如8080（最好大于1023）上开创一个tcp server，这个过程叫做绑定端口，并开始监听端口。</li>\n<li>得到该网络设备的ip地址，因此需要体现获得server的ipv4地址，以及开启tcp监听端口。<h3 id=\"udp协议\"><a href=\"#udp协议\" class=\"headerlink\" title=\"udp协议\"></a>udp协议</h3>无连接的传输协议，成为用户数据报协议<br>udp提供了一个无需链接就能发送封装的ip数据包的方法，建立一套tcp连接需要有：</li>\n<li>在一个网络设备上，特定的网络端口如8080（最好大于1023）上开创一个udp socket</li>\n<li>设定好目的地IP地址和端口便可以随心所欲发送数据</li>\n<li>目的地ip地址对应网络设备B，如果尝试在自己9090端口上开创一个udp socket，且A正好在发送信息，那么此时就能受到A发送的信息。</li>\n</ol>\n<h2 id=\"wifi连接\"><a href=\"#wifi连接\" class=\"headerlink\" title=\"wifi连接\"></a>wifi连接</h2><h3 id=\"station终端\"><a href=\"#station终端\" class=\"headerlink\" title=\"station终端\"></a>station终端</h3><p>新建station</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">import</span> network<br>wlan - network.WLAN(network.STA.<span class=\"hljs-keyword\">IF</span>)# <span class=\"hljs-keyword\">create</span> station<br>wlan.active(<span class=\"hljs-keyword\">True</span>)<br>wlan.scan() #scan <span class=\"hljs-keyword\">for</span> acess points(AP)<br>wlan.isconnected() #<span class=\"hljs-keyword\">check</span> <span class=\"hljs-keyword\">if</span> the station <span class=\"hljs-keyword\">is</span> connected <span class=\"hljs-keyword\">to</span> an AP<br><br>wlan.<span class=\"hljs-keyword\">connect</span>(<span class=\"hljs-string\">&#x27;ssid&#x27;</span>, <span class=\"hljs-string\">&#x27;key&#x27;</span>) #<span class=\"hljs-keyword\">connect</span> <span class=\"hljs-keyword\">to</span> an AP<br>wlan.config(<span class=\"hljs-string\">&#x27;mac&#x27;</span>) #<span class=\"hljs-keyword\">get</span> the interfac<span class=\"hljs-string\">e&#x27;s MAC address</span><br><span class=\"hljs-string\">wlan.ifconfig() #get the interface&#x27;</span>s IP/netmask/gw/DNS addresses<br></code></pre></td></tr></table></figure>\n<p>新建AP</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">import</span> network<br>ap = network.WLAN(network.AP_IF) # <span class=\"hljs-keyword\">create</span> acess <span class=\"hljs-type\">point</span> interface<br>ap.config(ssid=<span class=\"hljs-string\">&#x27;ESP-AP&#x27;</span>) #<span class=\"hljs-keyword\">set</span> the SSID <span class=\"hljs-keyword\">of</span> the <span class=\"hljs-keyword\">access</span> <span class=\"hljs-type\">point</span><br>ap.config(max_clients=<span class=\"hljs-number\">10</span>) #<span class=\"hljs-keyword\">set</span> how many clients can <span class=\"hljs-keyword\">connect</span> <span class=\"hljs-keyword\">to</span> the <span class=\"hljs-keyword\">access</span> <span class=\"hljs-type\">point</span><br>ap.active(<span class=\"hljs-keyword\">True</span>)<br></code></pre></td></tr></table></figure>\n<p>tcp通讯：</p>\n<ol>\n<li>连接wifi</li>\n<li>获取本地ip</li>\n<li>创建tcp</li>\n<li>绑定本地ip和端口</li>\n<li>设定最大连接数</li>\n<li>配置tcp选项</li>\n<li>用户进入获取用户组</li>\n<li>读取用户信息，</li>\n<li>发送接收到的数据给发送者</li>\n</ol>\n<p>udp通讯：server</p>\n<ol>\n<li>创建socket对象要设置udp模式</li>\n</ol>\n<p>udp通信：client</p>\n<ol>\n<li>判断wifi连接</li>\n<li>发送使用sendto函数</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/06/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-06/",
            "url": "http://example.com/2023/07/06/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-06/",
            "title": "电赛培训-23-07-06",
            "date_published": "2023-07-06T01:48:40.000Z",
            "content_html": "<h1 id=\"ESP32\"><a href=\"#ESP32\" class=\"headerlink\" title=\"ESP32\"></a>ESP32</h1><h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p>中断处理程序不要运行时间过长，不要分配内存</p>\n<h3 id=\"紧急异常缓冲区\"><a href=\"#紧急异常缓冲区\" class=\"headerlink\" title=\"紧急异常缓冲区\"></a>紧急异常缓冲区</h3><p>如果ISR中发生错误，MicroPython无法生成错误报告<br>除非创建特殊缓冲区</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-keyword\">import</span> micropython<br><span class=\"hljs-title\">micropython</span>.alloc_emergency_exception_buf(<span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"UART\"><a href=\"#UART\" class=\"headerlink\" title=\"UART\"></a>UART</h2><p>esp32有三个硬件UART，分别是UART0，UART1，UART2<br>各自分配了默认GPIO<br>TX：当前设备的发送<br>RX：当前设备的接收<br>串口中不分主从</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">from</span> machine import UART<br><span class=\"hljs-attribute\">uart1</span> = (<span class=\"hljs-number\">1</span>,baudrate=<span class=\"hljs-number\">9600</span>,tx=<span class=\"hljs-number\">33</span>,rx=<span class=\"hljs-number\">32</span>)#指定了id<br><br></code></pre></td></tr></table></figure>\n<p>任何GPIO都可以用于使用GPIO矩阵的硬件UART，除了可以用作rx的仅输入引脚34-39<br>发送与接受的波特率一样</p>\n<p>一种调试方法：不能使用调试器时，可以利用串口输出进行调试。</p>\n<h2 id=\"ADC\"><a href=\"#ADC\" class=\"headerlink\" title=\"ADC\"></a>ADC</h2><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">from machine import ADC<br>adc = <span class=\"hljs-constructor\">ADC(<span class=\"hljs-params\">pin</span>)</span><br><span class=\"hljs-keyword\">val</span> = adc.read<span class=\"hljs-constructor\">_u16()</span><br><span class=\"hljs-keyword\">val</span> = adc.read<span class=\"hljs-constructor\">_uv()</span># <span class=\"hljs-keyword\">to</span> microvolts<br></code></pre></td></tr></table></figure>\n<p><strong>ADC2也被wifi使用，所以开启wifi时会发生adc2异常</strong></p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>Timer.init(*,mode&#x3D;Timer.PERIODIC,period&#x3D;-1,callback&#x3D;None)</p>\n<ul>\n<li>mode 可以是ONE_SHOT或PERIODIC（单次或周期计时）</li>\n</ul>\n<h2 id=\"PWM\"><a href=\"#PWM\" class=\"headerlink\" title=\"PWM\"></a>PWM</h2>",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/",
            "url": "http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/",
            "title": "电赛培训-23-07-05",
            "date_published": "2023-07-05T01:46:48.000Z",
            "content_html": "<h1 id=\"Arduino\"><a href=\"#Arduino\" class=\"headerlink\" title=\"Arduino\"></a>Arduino</h1><p>软件：使用Arduino IDE，以C++风格语言编写相关库。<br>利用IDE编译固件下载到Arduino的前提条件是有bootloader程序。<br>所以从程序到固件的关键在于bootloader，其他单片机也可以装载bootloader固件，然后使用arduino库。</p>\n<h2 id=\"硬件-uno板\"><a href=\"#硬件-uno板\" class=\"headerlink\" title=\"硬件 uno板\"></a>硬件 uno板</h2><p>工作电压5v,可以typeB，DC5.5，或者跳线接入<br>共有14个数字输入输出（6个PWM口），6个模拟输入输出</p>\n<h2 id=\"系统指示灯\"><a href=\"#系统指示灯\" class=\"headerlink\" title=\"系统指示灯\"></a>系统指示灯</h2><ul>\n<li>ON：系统指示灯</li>\n<li>RX：接收指示灯</li>\n<li>TX：发送指示灯</li>\n<li>L：内置LED，对应13号数字口<h2 id=\"开始编写代码\"><a href=\"#开始编写代码\" class=\"headerlink\" title=\"开始编写代码\"></a>开始编写代码</h2>有两个一定会有的函数，void setup()和void loop()，分别是初始化和循环函数。<br>setup会执行一次，loop在setup后会自动循环<h3 id=\"setup函数\"><a href=\"#setup函数\" class=\"headerlink\" title=\"setup函数\"></a>setup函数</h3>setup中用pinMode配置管脚模式为输出<br>pinMode(pin编号，INPUT)：高阻态，可认为是100m欧姆，电平不定。<br>pinMode(pinnum,INPUT_PULLUP):内置上拉输入，无外部信号默认高电平。<br>pinMode(pinnum,OUTPUT):输出模式，uno上高电平5v，电流&lt;40mA</li>\n</ul>\n<h3 id=\"loop函数\"><a href=\"#loop函数\" class=\"headerlink\" title=\"loop函数\"></a>loop函数</h3><ul>\n<li>digitalWrite(pinnum,HIGH&#x2F;LOW):输出高低电平，只对output模式有效</li>\n<li>digitalRead(pinnum):读取高低电平,返回HIGH&#x2F;LOW两种电平</li>\n<li>analogRead(anaPinNum)：读取模拟输入电平，返回0-1023的数字，对应0-5v的电压</li>\n<li>analogWrite(pwmPinNum,0-255)：输出PWM波，对应0-5v的电压，频率为490Hz(3,9,10,11pin),或980Hz(5,6pin)</li>\n<li>analogReference(AD参考电压输入来源)：切换AD参考电压输入来源，有默认值，一般不用，可以让输出更加精细。</li>\n</ul>\n<h3 id=\"中断和轮询\"><a href=\"#中断和轮询\" class=\"headerlink\" title=\"中断和轮询\"></a>中断和轮询</h3><p>轮询：不断重复读取某个状态值，缺点是占用资源<br>中断：可以通过某个状态改变来发送信号，然后发送信号后可以执行其他操作，之后再恢复到发送信号之前的状态。<br>管脚中断：attachInterrupt(digitalPinToInterrupt(pinnum),ISR,mode),第一个参数是中断管脚号（uno为2，3），第二个参数是中断服务函数（可以自定义），第三个参数是中断模式，有LOW，RISING，FALLING，CHANGE四种模式。</p>\n<ul>\n<li>LOW：低电平触发</li>\n<li>RISING：上升沿触发</li>\n<li>FALLING：下降沿触发</li>\n<li>CHANGE：任意电平变化触发</li>\n</ul>\n<p><strong>注意，终端服务函数应当很短，而且不能使用其他中断实现的函数，延时需要delayMicroseconds(us)</strong><br><strong>修改全局变量应当用volatile修饰，防止编译器优化</strong></p>\n<h1 id=\"ESP32\"><a href=\"#ESP32\" class=\"headerlink\" title=\"ESP32\"></a>ESP32</h1><h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>esp32-WROOM-32<br>串口芯片：CP2102<br>核心频率240mHz<br>WiFi IEEE 802.11 b&#x2F;g&#x2F;n 2.4GHz<br>BLuetooth 4.2 BR&#x2F;EDR and BLE<br>520k SRAM 448kB ROM<br>2个I2S，RMT远程控制，LED PWM，1个host SD&#x2F;eMMC&#x2F;SDIO，一个slave SDIO&#x2F;SPI. TWAI(CAN),12bitADC,Ethernet</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>MicroPython+Thonny</p>\n<h3 id=\"常用库\"><a href=\"#常用库\" class=\"headerlink\" title=\"常用库\"></a>常用库</h3><h3 id=\"GPIO\"><a href=\"#GPIO\" class=\"headerlink\" title=\"GPIO\"></a>GPIO</h3><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">from</span> machine <span class=\"hljs-keyword\">import</span> Pin<br><br>p0 = Pin(<span class=\"hljs-number\">0</span>,Pin.<span class=\"hljs-keyword\">OUT</span>) # <span class=\"hljs-keyword\">create</span> output pin <span class=\"hljs-keyword\">on</span> GPIO0<br>p0.<span class=\"hljs-keyword\">on</span>() # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> &quot;on&quot; (high) <span class=\"hljs-keyword\">level</span><br>p0.<span class=\"hljs-keyword\">off</span>() # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> &quot;off&quot; (low) <span class=\"hljs-keyword\">level</span><br>p0.<span class=\"hljs-keyword\">value</span>(<span class=\"hljs-number\">1</span>) # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">on</span>/high<br>p0.init(p0.<span class=\"hljs-keyword\">IN</span>,p0.PULL_DOWN) # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">with</span> a pull-down resistor<br></code></pre></td></tr></table></figure>\n<p>init函数中，id是强制的</p>\n<ul>\n<li><p>mode指定引脚模式，有IN，OUT，OPEN_DRAIN，AF_OPEN_DRAIN四种模式</p>\n</li>\n<li><p>pull指定引脚是否连接弱上拉电阻，有None，PULL_UP，PULL_DOWN三种模式<br>弱上拉指上拉电阻阻值较大，高电平很容易因为外部电流驱动而拉低。</p>\n</li>\n<li><p>drive具有不同的最大安全电流的限制，有DRIVE_0-3四种选择</p>\n</li>\n<li><p>alt为引脚的备用功能，仅对alt和alt_open_drain两种模式有效，有0-7八种选择</p>\n</li>\n</ul>\n<p>value函数中，如果不带参数，就是得到当前状态，如果在输出模式，需要带参数，变为设置电平</p>\n<p>配置在引脚的触发源处于活动状态时要调用中断处理程序，如果引脚模式为Pin.IN，可以使用irq函数，如果引脚模式为Pin.IN，可以使用Pin.IRQ_RISING，Pin.IRQ_FALLING，Pin.IRQ_ANY三种模式，分别对应上升沿，下降沿，任意电平变化触发中断。</p>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",
            "url": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",
            "title": "电赛学习笔记-机器视觉",
            "date_published": "2023-05-14T09:04:31.000Z",
            "content_html": "<h1 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h1><h2 id=\"安装opencv\"><a href=\"#安装opencv\" class=\"headerlink\" title=\"安装opencv\"></a>安装opencv</h2><h2 id=\"开发板：STM32F407\"><a href=\"#开发板：STM32F407\" class=\"headerlink\" title=\"开发板：STM32F407\"></a>开发板：STM32F407</h2><h2 id=\"IDE：STM32CubeIDE\"><a href=\"#IDE：STM32CubeIDE\" class=\"headerlink\" title=\"IDE：STM32CubeIDE\"></a>IDE：STM32CubeIDE</h2><h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><p>配置工程ioc文件，配置好基础外设后，再packs中安装X-CUBE-AI组件包，在软件包外设中添加模型文件，设置压缩倍数，导入测试集验证准确率</p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><h3 id=\"yolo\"><a href=\"#yolo\" class=\"headerlink\" title=\"yolo\"></a>yolo</h3><p>利用mobilenet yolo50k模型可以导入到单片机中，只需要较少内存即可实现实时运行，实现人脸识别的功能</p>\n<h3 id=\"openmv\"><a href=\"#openmv\" class=\"headerlink\" title=\"openmv\"></a>openmv</h3><h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>正点原子ov7725摄像头<br>yolo50k</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p><a href=\"https://www.bilibili.com/video/BV1Bt411w77m/?share_source=copy_web&vd_source=4ed5c2c0429d7681216f506ac1e74065\">稚晖君</a><br><a href=\"https://github.com/dog-qiuqiu/MobileNet-Yolo\">yolo50k仓库</a><br><a href=\"https://www.bilibili.com/video/BV1FL411u72p/?share_source=copy_web&vd_source=4ed5c2c0429d7681216f506ac1e74065\">实时运行案例</a></p>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/",
            "url": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/",
            "title": "电赛学习笔记-micropython",
            "date_published": "2023-05-14T08:47:54.000Z",
            "content_html": "<h1 id=\"micropython简介\"><a href=\"#micropython简介\" class=\"headerlink\" title=\"micropython简介\"></a>micropython简介</h1><p>micropython是一个能够利用python进行单片机开发的固件，目前主要是在esp32平台上进行的开发</p>\n<h1 id=\"micropython安装\"><a href=\"#micropython安装\" class=\"headerlink\" title=\"micropython安装\"></a>micropython安装</h1><ul>\n<li>在micropython官网找到对应的单片机的型号的固件文件（.bin），下载到对应位置</li>\n<li>pip install esptool</li>\n<li>连接esp32单片机，查看端口号</li>\n<li>根据micropython官网的指示，利用esptool.py文件，清除单片机flash，再部署固件到单片机。</li>\n<li>安装uPyCraft IDE，选择好开发板类型和端口号后，<h1 id=\"micropython使用\"><a href=\"#micropython使用\" class=\"headerlink\" title=\"micropython使用\"></a>micropython使用</h1>需要根据单片机自带的库函数，进行python文档的开发<h1 id=\"micropython的优点\"><a href=\"#micropython的优点\" class=\"headerlink\" title=\"micropython的优点\"></a>micropython的优点</h1>代码量少，配置简单</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/",
            "url": "http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/",
            "title": "电赛学习笔记（1）——stm32学习笔记",
            "date_published": "2023-05-11T08:19:20.000Z",
            "content_html": "<h1 id=\"stm32基础\"><a href=\"#stm32基础\" class=\"headerlink\" title=\"stm32基础\"></a>stm32基础</h1><h2 id=\"关于stm32产品线\"><a href=\"#关于stm32产品线\" class=\"headerlink\" title=\"关于stm32产品线\"></a>关于stm32产品线</h2><h3 id=\"stm32f1系列-cortex-m3\"><a href=\"#stm32f1系列-cortex-m3\" class=\"headerlink\" title=\"stm32f1系列 cortex-m3\"></a>stm32f1系列 cortex-m3</h3><h3 id=\"stm32f4系列-cortex-m4\"><a href=\"#stm32f4系列-cortex-m4\" class=\"headerlink\" title=\"stm32f4系列 cortex-m4\"></a>stm32f4系列 cortex-m4</h3><ul>\n<li>内置了rgb lcd驱动</li>\n<li>加入了DSP与FPU模块<h3 id=\"stm32f7系列-cortex-m7\"><a href=\"#stm32f7系列-cortex-m7\" class=\"headerlink\" title=\"stm32f7系列 cortex-m7\"></a>stm32f7系列 cortex-m7</h3></li>\n<li>高速内存得到应用 <h2 id=\"寄存器编程\"><a href=\"#寄存器编程\" class=\"headerlink\" title=\"寄存器编程\"></a>寄存器编程</h2></li>\n</ul>\n<p><strong>关键字volatile</strong>需要在声明寄存器变量的时候添加，因为要防止编译器自行优化。</p>\n<h2 id=\"HAL库\"><a href=\"#HAL库\" class=\"headerlink\" title=\"HAL库\"></a>HAL库</h2><p>硬件抽象层，可以将不同产品线的芯片的寄存器操作抽象为函数，方便移植<br><strong><font color=\"red\">本笔记使用HAL库进行编程</font></strong><br>相对的，HAL库会产生大量的判断来降低代码运行效率<br>但是，还有另一个Low Layer库（LL），这个库可以提高效率</p>\n<h2 id=\"stm32cubeMX配置\"><a href=\"#stm32cubeMX配置\" class=\"headerlink\" title=\"stm32cubeMX配置\"></a>stm32cubeMX配置</h2><h2 id=\"stm32计时器\"><a href=\"#stm32计时器\" class=\"headerlink\" title=\"stm32计时器\"></a>stm32计时器</h2><h3 id=\"PWM调制输出\"><a href=\"#PWM调制输出\" class=\"headerlink\" title=\"PWM调制输出\"></a>PWM调制输出</h3><h4 id=\"几个重要参数\"><a href=\"#几个重要参数\" class=\"headerlink\" title=\"几个重要参数\"></a>几个重要参数</h4><ul>\n<li>占空比：高电平占整个周期的比例</li>\n<li>频率：整个PWM周期的倒数</li>\n<li>分辨率：占空比变化步长 <h4 id=\"PWM实现方法\"><a href=\"#PWM实现方法\" class=\"headerlink\" title=\"PWM实现方法\"></a>PWM实现方法</h4>输出比较模式，依靠内部计数器cnt和ccr设置的数值的比较来进行输出电平的控制，常用的有匹配时电平翻转和PWM模式<br>PWM占空比：$$DutyCycle&#x3D;\\frac{CCR}{ARR}$$<br>PWM频率：$$Freq&#x3D;\\frac{F_{clk}}{ARR}$$<br>PWM分辨率：$$Resolution&#x3D;\\frac{ARR}{2^{n}}$$<h4 id=\"高级定时器\"><a href=\"#高级定时器\" class=\"headerlink\" title=\"高级定时器\"></a>高级定时器</h4>死区生成：可以避免推挽电路上下管同时打开导致短路<h3 id=\"PWM控制电机\"><a href=\"#PWM控制电机\" class=\"headerlink\" title=\"PWM控制电机\"></a>PWM控制电机</h3>舵机是根据pwm信号控制舵机转动角度的，内部有直流电机<h4 id=\"电机驱动芯片\"><a href=\"#电机驱动芯片\" class=\"headerlink\" title=\"电机驱动芯片\"></a>电机驱动芯片</h4>利用H桥，可以控制电机转动方向。四个开关管可以构成两个推挽电路，使得电机可以获得两个方向的电流。<br>电机需要的电源一般是大功率的，不能直接通过gpio驱动，因此可以通过让stlink的5v口接入电机驱动芯片来获得电源。但是注意，pwm信号的地应当和电机电源的地相连，否则会出现电平不稳定的情况。<h3 id=\"PWM代码\"><a href=\"#PWM代码\" class=\"headerlink\" title=\"PWM代码\"></a>PWM代码</h3>pwm的激活结构如下：<br><img src=\"/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/PWM_Structure.jpg\" alt=\"PWM_Structure\"></li>\n<li>RCC开启时钟</li>\n<li>配置时基单元</li>\n<li>配置输出比较单元</li>\n<li>配置GPIO，设置为复用推挽输出</li>\n<li>运行控制，启动计数器<h4 id=\"TIM库函数\"><a href=\"#TIM库函数\" class=\"headerlink\" title=\"TIM库函数\"></a>TIM库函数</h4>在hal库中，tim相关库函数在stm32f1xx_hal_tim.h文件中<br>其中有关输出比较的内容有：</li>\n<li>TIM_OC_InitTypeDef: 输出比较初始化结构体</li>\n<li>HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)：输出比较初始化函数</li>\n<li>HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel)：配置输出通道函数</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        }
    ]
}