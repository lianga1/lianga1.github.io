{
    "version": "https://jsonfeed.org/version/1",
    "title": "意大利炮打友军 • All posts by \"电赛\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/07/27/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-27/",
            "url": "http://example.com/2023/07/27/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-27/",
            "title": "电赛培训-23-07-27",
            "date_published": "2023-07-27T02:04:23.000Z",
            "content_html": "<h2 id=\"赛程\"><a href=\"#赛程\" class=\"headerlink\" title=\"赛程\"></a>赛程</h2><p>9-11号作品测评<br>2号早晨7点半到413，放题</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/19/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-19/",
            "url": "http://example.com/2023/07/19/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-19/",
            "title": "电赛培训-23-07-19",
            "date_published": "2023-07-19T02:19:52.000Z",
            "content_html": "<h1 id=\"pid控制系统\"><a href=\"#pid控制系统\" class=\"headerlink\" title=\"pid控制系统\"></a>pid控制系统</h1><h2 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h2><p>$$ u(t)&#x3D;K_p e(t)+K_i \\int_0^t e(\\tau) d\\tau + K_d \\frac{de(t)}{dt} $$</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><ul>\n<li>比例项：减小误差</li>\n<li>积分项：消除稳态误差</li>\n<li>微分项：减小超调量</li>\n</ul>\n<h3 id=\"超调量\"><a href=\"#超调量\" class=\"headerlink\" title=\"超调量\"></a>超调量</h3><p>$$ \\xi &#x3D; \\frac{e^{-\\frac{\\pi \\zeta}{\\sqrt{1-\\zeta^2}}}}{\\sqrt{1-\\zeta^2}} $$<br>超调量的意义在于：在没有积分项的情况下，超调量越大，系统的响应越快，但是超调量越大，系统的稳定性越差<br>其中 $\\zeta$ 是阻尼系数，$\\zeta$ 越大，超调量越小，系统越稳定</p>\n<h2 id=\"误差\"><a href=\"#误差\" class=\"headerlink\" title=\"误差\"></a>误差</h2><p>低频抖动：积分项过大<br>高频抖动：微分项过大</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>状态量：超声波，速度，MPU6050姿态，</p>\n<h1 id=\"卡尔曼滤波\"><a href=\"#卡尔曼滤波\" class=\"headerlink\" title=\"卡尔曼滤波\"></a>卡尔曼滤波</h1><h2 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>利用间接测量值，计算最优估算，组合各种可能受到噪音影响的数据源。</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"状态观察\"><a href=\"#状态观察\" class=\"headerlink\" title=\"状态观察\"></a>状态观察</h3><p>状态观察是指，通过测量值，计算出状态量的过程，<br>状态观测器得到的估计状态表示为$ \\hat{x}  $</p>\n<h3 id=\"状态预测\"><a href=\"#状态预测\" class=\"headerlink\" title=\"状态预测\"></a>状态预测</h3><p>根据数学模型，从已有的状态量，通过计算得到了一个估计量$ \\hat{x} $<br>然而，数学模型的预测有其局限性，初值条件不同所以不能得到相同的结果。<br>所以需要状态估算器</p>\n<h3 id=\"状态估算\"><a href=\"#状态估算\" class=\"headerlink\" title=\"状态估算\"></a>状态估算</h3><p>需要估算值收敛到实际值，所以需要反馈，反馈误差为e<br>$$ e &#x3D; x - \\hat{x} $$假设一个微分方程：<br>$$ \\dot{x} &#x3D; Ax + Bu $$$$ y &#x3D; Cx $$以上是一个真实系统<br>$$ \\dot{\\hat{x}} &#x3D; A\\hat{x} + Bu + Ke$$$$ \\hat{y} &#x3D; C\\hat{x} $$这是系统估算模型</p>\n<p>两方程分别相减得到：<br>$$ \\dot{e} &#x3D;(A- KC)·e$$$$ y-\\hat{y} &#x3D; C·e$$<br>解得:<br>$$e(t) &#x3D; e^{A-KC} ·e(0)$$<br>若A-KC的值小于0，那么e(t)会收敛到0，即估算值收敛到实际值，实际上，k可以加速收敛过程。</p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>$$ \\dot{x} &#x3D; Ax + Bu + w$$$$ y &#x3D; Cx + v$$<br>w是过程噪声，v是测量噪声，他们都服从高斯分布，且互相独立。<br>在初始条件下，状态估算器估计了$\\hat{x}$，真实值在这个中心的正态分布周围<br>在多轮预测后，估计值的分布会比初始条件下的估计分布更大，同时，还有一个测量方程得到的均值与方差都不同的分布，这两个分布的相乘就得到优化估计。<br>事实上，卡尔曼滤波器方程是一个随机系统的状态观测器<br>公式如下：<br>$$ \\hat{x}<em>k&#x3D;A·\\hat{x}</em>{k-1} +B·u_k +K_k(y_k - C(A·\\hat{x}+B·u_k)) $$<br>其中$\\hat{x_k^-}$是前项估测，代表前两项的和，所以公式写为：<br>$$ \\hat{x}_k^ &#x3D; A·\\hat{x_k^-} ++K_k(y_k - C\\hat{x_k^-}) $$</p>\n<p>所以结果成为后验估值。</p>\n<p>误差协方差矩阵P<br>$$ P_k^- &#x3D; AP_{k-1}A^T +Q$$<br>这个就是对矩阵P的估值</p>\n<p>第二步，更新状态<br>$$ K_k &#x3D; \\frac{P_k^-C^T}{(CP_k^-C^T+R)} $$<br>这个是卡尔曼增益，使得更新K后误差协方差最小<br>$$ P_k &#x3D; (I-K_kC)P_k^- $$</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/18/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-18/",
            "url": "http://example.com/2023/07/18/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-18/",
            "title": "电赛培训-23-07-18",
            "date_published": "2023-07-18T02:44:15.000Z",
            "content_html": "<h1 id=\"arduino小车测速\"><a href=\"#arduino小车测速\" class=\"headerlink\" title=\"arduino小车测速\"></a>arduino小车测速</h1><h2 id=\"霍尔编码器\"><a href=\"#霍尔编码器\" class=\"headerlink\" title=\"霍尔编码器\"></a>霍尔编码器</h2><h2 id=\"外部中断\"><a href=\"#外部中断\" class=\"headerlink\" title=\"外部中断\"></a>外部中断</h2><p>一个霍尔编码器如果有两个传感器传出两路信号，就能根据相位差同时测量速度和方向<br>但是arduino只有两个硬件中断管脚，同时还要使能计时器中断，所以需要一个外部中断库<br>PinChangeInterrupt库</p>\n<h2 id=\"定时中断\"><a href=\"#定时中断\" class=\"headerlink\" title=\"定时中断\"></a>定时中断</h2><p>atmel内部有三个定时器</p>\n<ul>\n<li>Timer0是delay用的</li>\n<li>Timer1是pwm用的</li>\n<li>只有Timer2可以使用来进行定时中断<br>因此，需要使用MsTimer2库来实现定时中断</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/14/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-14/",
            "url": "http://example.com/2023/07/14/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-14/",
            "title": "电赛培训-23-07-14",
            "date_published": "2023-07-14T01:30:14.000Z",
            "content_html": "<h1 id=\"PWM\"><a href=\"#PWM\" class=\"headerlink\" title=\"PWM\"></a>PWM</h1><h2 id=\"通用定时器\"><a href=\"#通用定时器\" class=\"headerlink\" title=\"通用定时器\"></a>通用定时器</h2><h3 id=\"预分频\"><a href=\"#预分频\" class=\"headerlink\" title=\"预分频\"></a>预分频</h3><p>通过对时钟频率进行分频，实现了让计数器可以计数更长的时间。</p>\n<h2 id=\"占空比\"><a href=\"#占空比\" class=\"headerlink\" title=\"占空比\"></a>占空比</h2><p>占空比的实现是通过调节计数器到达翻转电平的值的大小来实现的。<br>利用的是计数器的比较功能<br>通过调节一个计数器不同的值，可以同时实现多个pwm的多个占空比的调节。但是他们的频率是相同的，若想要不同频率需要使用不同的计时器。<br>TIM3&#x2F;4通道数较多</p>\n<h2 id=\"捕获模式\"><a href=\"#捕获模式\" class=\"headerlink\" title=\"捕获模式\"></a>捕获模式</h2><p>捕获模式可以用来测量信号的频率，占空比等。</p>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><p>打开对应channel的pwm生成，设定预分频和counter值（推荐一个方便运算占空比的值）</p>\n<h2 id=\"作业\"><a href=\"#作业\" class=\"headerlink\" title=\"作业\"></a>作业</h2><ul>\n<li>需要实现通过按键增加占空比</li>\n<li>用捕获模式测量发生的PWM波频率和占空比</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/13/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-13/",
            "url": "http://example.com/2023/07/13/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-13/",
            "title": "电赛培训-23-07-13",
            "date_published": "2023-07-13T01:57:16.000Z",
            "content_html": "<h1 id=\"stm32串口通信\"><a href=\"#stm32串口通信\" class=\"headerlink\" title=\"stm32串口通信\"></a>stm32串口通信</h1><h1 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h1><h2 id=\"通用定时器\"><a href=\"#通用定时器\" class=\"headerlink\" title=\"通用定时器\"></a>通用定时器</h2><p>采用apb1&#x2F;apb2总线</p>\n<h3 id=\"预分频\"><a href=\"#预分频\" class=\"headerlink\" title=\"预分频\"></a>预分频</h3><p>计时时长&#x3D; (预分频+1) * (计数器值+1) &#x2F; 时钟频率</p>\n<h3 id=\"中断回调\"><a href=\"#中断回调\" class=\"headerlink\" title=\"中断回调\"></a>中断回调</h3><p>HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)<br>这个函数可以复制到it文件中，定义这个函数即可在中断中调用这个函数。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/12/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-12/",
            "url": "http://example.com/2023/07/12/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-12/",
            "title": "电赛培训-23-07-12",
            "date_published": "2023-07-12T01:51:29.000Z",
            "content_html": "<h1 id=\"stm32定时器\"><a href=\"#stm32定时器\" class=\"headerlink\" title=\"stm32定时器\"></a>stm32定时器</h1><p>SysTick控制寄存器：<br>在SysTick_Config函数中，需要传进一个参数，代表着多少个tick触发一次中断。这个参数是一个32位的寄存器，但是只有24位有效，因此最大值是2^24-1，也就是16777215，也就是16Mhz的时钟下，最大延时是1s。如果需要更长的延时，需要自己写一个计数器，然后在中断中进行判断。<br>有一个变量是SystemCoreClock，代表当前时钟速度。把这个变量除以多少，就是把一秒分成多少份来计时。<br>在SysTick_Handler这个函数中，每次计时器触发中断都会调用这个函数，可以设置一个静态变量来进行计数，例如每1ms触发中断，就让这个函数每500次进入中断才执行某个行为，就能实现每500ms执行一次某个行为。</p>\n<h1 id=\"按键中断\"><a href=\"#按键中断\" class=\"headerlink\" title=\"按键中断\"></a>按键中断</h1>",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/11/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-11/",
            "url": "http://example.com/2023/07/11/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-11/",
            "title": "电赛培训-23-07-11",
            "date_published": "2023-07-11T01:49:47.000Z",
            "content_html": "<h1 id=\"stm32-开发\"><a href=\"#stm32-开发\" class=\"headerlink\" title=\"stm32 开发\"></a>stm32 开发</h1><h2 id=\"配置内容\"><a href=\"#配置内容\" class=\"headerlink\" title=\"配置内容\"></a>配置内容</h2><p>main.c中的user code 注释中间是不会被cube重新生成的</p>\n<h2 id=\"时钟树\"><a href=\"#时钟树\" class=\"headerlink\" title=\"时钟树\"></a>时钟树</h2><h2 id=\"第一个hal函数\"><a href=\"#第一个hal函数\" class=\"headerlink\" title=\"第一个hal函数\"></a>第一个hal函数</h2><p>HAL_GPIO_WritePin(GPIOF,LED0_PIN|LED1_PIN, GPIO_PIN_SET);<br>HAL_Delay(ms);</p>\n<h2 id=\"板载按钮\"><a href=\"#板载按钮\" class=\"headerlink\" title=\"板载按钮\"></a>板载按钮</h2><p>PE4作为ButtonPin，使能需要一个上拉电阻</p>\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p>可以在cube中更改引脚为外部中断，可以调节中断触发模式</p>\n<h1 id=\"stm32用于clion的诸多问题\"><a href=\"#stm32用于clion的诸多问题\" class=\"headerlink\" title=\"stm32用于clion的诸多问题\"></a>stm32用于clion的诸多问题</h1><ol>\n<li>Error: libusb_open() failed with LIBUSB_ERROR_NOT_SUPPORTED<br>初步估计是usb驱动问题，因此计划使用zadig重装驱动，libusb</li>\n<li>Error:Error: timed out while waiting for target halted<br>似乎是在等待重启的过程中超时，难道是没有设置重启？<br><strong>解决了，忘了换配置文件了，老配置文件没问题</strong></li>\n<li>问题又来了，Initfailed，连接不到target，先用的玄学方法：按住rst按键，再烧录，就用这种笨方法至少可以烧录了<br>作为重置方法，接下来有一个比较好的解决方案，就是再cubemx中，pinout设置栏，再systemcore的sys部分里，有一个debug模式选择，之前一直是disable，所以拒绝再外部烧写，现在改成serial wire，就可以了。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/10/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-10/",
            "url": "http://example.com/2023/07/10/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-10/",
            "title": "电赛培训-23-07-10",
            "date_published": "2023-07-10T01:40:59.000Z",
            "content_html": "<h1 id=\"spi与i2c\"><a href=\"#spi与i2c\" class=\"headerlink\" title=\"spi与i2c\"></a>spi与i2c</h1><h2 id=\"iic通信\"><a href=\"#iic通信\" class=\"headerlink\" title=\"iic通信\"></a>iic通信</h2><p>i2c是一种用于设备间通讯的两线协议<br>硬件和软件实现都通过machine.I2C和machine.SoftI2C来实现。<br>硬件I2c优势在于速度快，但是对使用的引脚有限制。<br>软件I2C优势在于兼容性强，但是速度慢<br>函数：</p>\n<ul>\n<li>硬件I2C：使用以下参数来构造I2C对象<ul>\n<li>id表示特定的外设，取决于特定板子</li>\n<li>scl：时钟线引脚，Pin</li>\n<li>sda：数据线引脚，Pin</li>\n<li>freq：时钟频率，整数</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意接线先关注缺少的端口例如I2C或uart，之后再关注gpio</strong></p>\n<ul>\n<li>软件I2C：使用以下参数来构造I2C对象<ul>\n<li>scl：时钟线引脚，Pin</li>\n<li>sda：数据线引脚，Pin</li>\n<li>freq：时钟频率，整数</li>\n<li>timeout：超时时间，整数</li>\n</ul>\n</li>\n<li>init函数可以重新定义</li>\n<li>I2C.start()：开始通信</li>\n<li>I2C.stop()：结束通信</li>\n<li>I2C.readint(buf,nack&#x3D;True):读取字节存储到buf中，字节长度是buf长度，收到出最后一个字节以外所有子接后，将发送ack，如果设置nack则发送nack，ack代表着以后还会传输，nack代表着这是最后一个字节</li>\n<li>I2C.write(buf)：将buf中的字节写入到总线上，检查每个字节是否收到ack</li>\n<li>I2C.readfrom(addr,nbytes,stop&#x3D;True):从addr地址读取nbytes个字节，如果stop为True则在输入结束时发送stop信号。</li>\n<li>I2c.readfrom_into(adr,)</li>\n<li>I2c.writeto(addr,buf,stop&#x3D;True)</li>\n<li>I2c.writevto(addr,vector,stop&#x3D;True)将vector中包含的字节写入addr指定的从站，vector应该具有缓冲协议的元组或对象列表</li>\n<li>I2c.readfrom_mem(addr,memaddr,nbytes,addrsize&#x3D;8)从memaddr指定的内存地址开始，从addr指定的从站读出nbytes。参数addrsize以位为单位指定地址大小，返回读取数据bytes对象。</li>\n<li><h3 id=\"硬件I3c外设\"><a href=\"#硬件I3c外设\" class=\"headerlink\" title=\"硬件I3c外设\"></a>硬件I3c外设</h3>任何可用的输出引脚都可以用于scl和sda，默认情况下，I2C对象使用id 0，scl引脚为22，sda引脚为21，时钟频率为400kHz。</li>\n</ul>\n<h2 id=\"spi通信\"><a href=\"#spi通信\" class=\"headerlink\" title=\"spi通信\"></a>spi通信</h2><p>spi是一种由主机驱动的同步串行协议。在物理层概念，一条总线有三条线路组成：SCK，MOSI、MISO，多个设备可以共享一条总线。每个设备有一个单独的第四个信号SS（从设备选择），来选择总线上的特定设备并与之通信。</p>\n<figure class=\"highlight gml\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs gml\">machine.SPI(<span class=\"hljs-symbol\">id</span>)# 在给定的总线<span class=\"hljs-symbol\">id</span>上构造一个SPI对象。<span class=\"hljs-symbol\">id</span>的值取决于特定端口以及硬件<br></code></pre></td></tr></table></figure>\n<h1 id=\"stm32\"><a href=\"#stm32\" class=\"headerlink\" title=\"stm32\"></a>stm32</h1><h2 id=\"引脚\"><a href=\"#引脚\" class=\"headerlink\" title=\"引脚\"></a>引脚</h2><p>在cubemx中，浅黄色是不能修改定义的，深黄色也是默认的。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>引脚配置，在pinout_configuration中，如下图所示：<br><img src=\"/2023/07/10/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-10/GPIO_conf.png\" alt=\"引脚配置\"><br>可以配置其中每个引脚的功能，例如GPIO、SPI、I2C等等。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/07/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-07/",
            "url": "http://example.com/2023/07/07/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-07/",
            "title": "电赛培训-23-07-07",
            "date_published": "2023-07-07T01:34:49.000Z",
            "content_html": "<h1 id=\"串口通信\"><a href=\"#串口通信\" class=\"headerlink\" title=\"串口通信\"></a>串口通信</h1><h2 id=\"串行vs并行\"><a href=\"#串行vs并行\" class=\"headerlink\" title=\"串行vs并行\"></a>串行vs并行</h2><p>并行优点：快，效率高<br>缺点：需要端口多<br>串行优点：只需要一个端口<br>缺点：慢，效率低，且需要明确数据拍成一串的规则<br>（大端法vs小端法）</p>\n<h2 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h2><p>串行通信每次只发送一个字节，对于字节内部发送bit的顺序，每个通讯协议都是相同的，但是字节的顺序却不一定相同，这就是大端法和小端法的区别。</p>\n<h3 id=\"I2C通信\"><a href=\"#I2C通信\" class=\"headerlink\" title=\"I2C通信\"></a>I2C通信</h3><p>一个通信口可以和多个设备进行传输，只需要SDA和SCL两个数据线即可，SDA为数据线，SCL为时钟线，时钟线由主设备控制，主设备为发送方，从设备为接收方，从设备的地址由主设备指定，主设备发送数据时，从设备会返回一个ACK信号，表示接收成功，如果没有返回ACK信号，主设备会认为发送失败，重新发送。<br>但是，I2C驱动能力较弱，需要在数据线加上拉电阻，且所有设备必须有不同地址。</p>\n<h3 id=\"SPI通信\"><a href=\"#SPI通信\" class=\"headerlink\" title=\"SPI通信\"></a>SPI通信</h3><p>不需要考虑地址为问题，可以一个Master带多个slave。<br>缺点：每多一个从机，就需要有一个IO口作为片选信号，且需要一个时钟信号，所以需要的IO口较多。</p>\n<h3 id=\"UART通信\"><a href=\"#UART通信\" class=\"headerlink\" title=\"UART通信\"></a>UART通信</h3><p>接线非常简单，且双方对等，谁都可以随时发送信息。<br>缺点：容易接错，且难实现多个设备同时通信。而且功耗较大，所以很多传感器上不配备。<br>波特率：每个位对应时间长度的倒数<br>uart通信有起始位，数据位，校验位，停止位，所以每个字节需要10个bit，所以波特率为115200时，每秒可以传输11520个字节。</p>\n<h4 id=\"电平标准\"><a href=\"#电平标准\" class=\"headerlink\" title=\"电平标准\"></a>电平标准</h4><p>usb标准：看D+和D-的电平差，差大是1，小是0<br>TTL电平：0v是低电平，5&#x2F;3.3v是高电平<br>RS232电平：-3v<del>-15v是低电平，3v</del>15v是高电平</p>\n<h4 id=\"Arduino的uart\"><a href=\"#Arduino的uart\" class=\"headerlink\" title=\"Arduino的uart\"></a>Arduino的uart</h4><p>ttl电平5v<br>1为tx<br>0为rx<br>内部已通过ch340g串口转usb，与usb相连，arduino用uart串口发送信息时，会通过ch340g转换为usb信号，所以可以通过usb接收信息。<br>函数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs reasonml\"><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span><span class=\"hljs-keyword\">begin</span>(baudrate)：设置波特率<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serianl</span>.</span></span>print(content,选项)：发送信息,可以是数字，字符串，数组，对象，选项可以是DEC，BIN，OCT，HEX，BYTE，WORD，FLOAT，STRING，可以指定发送的进制，或者发送字符串。<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>println(content,选项)：发送信息，与print不同的是，会在最后加上换行符。<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>available<span class=\"hljs-literal\">()</span>：返回接收缓冲区中的字节数<br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>read<span class=\"hljs-constructor\">Bytes(<span class=\"hljs-params\">char</span>类型数组名，最大读取长度)</span><br><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Serial</span>.</span></span>write(<span class=\"hljs-built_in\">char</span>类型数组名，写入长度)：总共能发送数据长度个字节。按照数组中每个原始值诸葛发送，可以借助这个功能，对<span class=\"hljs-keyword\">struct</span>结构体中相关数据作为一个整体，将结构体指针强制转型为byte*类型，后面数据长度用sizeof(<span class=\"hljs-keyword\">struct</span>),这样就可以将结构体作为一个整体发送。<br></code></pre></td></tr></table></figure>\n<h4 id=\"Arduino的uart工具\"><a href=\"#Arduino的uart工具\" class=\"headerlink\" title=\"Arduino的uart工具\"></a>Arduino的uart工具</h4><ul>\n<li>串口绘图仪：可以发送数据时利用数据名：数据的格式，将以时间为横轴，数值为纵轴，根据格式中构成的变量数量，以不同颜色的线段，随时间变化的情况进行绘图。</li>\n<li>BYSerial<br>串口不能同时被多个程序打开。<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2>基本概念：</li>\n<li>TCP&#x2F;IP协议：定义了设备如何连接如互联网</li>\n<li>TCP：信息必须齐全的网络通信的基础</li>\n<li>UDP：信息可以缺少或者需要广播的网络通信的基础</li>\n<li>IP：计算机之间用于识别身份的临时位置编号</li>\n<li>ICMP：网络控制信号协议</li>\n<li>DHCP：动态分配ip地址协议</li>\n<li>一个能连接互联网的网课出厂自带的编号。<h3 id=\"ipv4\"><a href=\"#ipv4\" class=\"headerlink\" title=\"ipv4\"></a>ipv4</h3>ipv4定义了32位二进制地址<br>同时，ipv4定义了一些只会用于内部网络的地址编号，称为私网ip段，剩下的都是用于全球公网ip。<br>例如</li>\n</ul>\n<p>10.0.0.0-10.255.255.255<br>172.16.0.0-172.31.255.255<br>192.168.0.0-192.168.255.255</p>\n<h3 id=\"ipv6\"><a href=\"#ipv6\" class=\"headerlink\" title=\"ipv6\"></a>ipv6</h3><p>ipv6定义了128位二进制地址</p>\n<h3 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h3><p>子网掩码用于判断ip地址的前几位是网络号，后几位是主机号。<br>32个二进制位表示ip地址截止到哪里，只要相同就认为在同一个子网内，可以直接通信无需交给网关做转发。要求必须1卡头，连续多个1，剩下的是0。255.255.255.0对于这个设备，前面三个点分十进制数相同，那就认为是在同一个网络下，因此会直接连接而不会寻求网关。</p>\n<h3 id=\"tcp协议\"><a href=\"#tcp协议\" class=\"headerlink\" title=\"tcp协议\"></a>tcp协议</h3><p>传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议，一个tcp连接需要有：</p>\n<ol>\n<li>在一个网络色悲伤，特定的网络端口如8080（最好大于1023）上开创一个tcp server，这个过程叫做绑定端口，并开始监听端口。</li>\n<li>得到该网络设备的ip地址，因此需要体现获得server的ipv4地址，以及开启tcp监听端口。<h3 id=\"udp协议\"><a href=\"#udp协议\" class=\"headerlink\" title=\"udp协议\"></a>udp协议</h3>无连接的传输协议，成为用户数据报协议<br>udp提供了一个无需链接就能发送封装的ip数据包的方法，建立一套tcp连接需要有：</li>\n<li>在一个网络设备上，特定的网络端口如8080（最好大于1023）上开创一个udp socket</li>\n<li>设定好目的地IP地址和端口便可以随心所欲发送数据</li>\n<li>目的地ip地址对应网络设备B，如果尝试在自己9090端口上开创一个udp socket，且A正好在发送信息，那么此时就能受到A发送的信息。</li>\n</ol>\n<h2 id=\"wifi连接\"><a href=\"#wifi连接\" class=\"headerlink\" title=\"wifi连接\"></a>wifi连接</h2><h3 id=\"station终端\"><a href=\"#station终端\" class=\"headerlink\" title=\"station终端\"></a>station终端</h3><p>新建station</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">import</span> network<br>wlan - network.WLAN(network.STA.<span class=\"hljs-keyword\">IF</span>)# <span class=\"hljs-keyword\">create</span> station<br>wlan.active(<span class=\"hljs-keyword\">True</span>)<br>wlan.scan() #scan <span class=\"hljs-keyword\">for</span> acess points(AP)<br>wlan.isconnected() #<span class=\"hljs-keyword\">check</span> <span class=\"hljs-keyword\">if</span> the station <span class=\"hljs-keyword\">is</span> connected <span class=\"hljs-keyword\">to</span> an AP<br><br>wlan.<span class=\"hljs-keyword\">connect</span>(<span class=\"hljs-string\">&#x27;ssid&#x27;</span>, <span class=\"hljs-string\">&#x27;key&#x27;</span>) #<span class=\"hljs-keyword\">connect</span> <span class=\"hljs-keyword\">to</span> an AP<br>wlan.config(<span class=\"hljs-string\">&#x27;mac&#x27;</span>) #<span class=\"hljs-keyword\">get</span> the interfac<span class=\"hljs-string\">e&#x27;s MAC address</span><br><span class=\"hljs-string\">wlan.ifconfig() #get the interface&#x27;</span>s IP/netmask/gw/DNS addresses<br></code></pre></td></tr></table></figure>\n<p>新建AP</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">import</span> network<br>ap = network.WLAN(network.AP_IF) # <span class=\"hljs-keyword\">create</span> acess <span class=\"hljs-type\">point</span> interface<br>ap.config(ssid=<span class=\"hljs-string\">&#x27;ESP-AP&#x27;</span>) #<span class=\"hljs-keyword\">set</span> the SSID <span class=\"hljs-keyword\">of</span> the <span class=\"hljs-keyword\">access</span> <span class=\"hljs-type\">point</span><br>ap.config(max_clients=<span class=\"hljs-number\">10</span>) #<span class=\"hljs-keyword\">set</span> how many clients can <span class=\"hljs-keyword\">connect</span> <span class=\"hljs-keyword\">to</span> the <span class=\"hljs-keyword\">access</span> <span class=\"hljs-type\">point</span><br>ap.active(<span class=\"hljs-keyword\">True</span>)<br></code></pre></td></tr></table></figure>\n<p>tcp通讯：</p>\n<ol>\n<li>连接wifi</li>\n<li>获取本地ip</li>\n<li>创建tcp</li>\n<li>绑定本地ip和端口</li>\n<li>设定最大连接数</li>\n<li>配置tcp选项</li>\n<li>用户进入获取用户组</li>\n<li>读取用户信息，</li>\n<li>发送接收到的数据给发送者</li>\n</ol>\n<p>udp通讯：server</p>\n<ol>\n<li>创建socket对象要设置udp模式</li>\n</ol>\n<p>udp通信：client</p>\n<ol>\n<li>判断wifi连接</li>\n<li>发送使用sendto函数</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/06/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-06/",
            "url": "http://example.com/2023/07/06/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-06/",
            "title": "电赛培训-23-07-06",
            "date_published": "2023-07-06T01:48:40.000Z",
            "content_html": "<h1 id=\"ESP32\"><a href=\"#ESP32\" class=\"headerlink\" title=\"ESP32\"></a>ESP32</h1><h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p>中断处理程序不要运行时间过长，不要分配内存</p>\n<h3 id=\"紧急异常缓冲区\"><a href=\"#紧急异常缓冲区\" class=\"headerlink\" title=\"紧急异常缓冲区\"></a>紧急异常缓冲区</h3><p>如果ISR中发生错误，MicroPython无法生成错误报告<br>除非创建特殊缓冲区</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-keyword\">import</span> micropython<br><span class=\"hljs-title\">micropython</span>.alloc_emergency_exception_buf(<span class=\"hljs-number\">100</span>)<br></code></pre></td></tr></table></figure>\n<h2 id=\"UART\"><a href=\"#UART\" class=\"headerlink\" title=\"UART\"></a>UART</h2><p>esp32有三个硬件UART，分别是UART0，UART1，UART2<br>各自分配了默认GPIO<br>TX：当前设备的发送<br>RX：当前设备的接收<br>串口中不分主从</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">from</span> machine import UART<br><span class=\"hljs-attribute\">uart1</span> = (<span class=\"hljs-number\">1</span>,baudrate=<span class=\"hljs-number\">9600</span>,tx=<span class=\"hljs-number\">33</span>,rx=<span class=\"hljs-number\">32</span>)#指定了id<br><br></code></pre></td></tr></table></figure>\n<p>任何GPIO都可以用于使用GPIO矩阵的硬件UART，除了可以用作rx的仅输入引脚34-39<br>发送与接受的波特率一样</p>\n<p>一种调试方法：不能使用调试器时，可以利用串口输出进行调试。</p>\n<h2 id=\"ADC\"><a href=\"#ADC\" class=\"headerlink\" title=\"ADC\"></a>ADC</h2><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">from machine import ADC<br>adc = <span class=\"hljs-constructor\">ADC(<span class=\"hljs-params\">pin</span>)</span><br><span class=\"hljs-keyword\">val</span> = adc.read<span class=\"hljs-constructor\">_u16()</span><br><span class=\"hljs-keyword\">val</span> = adc.read<span class=\"hljs-constructor\">_uv()</span># <span class=\"hljs-keyword\">to</span> microvolts<br></code></pre></td></tr></table></figure>\n<p><strong>ADC2也被wifi使用，所以开启wifi时会发生adc2异常</strong></p>\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><p>Timer.init(*,mode&#x3D;Timer.PERIODIC,period&#x3D;-1,callback&#x3D;None)</p>\n<ul>\n<li>mode 可以是ONE_SHOT或PERIODIC（单次或周期计时）</li>\n</ul>\n<h2 id=\"PWM\"><a href=\"#PWM\" class=\"headerlink\" title=\"PWM\"></a>PWM</h2>",
            "tags": []
        },
        {
            "id": "http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/",
            "url": "http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/",
            "title": "电赛培训-23-07-05",
            "date_published": "2023-07-05T01:46:48.000Z",
            "content_html": "<h1 id=\"Arduino\"><a href=\"#Arduino\" class=\"headerlink\" title=\"Arduino\"></a>Arduino</h1><p>软件：使用Arduino IDE，以C++风格语言编写相关库。<br>利用IDE编译固件下载到Arduino的前提条件是有bootloader程序。<br>所以从程序到固件的关键在于bootloader，其他单片机也可以装载bootloader固件，然后使用arduino库。</p>\n<h2 id=\"硬件-uno板\"><a href=\"#硬件-uno板\" class=\"headerlink\" title=\"硬件 uno板\"></a>硬件 uno板</h2><p>工作电压5v,可以typeB，DC5.5，或者跳线接入<br>共有14个数字输入输出（6个PWM口），6个模拟输入输出</p>\n<h2 id=\"系统指示灯\"><a href=\"#系统指示灯\" class=\"headerlink\" title=\"系统指示灯\"></a>系统指示灯</h2><ul>\n<li>ON：系统指示灯</li>\n<li>RX：接收指示灯</li>\n<li>TX：发送指示灯</li>\n<li>L：内置LED，对应13号数字口<h2 id=\"开始编写代码\"><a href=\"#开始编写代码\" class=\"headerlink\" title=\"开始编写代码\"></a>开始编写代码</h2>有两个一定会有的函数，void setup()和void loop()，分别是初始化和循环函数。<br>setup会执行一次，loop在setup后会自动循环<h3 id=\"setup函数\"><a href=\"#setup函数\" class=\"headerlink\" title=\"setup函数\"></a>setup函数</h3>setup中用pinMode配置管脚模式为输出<br>pinMode(pin编号，INPUT)：高阻态，可认为是100m欧姆，电平不定。<br>pinMode(pinnum,INPUT_PULLUP):内置上拉输入，无外部信号默认高电平。<br>pinMode(pinnum,OUTPUT):输出模式，uno上高电平5v，电流&lt;40mA</li>\n</ul>\n<h3 id=\"loop函数\"><a href=\"#loop函数\" class=\"headerlink\" title=\"loop函数\"></a>loop函数</h3><ul>\n<li>digitalWrite(pinnum,HIGH&#x2F;LOW):输出高低电平，只对output模式有效</li>\n<li>digitalRead(pinnum):读取高低电平,返回HIGH&#x2F;LOW两种电平</li>\n<li>analogRead(anaPinNum)：读取模拟输入电平，返回0-1023的数字，对应0-5v的电压</li>\n<li>analogWrite(pwmPinNum,0-255)：输出PWM波，对应0-5v的电压，频率为490Hz(3,9,10,11pin),或980Hz(5,6pin)</li>\n<li>analogReference(AD参考电压输入来源)：切换AD参考电压输入来源，有默认值，一般不用，可以让输出更加精细。</li>\n</ul>\n<h3 id=\"中断和轮询\"><a href=\"#中断和轮询\" class=\"headerlink\" title=\"中断和轮询\"></a>中断和轮询</h3><p>轮询：不断重复读取某个状态值，缺点是占用资源<br>中断：可以通过某个状态改变来发送信号，然后发送信号后可以执行其他操作，之后再恢复到发送信号之前的状态。<br>管脚中断：attachInterrupt(digitalPinToInterrupt(pinnum),ISR,mode),第一个参数是中断管脚号（uno为2，3），第二个参数是中断服务函数（可以自定义），第三个参数是中断模式，有LOW，RISING，FALLING，CHANGE四种模式。</p>\n<ul>\n<li>LOW：低电平触发</li>\n<li>RISING：上升沿触发</li>\n<li>FALLING：下降沿触发</li>\n<li>CHANGE：任意电平变化触发</li>\n</ul>\n<p><strong>注意，终端服务函数应当很短，而且不能使用其他中断实现的函数，延时需要delayMicroseconds(us)</strong><br><strong>修改全局变量应当用volatile修饰，防止编译器优化</strong></p>\n<h1 id=\"ESP32\"><a href=\"#ESP32\" class=\"headerlink\" title=\"ESP32\"></a>ESP32</h1><h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>esp32-WROOM-32<br>串口芯片：CP2102<br>核心频率240mHz<br>WiFi IEEE 802.11 b&#x2F;g&#x2F;n 2.4GHz<br>BLuetooth 4.2 BR&#x2F;EDR and BLE<br>520k SRAM 448kB ROM<br>2个I2S，RMT远程控制，LED PWM，1个host SD&#x2F;eMMC&#x2F;SDIO，一个slave SDIO&#x2F;SPI. TWAI(CAN),12bitADC,Ethernet</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>MicroPython+Thonny</p>\n<h3 id=\"常用库\"><a href=\"#常用库\" class=\"headerlink\" title=\"常用库\"></a>常用库</h3><h3 id=\"GPIO\"><a href=\"#GPIO\" class=\"headerlink\" title=\"GPIO\"></a>GPIO</h3><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><div class=\"code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">from</span> machine <span class=\"hljs-keyword\">import</span> Pin<br><br>p0 = Pin(<span class=\"hljs-number\">0</span>,Pin.<span class=\"hljs-keyword\">OUT</span>) # <span class=\"hljs-keyword\">create</span> output pin <span class=\"hljs-keyword\">on</span> GPIO0<br>p0.<span class=\"hljs-keyword\">on</span>() # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> &quot;on&quot; (high) <span class=\"hljs-keyword\">level</span><br>p0.<span class=\"hljs-keyword\">off</span>() # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> &quot;off&quot; (low) <span class=\"hljs-keyword\">level</span><br>p0.<span class=\"hljs-keyword\">value</span>(<span class=\"hljs-number\">1</span>) # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">on</span>/high<br>p0.init(p0.<span class=\"hljs-keyword\">IN</span>,p0.PULL_DOWN) # <span class=\"hljs-keyword\">set</span> pin <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">input</span> <span class=\"hljs-keyword\">with</span> a pull-down resistor<br></code></pre></td></tr></table></figure>\n<p>init函数中，id是强制的</p>\n<ul>\n<li><p>mode指定引脚模式，有IN，OUT，OPEN_DRAIN，AF_OPEN_DRAIN四种模式</p>\n</li>\n<li><p>pull指定引脚是否连接弱上拉电阻，有None，PULL_UP，PULL_DOWN三种模式<br>弱上拉指上拉电阻阻值较大，高电平很容易因为外部电流驱动而拉低。</p>\n</li>\n<li><p>drive具有不同的最大安全电流的限制，有DRIVE_0-3四种选择</p>\n</li>\n<li><p>alt为引脚的备用功能，仅对alt和alt_open_drain两种模式有效，有0-7八种选择</p>\n</li>\n</ul>\n<p>value函数中，如果不带参数，就是得到当前状态，如果在输出模式，需要带参数，变为设置电平</p>\n<p>配置在引脚的触发源处于活动状态时要调用中断处理程序，如果引脚模式为Pin.IN，可以使用irq函数，如果引脚模式为Pin.IN，可以使用Pin.IRQ_RISING，Pin.IRQ_FALLING，Pin.IRQ_ANY三种模式，分别对应上升沿，下降沿，任意电平变化触发中断。</p>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",
            "url": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/",
            "title": "电赛学习笔记-机器视觉",
            "date_published": "2023-05-14T09:04:31.000Z",
            "content_html": "<h1 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h1><h2 id=\"安装opencv\"><a href=\"#安装opencv\" class=\"headerlink\" title=\"安装opencv\"></a>安装opencv</h2><h2 id=\"开发板：STM32F407\"><a href=\"#开发板：STM32F407\" class=\"headerlink\" title=\"开发板：STM32F407\"></a>开发板：STM32F407</h2><h2 id=\"IDE：STM32CubeIDE\"><a href=\"#IDE：STM32CubeIDE\" class=\"headerlink\" title=\"IDE：STM32CubeIDE\"></a>IDE：STM32CubeIDE</h2><h2 id=\"配置过程\"><a href=\"#配置过程\" class=\"headerlink\" title=\"配置过程\"></a>配置过程</h2><p>配置工程ioc文件，配置好基础外设后，再packs中安装X-CUBE-AI组件包，在软件包外设中添加模型文件，设置压缩倍数，导入测试集验证准确率</p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><h3 id=\"yolo\"><a href=\"#yolo\" class=\"headerlink\" title=\"yolo\"></a>yolo</h3><p>利用mobilenet yolo50k模型可以导入到单片机中，只需要较少内存即可实现实时运行，实现人脸识别的功能</p>\n<h3 id=\"openmv\"><a href=\"#openmv\" class=\"headerlink\" title=\"openmv\"></a>openmv</h3><h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>正点原子ov7725摄像头<br>yolo50k</p>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><p><a href=\"https://www.bilibili.com/video/BV1Bt411w77m/?share_source=copy_web&vd_source=4ed5c2c0429d7681216f506ac1e74065\">稚晖君</a><br><a href=\"https://github.com/dog-qiuqiu/MobileNet-Yolo\">yolo50k仓库</a><br><a href=\"https://www.bilibili.com/video/BV1FL411u72p/?share_source=copy_web&vd_source=4ed5c2c0429d7681216f506ac1e74065\">实时运行案例</a></p>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/",
            "url": "http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/",
            "title": "电赛学习笔记-micropython",
            "date_published": "2023-05-14T08:47:54.000Z",
            "content_html": "<h1 id=\"micropython简介\"><a href=\"#micropython简介\" class=\"headerlink\" title=\"micropython简介\"></a>micropython简介</h1><p>micropython是一个能够利用python进行单片机开发的固件，目前主要是在esp32平台上进行的开发</p>\n<h1 id=\"micropython安装\"><a href=\"#micropython安装\" class=\"headerlink\" title=\"micropython安装\"></a>micropython安装</h1><ul>\n<li>在micropython官网找到对应的单片机的型号的固件文件（.bin），下载到对应位置</li>\n<li>pip install esptool</li>\n<li>连接esp32单片机，查看端口号</li>\n<li>根据micropython官网的指示，利用esptool.py文件，清除单片机flash，再部署固件到单片机。</li>\n<li>安装uPyCraft IDE，选择好开发板类型和端口号后，<h1 id=\"micropython使用\"><a href=\"#micropython使用\" class=\"headerlink\" title=\"micropython使用\"></a>micropython使用</h1>需要根据单片机自带的库函数，进行python文档的开发<h1 id=\"micropython的优点\"><a href=\"#micropython的优点\" class=\"headerlink\" title=\"micropython的优点\"></a>micropython的优点</h1>代码量少，配置简单</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        },
        {
            "id": "http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/",
            "url": "http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/",
            "title": "电赛学习笔记（1）——stm32学习笔记",
            "date_published": "2023-05-11T08:19:20.000Z",
            "content_html": "<h1 id=\"stm32基础\"><a href=\"#stm32基础\" class=\"headerlink\" title=\"stm32基础\"></a>stm32基础</h1><h2 id=\"关于stm32产品线\"><a href=\"#关于stm32产品线\" class=\"headerlink\" title=\"关于stm32产品线\"></a>关于stm32产品线</h2><h3 id=\"stm32f1系列-cortex-m3\"><a href=\"#stm32f1系列-cortex-m3\" class=\"headerlink\" title=\"stm32f1系列 cortex-m3\"></a>stm32f1系列 cortex-m3</h3><h3 id=\"stm32f4系列-cortex-m4\"><a href=\"#stm32f4系列-cortex-m4\" class=\"headerlink\" title=\"stm32f4系列 cortex-m4\"></a>stm32f4系列 cortex-m4</h3><ul>\n<li>内置了rgb lcd驱动</li>\n<li>加入了DSP与FPU模块<h3 id=\"stm32f7系列-cortex-m7\"><a href=\"#stm32f7系列-cortex-m7\" class=\"headerlink\" title=\"stm32f7系列 cortex-m7\"></a>stm32f7系列 cortex-m7</h3></li>\n<li>高速内存得到应用 <h2 id=\"寄存器编程\"><a href=\"#寄存器编程\" class=\"headerlink\" title=\"寄存器编程\"></a>寄存器编程</h2></li>\n</ul>\n<p><strong>关键字volatile</strong>需要在声明寄存器变量的时候添加，因为要防止编译器自行优化。</p>\n<h2 id=\"HAL库\"><a href=\"#HAL库\" class=\"headerlink\" title=\"HAL库\"></a>HAL库</h2><p>硬件抽象层，可以将不同产品线的芯片的寄存器操作抽象为函数，方便移植<br><strong><font color=\"red\">本笔记使用HAL库进行编程</font></strong><br>相对的，HAL库会产生大量的判断来降低代码运行效率<br>但是，还有另一个Low Layer库（LL），这个库可以提高效率</p>\n<h2 id=\"stm32cubeMX配置\"><a href=\"#stm32cubeMX配置\" class=\"headerlink\" title=\"stm32cubeMX配置\"></a>stm32cubeMX配置</h2><h2 id=\"stm32计时器\"><a href=\"#stm32计时器\" class=\"headerlink\" title=\"stm32计时器\"></a>stm32计时器</h2><h3 id=\"PWM调制输出\"><a href=\"#PWM调制输出\" class=\"headerlink\" title=\"PWM调制输出\"></a>PWM调制输出</h3><h4 id=\"几个重要参数\"><a href=\"#几个重要参数\" class=\"headerlink\" title=\"几个重要参数\"></a>几个重要参数</h4><ul>\n<li>占空比：高电平占整个周期的比例</li>\n<li>频率：整个PWM周期的倒数</li>\n<li>分辨率：占空比变化步长 <h4 id=\"PWM实现方法\"><a href=\"#PWM实现方法\" class=\"headerlink\" title=\"PWM实现方法\"></a>PWM实现方法</h4>输出比较模式，依靠内部计数器cnt和ccr设置的数值的比较来进行输出电平的控制，常用的有匹配时电平翻转和PWM模式<br>PWM占空比：$$DutyCycle&#x3D;\\frac{CCR}{ARR}$$<br>PWM频率：$$Freq&#x3D;\\frac{F_{clk}}{ARR}$$<br>PWM分辨率：$$Resolution&#x3D;\\frac{ARR}{2^{n}}$$<h4 id=\"高级定时器\"><a href=\"#高级定时器\" class=\"headerlink\" title=\"高级定时器\"></a>高级定时器</h4>死区生成：可以避免推挽电路上下管同时打开导致短路<h3 id=\"PWM控制电机\"><a href=\"#PWM控制电机\" class=\"headerlink\" title=\"PWM控制电机\"></a>PWM控制电机</h3>舵机是根据pwm信号控制舵机转动角度的，内部有直流电机<h4 id=\"电机驱动芯片\"><a href=\"#电机驱动芯片\" class=\"headerlink\" title=\"电机驱动芯片\"></a>电机驱动芯片</h4>利用H桥，可以控制电机转动方向。四个开关管可以构成两个推挽电路，使得电机可以获得两个方向的电流。<br>电机需要的电源一般是大功率的，不能直接通过gpio驱动，因此可以通过让stlink的5v口接入电机驱动芯片来获得电源。但是注意，pwm信号的地应当和电机电源的地相连，否则会出现电平不稳定的情况。<h3 id=\"PWM代码\"><a href=\"#PWM代码\" class=\"headerlink\" title=\"PWM代码\"></a>PWM代码</h3>pwm的激活结构如下：<br><img src=\"/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/PWM_Structure.jpg\" alt=\"PWM_Structure\"></li>\n<li>RCC开启时钟</li>\n<li>配置时基单元</li>\n<li>配置输出比较单元</li>\n<li>配置GPIO，设置为复用推挽输出</li>\n<li>运行控制，启动计数器<h4 id=\"TIM库函数\"><a href=\"#TIM库函数\" class=\"headerlink\" title=\"TIM库函数\"></a>TIM库函数</h4>在hal库中，tim相关库函数在stm32f1xx_hal_tim.h文件中<br>其中有关输出比较的内容有：</li>\n<li>TIM_OC_InitTypeDef: 输出比较初始化结构体</li>\n<li>HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)：输出比较初始化函数</li>\n<li>HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel)：配置输出通道函数</li>\n</ul>\n",
            "tags": [
                "技术",
                "博客",
                "电赛"
            ]
        }
    ]
}