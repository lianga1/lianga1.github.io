<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>意大利炮打友军 • Posts by &#34;电赛&#34; category</title>
    <link href="http://example.com" />
    <updated>2023-07-27T02:04:23.000Z</updated>
    <category term="随笔" />
    <category term="技术" />
    <category term="博客" />
    <category term="markdown" />
    <category term="python" />
    <category term="月历" />
    <category term="写作" />
    <category term="科幻" />
    <category term="世界观" />
    <category term="WSL" />
    <category term="Linux" />
    <category term="编译" />
    <category term="电赛" />
    <category term="记录" />
    <category term="周报" />
    <category term="课题组" />
    <category term="神经网络" />
    <category term="pytorch" />
    <entry>
        <id>http://example.com/2023/07/27/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-27/</id>
        <title>电赛培训-23-07-27</title>
        <link rel="alternate" href="http://example.com/2023/07/27/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-27/"/>
        <content type="html">&lt;h2 id=&#34;赛程&#34;&gt;&lt;a href=&#34;#赛程&#34; class=&#34;headerlink&#34; title=&#34;赛程&#34;&gt;&lt;/a&gt;赛程&lt;/h2&gt;&lt;p&gt;9-11号作品测评&lt;br&gt;2号早晨7点半到413，放题&lt;/p&gt;
</content>
        <updated>2023-07-27T02:04:23.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/19/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-19/</id>
        <title>电赛培训-23-07-19</title>
        <link rel="alternate" href="http://example.com/2023/07/19/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-19/"/>
        <content type="html">&lt;h1 id=&#34;pid控制系统&#34;&gt;&lt;a href=&#34;#pid控制系统&#34; class=&#34;headerlink&#34; title=&#34;pid控制系统&#34;&gt;&lt;/a&gt;pid控制系统&lt;/h1&gt;&lt;h2 id=&#34;公式&#34;&gt;&lt;a href=&#34;#公式&#34; class=&#34;headerlink&#34; title=&#34;公式&#34;&gt;&lt;/a&gt;公式&lt;/h2&gt;&lt;p&gt;$$ u(t)&amp;#x3D;K_p e(t)+K_i \int_0^t e(\tau) d\tau + K_d \frac{de(t)}{dt} $$&lt;/p&gt;
&lt;h2 id=&#34;作用&#34;&gt;&lt;a href=&#34;#作用&#34; class=&#34;headerlink&#34; title=&#34;作用&#34;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;比例项：减小误差&lt;/li&gt;
&lt;li&gt;积分项：消除稳态误差&lt;/li&gt;
&lt;li&gt;微分项：减小超调量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;超调量&#34;&gt;&lt;a href=&#34;#超调量&#34; class=&#34;headerlink&#34; title=&#34;超调量&#34;&gt;&lt;/a&gt;超调量&lt;/h3&gt;&lt;p&gt;$$ \xi &amp;#x3D; \frac{e^{-\frac{\pi \zeta}{\sqrt{1-\zeta^2}}}}{\sqrt{1-\zeta^2}} $$&lt;br&gt;超调量的意义在于：在没有积分项的情况下，超调量越大，系统的响应越快，但是超调量越大，系统的稳定性越差&lt;br&gt;其中 $\zeta$ 是阻尼系数，$\zeta$ 越大，超调量越小，系统越稳定&lt;/p&gt;
&lt;h2 id=&#34;误差&#34;&gt;&lt;a href=&#34;#误差&#34; class=&#34;headerlink&#34; title=&#34;误差&#34;&gt;&lt;/a&gt;误差&lt;/h2&gt;&lt;p&gt;低频抖动：积分项过大&lt;br&gt;高频抖动：微分项过大&lt;/p&gt;
&lt;h2 id=&#34;例子&#34;&gt;&lt;a href=&#34;#例子&#34; class=&#34;headerlink&#34; title=&#34;例子&#34;&gt;&lt;/a&gt;例子&lt;/h2&gt;&lt;p&gt;状态量：超声波，速度，MPU6050姿态，&lt;/p&gt;
&lt;h1 id=&#34;卡尔曼滤波&#34;&gt;&lt;a href=&#34;#卡尔曼滤波&#34; class=&#34;headerlink&#34; title=&#34;卡尔曼滤波&#34;&gt;&lt;/a&gt;卡尔曼滤波&lt;/h1&gt;&lt;h2 id=&#34;作用-1&#34;&gt;&lt;a href=&#34;#作用-1&#34; class=&#34;headerlink&#34; title=&#34;作用&#34;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;利用间接测量值，计算最优估算，组合各种可能受到噪音影响的数据源。&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;&lt;a href=&#34;#原理&#34; class=&#34;headerlink&#34; title=&#34;原理&#34;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;h3 id=&#34;状态观察&#34;&gt;&lt;a href=&#34;#状态观察&#34; class=&#34;headerlink&#34; title=&#34;状态观察&#34;&gt;&lt;/a&gt;状态观察&lt;/h3&gt;&lt;p&gt;状态观察是指，通过测量值，计算出状态量的过程，&lt;br&gt;状态观测器得到的估计状态表示为$ \hat{x}  $&lt;/p&gt;
&lt;h3 id=&#34;状态预测&#34;&gt;&lt;a href=&#34;#状态预测&#34; class=&#34;headerlink&#34; title=&#34;状态预测&#34;&gt;&lt;/a&gt;状态预测&lt;/h3&gt;&lt;p&gt;根据数学模型，从已有的状态量，通过计算得到了一个估计量$ \hat{x} $&lt;br&gt;然而，数学模型的预测有其局限性，初值条件不同所以不能得到相同的结果。&lt;br&gt;所以需要状态估算器&lt;/p&gt;
&lt;h3 id=&#34;状态估算&#34;&gt;&lt;a href=&#34;#状态估算&#34; class=&#34;headerlink&#34; title=&#34;状态估算&#34;&gt;&lt;/a&gt;状态估算&lt;/h3&gt;&lt;p&gt;需要估算值收敛到实际值，所以需要反馈，反馈误差为e&lt;br&gt;$$ e &amp;#x3D; x - \hat{x} $$假设一个微分方程：&lt;br&gt;$$ \dot{x} &amp;#x3D; Ax + Bu $$$$ y &amp;#x3D; Cx $$以上是一个真实系统&lt;br&gt;$$ \dot{\hat{x}} &amp;#x3D; A\hat{x} + Bu + Ke$$$$ \hat{y} &amp;#x3D; C\hat{x} $$这是系统估算模型&lt;/p&gt;
&lt;p&gt;两方程分别相减得到：&lt;br&gt;$$ \dot{e} &amp;#x3D;(A- KC)·e$$$$ y-\hat{y} &amp;#x3D; C·e$$&lt;br&gt;解得:&lt;br&gt;$$e(t) &amp;#x3D; e^{A-KC} ·e(0)$$&lt;br&gt;若A-KC的值小于0，那么e(t)会收敛到0，即估算值收敛到实际值，实际上，k可以加速收敛过程。&lt;/p&gt;
&lt;h3 id=&#34;例子-1&#34;&gt;&lt;a href=&#34;#例子-1&#34; class=&#34;headerlink&#34; title=&#34;例子&#34;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;$$ \dot{x} &amp;#x3D; Ax + Bu + w$$$$ y &amp;#x3D; Cx + v$$&lt;br&gt;w是过程噪声，v是测量噪声，他们都服从高斯分布，且互相独立。&lt;br&gt;在初始条件下，状态估算器估计了$\hat{x}$，真实值在这个中心的正态分布周围&lt;br&gt;在多轮预测后，估计值的分布会比初始条件下的估计分布更大，同时，还有一个测量方程得到的均值与方差都不同的分布，这两个分布的相乘就得到优化估计。&lt;br&gt;事实上，卡尔曼滤波器方程是一个随机系统的状态观测器&lt;br&gt;公式如下：&lt;br&gt;$$ \hat{x}&lt;em&gt;k&amp;#x3D;A·\hat{x}&lt;/em&gt;{k-1} +B·u_k +K_k(y_k - C(A·\hat{x}+B·u_k)) $$&lt;br&gt;其中$\hat{x_k^-}$是前项估测，代表前两项的和，所以公式写为：&lt;br&gt;$$ \hat{x}_k^ &amp;#x3D; A·\hat{x_k^-} ++K_k(y_k - C\hat{x_k^-}) $$&lt;/p&gt;
&lt;p&gt;所以结果成为后验估值。&lt;/p&gt;
&lt;p&gt;误差协方差矩阵P&lt;br&gt;$$ P_k^- &amp;#x3D; AP_{k-1}A^T +Q$$&lt;br&gt;这个就是对矩阵P的估值&lt;/p&gt;
&lt;p&gt;第二步，更新状态&lt;br&gt;$$ K_k &amp;#x3D; \frac{P_k^-C^T}{(CP_k^-C^T+R)} $$&lt;br&gt;这个是卡尔曼增益，使得更新K后误差协方差最小&lt;br&gt;$$ P_k &amp;#x3D; (I-K_kC)P_k^- $$&lt;/p&gt;
</content>
        <updated>2023-07-19T02:19:52.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/18/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-18/</id>
        <title>电赛培训-23-07-18</title>
        <link rel="alternate" href="http://example.com/2023/07/18/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-18/"/>
        <content type="html">&lt;h1 id=&#34;arduino小车测速&#34;&gt;&lt;a href=&#34;#arduino小车测速&#34; class=&#34;headerlink&#34; title=&#34;arduino小车测速&#34;&gt;&lt;/a&gt;arduino小车测速&lt;/h1&gt;&lt;h2 id=&#34;霍尔编码器&#34;&gt;&lt;a href=&#34;#霍尔编码器&#34; class=&#34;headerlink&#34; title=&#34;霍尔编码器&#34;&gt;&lt;/a&gt;霍尔编码器&lt;/h2&gt;&lt;h2 id=&#34;外部中断&#34;&gt;&lt;a href=&#34;#外部中断&#34; class=&#34;headerlink&#34; title=&#34;外部中断&#34;&gt;&lt;/a&gt;外部中断&lt;/h2&gt;&lt;p&gt;一个霍尔编码器如果有两个传感器传出两路信号，就能根据相位差同时测量速度和方向&lt;br&gt;但是arduino只有两个硬件中断管脚，同时还要使能计时器中断，所以需要一个外部中断库&lt;br&gt;PinChangeInterrupt库&lt;/p&gt;
&lt;h2 id=&#34;定时中断&#34;&gt;&lt;a href=&#34;#定时中断&#34; class=&#34;headerlink&#34; title=&#34;定时中断&#34;&gt;&lt;/a&gt;定时中断&lt;/h2&gt;&lt;p&gt;atmel内部有三个定时器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Timer0是delay用的&lt;/li&gt;
&lt;li&gt;Timer1是pwm用的&lt;/li&gt;
&lt;li&gt;只有Timer2可以使用来进行定时中断&lt;br&gt;因此，需要使用MsTimer2库来实现定时中断&lt;/li&gt;
&lt;/ul&gt;
</content>
        <updated>2023-07-18T02:44:15.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/14/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-14/</id>
        <title>电赛培训-23-07-14</title>
        <link rel="alternate" href="http://example.com/2023/07/14/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-14/"/>
        <content type="html">&lt;h1 id=&#34;PWM&#34;&gt;&lt;a href=&#34;#PWM&#34; class=&#34;headerlink&#34; title=&#34;PWM&#34;&gt;&lt;/a&gt;PWM&lt;/h1&gt;&lt;h2 id=&#34;通用定时器&#34;&gt;&lt;a href=&#34;#通用定时器&#34; class=&#34;headerlink&#34; title=&#34;通用定时器&#34;&gt;&lt;/a&gt;通用定时器&lt;/h2&gt;&lt;h3 id=&#34;预分频&#34;&gt;&lt;a href=&#34;#预分频&#34; class=&#34;headerlink&#34; title=&#34;预分频&#34;&gt;&lt;/a&gt;预分频&lt;/h3&gt;&lt;p&gt;通过对时钟频率进行分频，实现了让计数器可以计数更长的时间。&lt;/p&gt;
&lt;h2 id=&#34;占空比&#34;&gt;&lt;a href=&#34;#占空比&#34; class=&#34;headerlink&#34; title=&#34;占空比&#34;&gt;&lt;/a&gt;占空比&lt;/h2&gt;&lt;p&gt;占空比的实现是通过调节计数器到达翻转电平的值的大小来实现的。&lt;br&gt;利用的是计数器的比较功能&lt;br&gt;通过调节一个计数器不同的值，可以同时实现多个pwm的多个占空比的调节。但是他们的频率是相同的，若想要不同频率需要使用不同的计时器。&lt;br&gt;TIM3&amp;#x2F;4通道数较多&lt;/p&gt;
&lt;h2 id=&#34;捕获模式&#34;&gt;&lt;a href=&#34;#捕获模式&#34; class=&#34;headerlink&#34; title=&#34;捕获模式&#34;&gt;&lt;/a&gt;捕获模式&lt;/h2&gt;&lt;p&gt;捕获模式可以用来测量信号的频率，占空比等。&lt;/p&gt;
&lt;h2 id=&#34;设置&#34;&gt;&lt;a href=&#34;#设置&#34; class=&#34;headerlink&#34; title=&#34;设置&#34;&gt;&lt;/a&gt;设置&lt;/h2&gt;&lt;p&gt;打开对应channel的pwm生成，设定预分频和counter值（推荐一个方便运算占空比的值）&lt;/p&gt;
&lt;h2 id=&#34;作业&#34;&gt;&lt;a href=&#34;#作业&#34; class=&#34;headerlink&#34; title=&#34;作业&#34;&gt;&lt;/a&gt;作业&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需要实现通过按键增加占空比&lt;/li&gt;
&lt;li&gt;用捕获模式测量发生的PWM波频率和占空比&lt;/li&gt;
&lt;/ul&gt;
</content>
        <updated>2023-07-14T01:30:14.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/13/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-13/</id>
        <title>电赛培训-23-07-13</title>
        <link rel="alternate" href="http://example.com/2023/07/13/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-13/"/>
        <content type="html">&lt;h1 id=&#34;stm32串口通信&#34;&gt;&lt;a href=&#34;#stm32串口通信&#34; class=&#34;headerlink&#34; title=&#34;stm32串口通信&#34;&gt;&lt;/a&gt;stm32串口通信&lt;/h1&gt;&lt;h1 id=&#34;定时器&#34;&gt;&lt;a href=&#34;#定时器&#34; class=&#34;headerlink&#34; title=&#34;定时器&#34;&gt;&lt;/a&gt;定时器&lt;/h1&gt;&lt;h2 id=&#34;通用定时器&#34;&gt;&lt;a href=&#34;#通用定时器&#34; class=&#34;headerlink&#34; title=&#34;通用定时器&#34;&gt;&lt;/a&gt;通用定时器&lt;/h2&gt;&lt;p&gt;采用apb1&amp;#x2F;apb2总线&lt;/p&gt;
&lt;h3 id=&#34;预分频&#34;&gt;&lt;a href=&#34;#预分频&#34; class=&#34;headerlink&#34; title=&#34;预分频&#34;&gt;&lt;/a&gt;预分频&lt;/h3&gt;&lt;p&gt;计时时长&amp;#x3D; (预分频+1) * (计数器值+1) &amp;#x2F; 时钟频率&lt;/p&gt;
&lt;h3 id=&#34;中断回调&#34;&gt;&lt;a href=&#34;#中断回调&#34; class=&#34;headerlink&#34; title=&#34;中断回调&#34;&gt;&lt;/a&gt;中断回调&lt;/h3&gt;&lt;p&gt;HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&lt;br&gt;这个函数可以复制到it文件中，定义这个函数即可在中断中调用这个函数。&lt;/p&gt;
</content>
        <updated>2023-07-13T01:57:16.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/12/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-12/</id>
        <title>电赛培训-23-07-12</title>
        <link rel="alternate" href="http://example.com/2023/07/12/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-12/"/>
        <content type="html">&lt;h1 id=&#34;stm32定时器&#34;&gt;&lt;a href=&#34;#stm32定时器&#34; class=&#34;headerlink&#34; title=&#34;stm32定时器&#34;&gt;&lt;/a&gt;stm32定时器&lt;/h1&gt;&lt;p&gt;SysTick控制寄存器：&lt;br&gt;在SysTick_Config函数中，需要传进一个参数，代表着多少个tick触发一次中断。这个参数是一个32位的寄存器，但是只有24位有效，因此最大值是2^24-1，也就是16777215，也就是16Mhz的时钟下，最大延时是1s。如果需要更长的延时，需要自己写一个计数器，然后在中断中进行判断。&lt;br&gt;有一个变量是SystemCoreClock，代表当前时钟速度。把这个变量除以多少，就是把一秒分成多少份来计时。&lt;br&gt;在SysTick_Handler这个函数中，每次计时器触发中断都会调用这个函数，可以设置一个静态变量来进行计数，例如每1ms触发中断，就让这个函数每500次进入中断才执行某个行为，就能实现每500ms执行一次某个行为。&lt;/p&gt;
&lt;h1 id=&#34;按键中断&#34;&gt;&lt;a href=&#34;#按键中断&#34; class=&#34;headerlink&#34; title=&#34;按键中断&#34;&gt;&lt;/a&gt;按键中断&lt;/h1&gt;</content>
        <updated>2023-07-12T01:51:29.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/11/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-11/</id>
        <title>电赛培训-23-07-11</title>
        <link rel="alternate" href="http://example.com/2023/07/11/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-11/"/>
        <content type="html">&lt;h1 id=&#34;stm32-开发&#34;&gt;&lt;a href=&#34;#stm32-开发&#34; class=&#34;headerlink&#34; title=&#34;stm32 开发&#34;&gt;&lt;/a&gt;stm32 开发&lt;/h1&gt;&lt;h2 id=&#34;配置内容&#34;&gt;&lt;a href=&#34;#配置内容&#34; class=&#34;headerlink&#34; title=&#34;配置内容&#34;&gt;&lt;/a&gt;配置内容&lt;/h2&gt;&lt;p&gt;main.c中的user code 注释中间是不会被cube重新生成的&lt;/p&gt;
&lt;h2 id=&#34;时钟树&#34;&gt;&lt;a href=&#34;#时钟树&#34; class=&#34;headerlink&#34; title=&#34;时钟树&#34;&gt;&lt;/a&gt;时钟树&lt;/h2&gt;&lt;h2 id=&#34;第一个hal函数&#34;&gt;&lt;a href=&#34;#第一个hal函数&#34; class=&#34;headerlink&#34; title=&#34;第一个hal函数&#34;&gt;&lt;/a&gt;第一个hal函数&lt;/h2&gt;&lt;p&gt;HAL_GPIO_WritePin(GPIOF,LED0_PIN|LED1_PIN, GPIO_PIN_SET);&lt;br&gt;HAL_Delay(ms);&lt;/p&gt;
&lt;h2 id=&#34;板载按钮&#34;&gt;&lt;a href=&#34;#板载按钮&#34; class=&#34;headerlink&#34; title=&#34;板载按钮&#34;&gt;&lt;/a&gt;板载按钮&lt;/h2&gt;&lt;p&gt;PE4作为ButtonPin，使能需要一个上拉电阻&lt;/p&gt;
&lt;h2 id=&#34;中断&#34;&gt;&lt;a href=&#34;#中断&#34; class=&#34;headerlink&#34; title=&#34;中断&#34;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;p&gt;可以在cube中更改引脚为外部中断，可以调节中断触发模式&lt;/p&gt;
&lt;h1 id=&#34;stm32用于clion的诸多问题&#34;&gt;&lt;a href=&#34;#stm32用于clion的诸多问题&#34; class=&#34;headerlink&#34; title=&#34;stm32用于clion的诸多问题&#34;&gt;&lt;/a&gt;stm32用于clion的诸多问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Error: libusb_open() failed with LIBUSB_ERROR_NOT_SUPPORTED&lt;br&gt;初步估计是usb驱动问题，因此计划使用zadig重装驱动，libusb&lt;/li&gt;
&lt;li&gt;Error:Error: timed out while waiting for target halted&lt;br&gt;似乎是在等待重启的过程中超时，难道是没有设置重启？&lt;br&gt;&lt;strong&gt;解决了，忘了换配置文件了，老配置文件没问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;问题又来了，Initfailed，连接不到target，先用的玄学方法：按住rst按键，再烧录，就用这种笨方法至少可以烧录了&lt;br&gt;作为重置方法，接下来有一个比较好的解决方案，就是再cubemx中，pinout设置栏，再systemcore的sys部分里，有一个debug模式选择，之前一直是disable，所以拒绝再外部烧写，现在改成serial wire，就可以了。&lt;/li&gt;
&lt;/ol&gt;
</content>
        <updated>2023-07-11T01:49:47.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/10/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-10/</id>
        <title>电赛培训-23-07-10</title>
        <link rel="alternate" href="http://example.com/2023/07/10/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-10/"/>
        <content type="html">&lt;h1 id=&#34;spi与i2c&#34;&gt;&lt;a href=&#34;#spi与i2c&#34; class=&#34;headerlink&#34; title=&#34;spi与i2c&#34;&gt;&lt;/a&gt;spi与i2c&lt;/h1&gt;&lt;h2 id=&#34;iic通信&#34;&gt;&lt;a href=&#34;#iic通信&#34; class=&#34;headerlink&#34; title=&#34;iic通信&#34;&gt;&lt;/a&gt;iic通信&lt;/h2&gt;&lt;p&gt;i2c是一种用于设备间通讯的两线协议&lt;br&gt;硬件和软件实现都通过machine.I2C和machine.SoftI2C来实现。&lt;br&gt;硬件I2c优势在于速度快，但是对使用的引脚有限制。&lt;br&gt;软件I2C优势在于兼容性强，但是速度慢&lt;br&gt;函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件I2C：使用以下参数来构造I2C对象&lt;ul&gt;
&lt;li&gt;id表示特定的外设，取决于特定板子&lt;/li&gt;
&lt;li&gt;scl：时钟线引脚，Pin&lt;/li&gt;
&lt;li&gt;sda：数据线引脚，Pin&lt;/li&gt;
&lt;li&gt;freq：时钟频率，整数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意接线先关注缺少的端口例如I2C或uart，之后再关注gpio&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件I2C：使用以下参数来构造I2C对象&lt;ul&gt;
&lt;li&gt;scl：时钟线引脚，Pin&lt;/li&gt;
&lt;li&gt;sda：数据线引脚，Pin&lt;/li&gt;
&lt;li&gt;freq：时钟频率，整数&lt;/li&gt;
&lt;li&gt;timeout：超时时间，整数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;init函数可以重新定义&lt;/li&gt;
&lt;li&gt;I2C.start()：开始通信&lt;/li&gt;
&lt;li&gt;I2C.stop()：结束通信&lt;/li&gt;
&lt;li&gt;I2C.readint(buf,nack&amp;#x3D;True):读取字节存储到buf中，字节长度是buf长度，收到出最后一个字节以外所有子接后，将发送ack，如果设置nack则发送nack，ack代表着以后还会传输，nack代表着这是最后一个字节&lt;/li&gt;
&lt;li&gt;I2C.write(buf)：将buf中的字节写入到总线上，检查每个字节是否收到ack&lt;/li&gt;
&lt;li&gt;I2C.readfrom(addr,nbytes,stop&amp;#x3D;True):从addr地址读取nbytes个字节，如果stop为True则在输入结束时发送stop信号。&lt;/li&gt;
&lt;li&gt;I2c.readfrom_into(adr,)&lt;/li&gt;
&lt;li&gt;I2c.writeto(addr,buf,stop&amp;#x3D;True)&lt;/li&gt;
&lt;li&gt;I2c.writevto(addr,vector,stop&amp;#x3D;True)将vector中包含的字节写入addr指定的从站，vector应该具有缓冲协议的元组或对象列表&lt;/li&gt;
&lt;li&gt;I2c.readfrom_mem(addr,memaddr,nbytes,addrsize&amp;#x3D;8)从memaddr指定的内存地址开始，从addr指定的从站读出nbytes。参数addrsize以位为单位指定地址大小，返回读取数据bytes对象。&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;硬件I3c外设&#34;&gt;&lt;a href=&#34;#硬件I3c外设&#34; class=&#34;headerlink&#34; title=&#34;硬件I3c外设&#34;&gt;&lt;/a&gt;硬件I3c外设&lt;/h3&gt;任何可用的输出引脚都可以用于scl和sda，默认情况下，I2C对象使用id 0，scl引脚为22，sda引脚为21，时钟频率为400kHz。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;spi通信&#34;&gt;&lt;a href=&#34;#spi通信&#34; class=&#34;headerlink&#34; title=&#34;spi通信&#34;&gt;&lt;/a&gt;spi通信&lt;/h2&gt;&lt;p&gt;spi是一种由主机驱动的同步串行协议。在物理层概念，一条总线有三条线路组成：SCK，MOSI、MISO，多个设备可以共享一条总线。每个设备有一个单独的第四个信号SS（从设备选择），来选择总线上的特定设备并与之通信。&lt;/p&gt;
&lt;figure class=&#34;highlight gml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs gml&#34;&gt;machine.SPI(&lt;span class=&#34;hljs-symbol&#34;&gt;id&lt;/span&gt;)# 在给定的总线&lt;span class=&#34;hljs-symbol&#34;&gt;id&lt;/span&gt;上构造一个SPI对象。&lt;span class=&#34;hljs-symbol&#34;&gt;id&lt;/span&gt;的值取决于特定端口以及硬件&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;stm32&#34;&gt;&lt;a href=&#34;#stm32&#34; class=&#34;headerlink&#34; title=&#34;stm32&#34;&gt;&lt;/a&gt;stm32&lt;/h1&gt;&lt;h2 id=&#34;引脚&#34;&gt;&lt;a href=&#34;#引脚&#34; class=&#34;headerlink&#34; title=&#34;引脚&#34;&gt;&lt;/a&gt;引脚&lt;/h2&gt;&lt;p&gt;在cubemx中，浅黄色是不能修改定义的，深黄色也是默认的。&lt;/p&gt;
&lt;h2 id=&#34;配置&#34;&gt;&lt;a href=&#34;#配置&#34; class=&#34;headerlink&#34; title=&#34;配置&#34;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;引脚配置，在pinout_configuration中，如下图所示：&lt;br&gt;&lt;img src=&#34;/2023/07/10/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-10/GPIO_conf.png&#34; alt=&#34;引脚配置&#34;&gt;&lt;br&gt;可以配置其中每个引脚的功能，例如GPIO、SPI、I2C等等。&lt;/p&gt;
</content>
        <updated>2023-07-10T01:40:59.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/07/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-07/</id>
        <title>电赛培训-23-07-07</title>
        <link rel="alternate" href="http://example.com/2023/07/07/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-07/"/>
        <content type="html">&lt;h1 id=&#34;串口通信&#34;&gt;&lt;a href=&#34;#串口通信&#34; class=&#34;headerlink&#34; title=&#34;串口通信&#34;&gt;&lt;/a&gt;串口通信&lt;/h1&gt;&lt;h2 id=&#34;串行vs并行&#34;&gt;&lt;a href=&#34;#串行vs并行&#34; class=&#34;headerlink&#34; title=&#34;串行vs并行&#34;&gt;&lt;/a&gt;串行vs并行&lt;/h2&gt;&lt;p&gt;并行优点：快，效率高&lt;br&gt;缺点：需要端口多&lt;br&gt;串行优点：只需要一个端口&lt;br&gt;缺点：慢，效率低，且需要明确数据拍成一串的规则&lt;br&gt;（大端法vs小端法）&lt;/p&gt;
&lt;h2 id=&#34;通信&#34;&gt;&lt;a href=&#34;#通信&#34; class=&#34;headerlink&#34; title=&#34;通信&#34;&gt;&lt;/a&gt;通信&lt;/h2&gt;&lt;p&gt;串行通信每次只发送一个字节，对于字节内部发送bit的顺序，每个通讯协议都是相同的，但是字节的顺序却不一定相同，这就是大端法和小端法的区别。&lt;/p&gt;
&lt;h3 id=&#34;I2C通信&#34;&gt;&lt;a href=&#34;#I2C通信&#34; class=&#34;headerlink&#34; title=&#34;I2C通信&#34;&gt;&lt;/a&gt;I2C通信&lt;/h3&gt;&lt;p&gt;一个通信口可以和多个设备进行传输，只需要SDA和SCL两个数据线即可，SDA为数据线，SCL为时钟线，时钟线由主设备控制，主设备为发送方，从设备为接收方，从设备的地址由主设备指定，主设备发送数据时，从设备会返回一个ACK信号，表示接收成功，如果没有返回ACK信号，主设备会认为发送失败，重新发送。&lt;br&gt;但是，I2C驱动能力较弱，需要在数据线加上拉电阻，且所有设备必须有不同地址。&lt;/p&gt;
&lt;h3 id=&#34;SPI通信&#34;&gt;&lt;a href=&#34;#SPI通信&#34; class=&#34;headerlink&#34; title=&#34;SPI通信&#34;&gt;&lt;/a&gt;SPI通信&lt;/h3&gt;&lt;p&gt;不需要考虑地址为问题，可以一个Master带多个slave。&lt;br&gt;缺点：每多一个从机，就需要有一个IO口作为片选信号，且需要一个时钟信号，所以需要的IO口较多。&lt;/p&gt;
&lt;h3 id=&#34;UART通信&#34;&gt;&lt;a href=&#34;#UART通信&#34; class=&#34;headerlink&#34; title=&#34;UART通信&#34;&gt;&lt;/a&gt;UART通信&lt;/h3&gt;&lt;p&gt;接线非常简单，且双方对等，谁都可以随时发送信息。&lt;br&gt;缺点：容易接错，且难实现多个设备同时通信。而且功耗较大，所以很多传感器上不配备。&lt;br&gt;波特率：每个位对应时间长度的倒数&lt;br&gt;uart通信有起始位，数据位，校验位，停止位，所以每个字节需要10个bit，所以波特率为115200时，每秒可以传输11520个字节。&lt;/p&gt;
&lt;h4 id=&#34;电平标准&#34;&gt;&lt;a href=&#34;#电平标准&#34; class=&#34;headerlink&#34; title=&#34;电平标准&#34;&gt;&lt;/a&gt;电平标准&lt;/h4&gt;&lt;p&gt;usb标准：看D+和D-的电平差，差大是1，小是0&lt;br&gt;TTL电平：0v是低电平，5&amp;#x2F;3.3v是高电平&lt;br&gt;RS232电平：-3v&lt;del&gt;-15v是低电平，3v&lt;/del&gt;15v是高电平&lt;/p&gt;
&lt;h4 id=&#34;Arduino的uart&#34;&gt;&lt;a href=&#34;#Arduino的uart&#34; class=&#34;headerlink&#34; title=&#34;Arduino的uart&#34;&gt;&lt;/a&gt;Arduino的uart&lt;/h4&gt;&lt;p&gt;ttl电平5v&lt;br&gt;1为tx&lt;br&gt;0为rx&lt;br&gt;内部已通过ch340g串口转usb，与usb相连，arduino用uart串口发送信息时，会通过ch340g转换为usb信号，所以可以通过usb接收信息。&lt;br&gt;函数：&lt;/p&gt;
&lt;figure class=&#34;highlight reasonml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs reasonml&#34;&gt;&lt;span class=&#34;hljs-module-access&#34;&gt;&lt;span class=&#34;hljs-module&#34;&gt;&lt;span class=&#34;hljs-identifier&#34;&gt;Serial&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;begin&lt;/span&gt;(baudrate)：设置波特率&lt;br&gt;&lt;span class=&#34;hljs-module-access&#34;&gt;&lt;span class=&#34;hljs-module&#34;&gt;&lt;span class=&#34;hljs-identifier&#34;&gt;Serianl&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;print(content,选项)：发送信息,可以是数字，字符串，数组，对象，选项可以是DEC，BIN，OCT，HEX，BYTE，WORD，FLOAT，STRING，可以指定发送的进制，或者发送字符串。&lt;br&gt;&lt;span class=&#34;hljs-module-access&#34;&gt;&lt;span class=&#34;hljs-module&#34;&gt;&lt;span class=&#34;hljs-identifier&#34;&gt;Serial&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;println(content,选项)：发送信息，与print不同的是，会在最后加上换行符。&lt;br&gt;&lt;span class=&#34;hljs-module-access&#34;&gt;&lt;span class=&#34;hljs-module&#34;&gt;&lt;span class=&#34;hljs-identifier&#34;&gt;Serial&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;available&lt;span class=&#34;hljs-literal&#34;&gt;()&lt;/span&gt;：返回接收缓冲区中的字节数&lt;br&gt;&lt;span class=&#34;hljs-module-access&#34;&gt;&lt;span class=&#34;hljs-module&#34;&gt;&lt;span class=&#34;hljs-identifier&#34;&gt;Serial&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;read&lt;span class=&#34;hljs-constructor&#34;&gt;Bytes(&lt;span class=&#34;hljs-params&#34;&gt;char&lt;/span&gt;类型数组名，最大读取长度)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-module-access&#34;&gt;&lt;span class=&#34;hljs-module&#34;&gt;&lt;span class=&#34;hljs-identifier&#34;&gt;Serial&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;write(&lt;span class=&#34;hljs-built_in&#34;&gt;char&lt;/span&gt;类型数组名，写入长度)：总共能发送数据长度个字节。按照数组中每个原始值诸葛发送，可以借助这个功能，对&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt;结构体中相关数据作为一个整体，将结构体指针强制转型为byte*类型，后面数据长度用sizeof(&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt;),这样就可以将结构体作为一个整体发送。&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&#34;Arduino的uart工具&#34;&gt;&lt;a href=&#34;#Arduino的uart工具&#34; class=&#34;headerlink&#34; title=&#34;Arduino的uart工具&#34;&gt;&lt;/a&gt;Arduino的uart工具&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;串口绘图仪：可以发送数据时利用数据名：数据的格式，将以时间为横轴，数值为纵轴，根据格式中构成的变量数量，以不同颜色的线段，随时间变化的情况进行绘图。&lt;/li&gt;
&lt;li&gt;BYSerial&lt;br&gt;串口不能同时被多个程序打开。&lt;h2 id=&#34;网络&#34;&gt;&lt;a href=&#34;#网络&#34; class=&#34;headerlink&#34; title=&#34;网络&#34;&gt;&lt;/a&gt;网络&lt;/h2&gt;基本概念：&lt;/li&gt;
&lt;li&gt;TCP&amp;#x2F;IP协议：定义了设备如何连接如互联网&lt;/li&gt;
&lt;li&gt;TCP：信息必须齐全的网络通信的基础&lt;/li&gt;
&lt;li&gt;UDP：信息可以缺少或者需要广播的网络通信的基础&lt;/li&gt;
&lt;li&gt;IP：计算机之间用于识别身份的临时位置编号&lt;/li&gt;
&lt;li&gt;ICMP：网络控制信号协议&lt;/li&gt;
&lt;li&gt;DHCP：动态分配ip地址协议&lt;/li&gt;
&lt;li&gt;一个能连接互联网的网课出厂自带的编号。&lt;h3 id=&#34;ipv4&#34;&gt;&lt;a href=&#34;#ipv4&#34; class=&#34;headerlink&#34; title=&#34;ipv4&#34;&gt;&lt;/a&gt;ipv4&lt;/h3&gt;ipv4定义了32位二进制地址&lt;br&gt;同时，ipv4定义了一些只会用于内部网络的地址编号，称为私网ip段，剩下的都是用于全球公网ip。&lt;br&gt;例如&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;10.0.0.0-10.255.255.255&lt;br&gt;172.16.0.0-172.31.255.255&lt;br&gt;192.168.0.0-192.168.255.255&lt;/p&gt;
&lt;h3 id=&#34;ipv6&#34;&gt;&lt;a href=&#34;#ipv6&#34; class=&#34;headerlink&#34; title=&#34;ipv6&#34;&gt;&lt;/a&gt;ipv6&lt;/h3&gt;&lt;p&gt;ipv6定义了128位二进制地址&lt;/p&gt;
&lt;h3 id=&#34;子网掩码&#34;&gt;&lt;a href=&#34;#子网掩码&#34; class=&#34;headerlink&#34; title=&#34;子网掩码&#34;&gt;&lt;/a&gt;子网掩码&lt;/h3&gt;&lt;p&gt;子网掩码用于判断ip地址的前几位是网络号，后几位是主机号。&lt;br&gt;32个二进制位表示ip地址截止到哪里，只要相同就认为在同一个子网内，可以直接通信无需交给网关做转发。要求必须1卡头，连续多个1，剩下的是0。255.255.255.0对于这个设备，前面三个点分十进制数相同，那就认为是在同一个网络下，因此会直接连接而不会寻求网关。&lt;/p&gt;
&lt;h3 id=&#34;tcp协议&#34;&gt;&lt;a href=&#34;#tcp协议&#34; class=&#34;headerlink&#34; title=&#34;tcp协议&#34;&gt;&lt;/a&gt;tcp协议&lt;/h3&gt;&lt;p&gt;传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议，一个tcp连接需要有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在一个网络色悲伤，特定的网络端口如8080（最好大于1023）上开创一个tcp server，这个过程叫做绑定端口，并开始监听端口。&lt;/li&gt;
&lt;li&gt;得到该网络设备的ip地址，因此需要体现获得server的ipv4地址，以及开启tcp监听端口。&lt;h3 id=&#34;udp协议&#34;&gt;&lt;a href=&#34;#udp协议&#34; class=&#34;headerlink&#34; title=&#34;udp协议&#34;&gt;&lt;/a&gt;udp协议&lt;/h3&gt;无连接的传输协议，成为用户数据报协议&lt;br&gt;udp提供了一个无需链接就能发送封装的ip数据包的方法，建立一套tcp连接需要有：&lt;/li&gt;
&lt;li&gt;在一个网络设备上，特定的网络端口如8080（最好大于1023）上开创一个udp socket&lt;/li&gt;
&lt;li&gt;设定好目的地IP地址和端口便可以随心所欲发送数据&lt;/li&gt;
&lt;li&gt;目的地ip地址对应网络设备B，如果尝试在自己9090端口上开创一个udp socket，且A正好在发送信息，那么此时就能受到A发送的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;wifi连接&#34;&gt;&lt;a href=&#34;#wifi连接&#34; class=&#34;headerlink&#34; title=&#34;wifi连接&#34;&gt;&lt;/a&gt;wifi连接&lt;/h2&gt;&lt;h3 id=&#34;station终端&#34;&gt;&lt;a href=&#34;#station终端&#34; class=&#34;headerlink&#34; title=&#34;station终端&#34;&gt;&lt;/a&gt;station终端&lt;/h3&gt;&lt;p&gt;新建station&lt;/p&gt;
&lt;figure class=&#34;highlight pgsql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs pgsql&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;import&lt;/span&gt; network&lt;br&gt;wlan - network.WLAN(network.STA.&lt;span class=&#34;hljs-keyword&#34;&gt;IF&lt;/span&gt;)# &lt;span class=&#34;hljs-keyword&#34;&gt;create&lt;/span&gt; station&lt;br&gt;wlan.active(&lt;span class=&#34;hljs-keyword&#34;&gt;True&lt;/span&gt;)&lt;br&gt;wlan.scan() #scan &lt;span class=&#34;hljs-keyword&#34;&gt;for&lt;/span&gt; acess points(AP)&lt;br&gt;wlan.isconnected() #&lt;span class=&#34;hljs-keyword&#34;&gt;check&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; the station &lt;span class=&#34;hljs-keyword&#34;&gt;is&lt;/span&gt; connected &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; an AP&lt;br&gt;&lt;br&gt;wlan.&lt;span class=&#34;hljs-keyword&#34;&gt;connect&lt;/span&gt;(&lt;span class=&#34;hljs-string&#34;&gt;&amp;#x27;ssid&amp;#x27;&lt;/span&gt;, &lt;span class=&#34;hljs-string&#34;&gt;&amp;#x27;key&amp;#x27;&lt;/span&gt;) #&lt;span class=&#34;hljs-keyword&#34;&gt;connect&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; an AP&lt;br&gt;wlan.config(&lt;span class=&#34;hljs-string&#34;&gt;&amp;#x27;mac&amp;#x27;&lt;/span&gt;) #&lt;span class=&#34;hljs-keyword&#34;&gt;get&lt;/span&gt; the interfac&lt;span class=&#34;hljs-string&#34;&gt;e&amp;#x27;s MAC address&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-string&#34;&gt;wlan.ifconfig() #get the interface&amp;#x27;&lt;/span&gt;s IP/netmask/gw/DNS addresses&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;新建AP&lt;/p&gt;
&lt;figure class=&#34;highlight pgsql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs pgsql&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;import&lt;/span&gt; network&lt;br&gt;ap = network.WLAN(network.AP_IF) # &lt;span class=&#34;hljs-keyword&#34;&gt;create&lt;/span&gt; acess &lt;span class=&#34;hljs-type&#34;&gt;point&lt;/span&gt; interface&lt;br&gt;ap.config(ssid=&lt;span class=&#34;hljs-string&#34;&gt;&amp;#x27;ESP-AP&amp;#x27;&lt;/span&gt;) #&lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; the SSID &lt;span class=&#34;hljs-keyword&#34;&gt;of&lt;/span&gt; the &lt;span class=&#34;hljs-keyword&#34;&gt;access&lt;/span&gt; &lt;span class=&#34;hljs-type&#34;&gt;point&lt;/span&gt;&lt;br&gt;ap.config(max_clients=&lt;span class=&#34;hljs-number&#34;&gt;10&lt;/span&gt;) #&lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; how many clients can &lt;span class=&#34;hljs-keyword&#34;&gt;connect&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; the &lt;span class=&#34;hljs-keyword&#34;&gt;access&lt;/span&gt; &lt;span class=&#34;hljs-type&#34;&gt;point&lt;/span&gt;&lt;br&gt;ap.active(&lt;span class=&#34;hljs-keyword&#34;&gt;True&lt;/span&gt;)&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;tcp通讯：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接wifi&lt;/li&gt;
&lt;li&gt;获取本地ip&lt;/li&gt;
&lt;li&gt;创建tcp&lt;/li&gt;
&lt;li&gt;绑定本地ip和端口&lt;/li&gt;
&lt;li&gt;设定最大连接数&lt;/li&gt;
&lt;li&gt;配置tcp选项&lt;/li&gt;
&lt;li&gt;用户进入获取用户组&lt;/li&gt;
&lt;li&gt;读取用户信息，&lt;/li&gt;
&lt;li&gt;发送接收到的数据给发送者&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;udp通讯：server&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建socket对象要设置udp模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;udp通信：client&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断wifi连接&lt;/li&gt;
&lt;li&gt;发送使用sendto函数&lt;/li&gt;
&lt;/ol&gt;
</content>
        <updated>2023-07-07T01:34:49.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/06/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-06/</id>
        <title>电赛培训-23-07-06</title>
        <link rel="alternate" href="http://example.com/2023/07/06/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-06/"/>
        <content type="html">&lt;h1 id=&#34;ESP32&#34;&gt;&lt;a href=&#34;#ESP32&#34; class=&#34;headerlink&#34; title=&#34;ESP32&#34;&gt;&lt;/a&gt;ESP32&lt;/h1&gt;&lt;h2 id=&#34;中断&#34;&gt;&lt;a href=&#34;#中断&#34; class=&#34;headerlink&#34; title=&#34;中断&#34;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;p&gt;中断处理程序不要运行时间过长，不要分配内存&lt;/p&gt;
&lt;h3 id=&#34;紧急异常缓冲区&#34;&gt;&lt;a href=&#34;#紧急异常缓冲区&#34; class=&#34;headerlink&#34; title=&#34;紧急异常缓冲区&#34;&gt;&lt;/a&gt;紧急异常缓冲区&lt;/h3&gt;&lt;p&gt;如果ISR中发生错误，MicroPython无法生成错误报告&lt;br&gt;除非创建特殊缓冲区&lt;/p&gt;
&lt;figure class=&#34;highlight elm&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs elm&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;import&lt;/span&gt; micropython&lt;br&gt;&lt;span class=&#34;hljs-title&#34;&gt;micropython&lt;/span&gt;.alloc_emergency_exception_buf(&lt;span class=&#34;hljs-number&#34;&gt;100&lt;/span&gt;)&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;UART&#34;&gt;&lt;a href=&#34;#UART&#34; class=&#34;headerlink&#34; title=&#34;UART&#34;&gt;&lt;/a&gt;UART&lt;/h2&gt;&lt;p&gt;esp32有三个硬件UART，分别是UART0，UART1，UART2&lt;br&gt;各自分配了默认GPIO&lt;br&gt;TX：当前设备的发送&lt;br&gt;RX：当前设备的接收&lt;br&gt;串口中不分主从&lt;/p&gt;
&lt;figure class=&#34;highlight apache&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs apache&#34;&gt;&lt;span class=&#34;hljs-attribute&#34;&gt;from&lt;/span&gt; machine import UART&lt;br&gt;&lt;span class=&#34;hljs-attribute&#34;&gt;uart1&lt;/span&gt; = (&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;,baudrate=&lt;span class=&#34;hljs-number&#34;&gt;9600&lt;/span&gt;,tx=&lt;span class=&#34;hljs-number&#34;&gt;33&lt;/span&gt;,rx=&lt;span class=&#34;hljs-number&#34;&gt;32&lt;/span&gt;)#指定了id&lt;br&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;任何GPIO都可以用于使用GPIO矩阵的硬件UART，除了可以用作rx的仅输入引脚34-39&lt;br&gt;发送与接受的波特率一样&lt;/p&gt;
&lt;p&gt;一种调试方法：不能使用调试器时，可以利用串口输出进行调试。&lt;/p&gt;
&lt;h2 id=&#34;ADC&#34;&gt;&lt;a href=&#34;#ADC&#34; class=&#34;headerlink&#34; title=&#34;ADC&#34;&gt;&lt;/a&gt;ADC&lt;/h2&gt;&lt;figure class=&#34;highlight reasonml&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs reasonml&#34;&gt;from machine import ADC&lt;br&gt;adc = &lt;span class=&#34;hljs-constructor&#34;&gt;ADC(&lt;span class=&#34;hljs-params&#34;&gt;pin&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;val&lt;/span&gt; = adc.read&lt;span class=&#34;hljs-constructor&#34;&gt;_u16()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;val&lt;/span&gt; = adc.read&lt;span class=&#34;hljs-constructor&#34;&gt;_uv()&lt;/span&gt;# &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; microvolts&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;ADC2也被wifi使用，所以开启wifi时会发生adc2异常&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;定时器&#34;&gt;&lt;a href=&#34;#定时器&#34; class=&#34;headerlink&#34; title=&#34;定时器&#34;&gt;&lt;/a&gt;定时器&lt;/h2&gt;&lt;p&gt;Timer.init(*,mode&amp;#x3D;Timer.PERIODIC,period&amp;#x3D;-1,callback&amp;#x3D;None)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mode 可以是ONE_SHOT或PERIODIC（单次或周期计时）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;PWM&#34;&gt;&lt;a href=&#34;#PWM&#34; class=&#34;headerlink&#34; title=&#34;PWM&#34;&gt;&lt;/a&gt;PWM&lt;/h2&gt;</content>
        <updated>2023-07-06T01:48:40.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/</id>
        <title>电赛培训-23-07-05</title>
        <link rel="alternate" href="http://example.com/2023/07/05/%E7%94%B5%E8%B5%9B%E5%9F%B9%E8%AE%AD-23-07-05/"/>
        <content type="html">&lt;h1 id=&#34;Arduino&#34;&gt;&lt;a href=&#34;#Arduino&#34; class=&#34;headerlink&#34; title=&#34;Arduino&#34;&gt;&lt;/a&gt;Arduino&lt;/h1&gt;&lt;p&gt;软件：使用Arduino IDE，以C++风格语言编写相关库。&lt;br&gt;利用IDE编译固件下载到Arduino的前提条件是有bootloader程序。&lt;br&gt;所以从程序到固件的关键在于bootloader，其他单片机也可以装载bootloader固件，然后使用arduino库。&lt;/p&gt;
&lt;h2 id=&#34;硬件-uno板&#34;&gt;&lt;a href=&#34;#硬件-uno板&#34; class=&#34;headerlink&#34; title=&#34;硬件 uno板&#34;&gt;&lt;/a&gt;硬件 uno板&lt;/h2&gt;&lt;p&gt;工作电压5v,可以typeB，DC5.5，或者跳线接入&lt;br&gt;共有14个数字输入输出（6个PWM口），6个模拟输入输出&lt;/p&gt;
&lt;h2 id=&#34;系统指示灯&#34;&gt;&lt;a href=&#34;#系统指示灯&#34; class=&#34;headerlink&#34; title=&#34;系统指示灯&#34;&gt;&lt;/a&gt;系统指示灯&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ON：系统指示灯&lt;/li&gt;
&lt;li&gt;RX：接收指示灯&lt;/li&gt;
&lt;li&gt;TX：发送指示灯&lt;/li&gt;
&lt;li&gt;L：内置LED，对应13号数字口&lt;h2 id=&#34;开始编写代码&#34;&gt;&lt;a href=&#34;#开始编写代码&#34; class=&#34;headerlink&#34; title=&#34;开始编写代码&#34;&gt;&lt;/a&gt;开始编写代码&lt;/h2&gt;有两个一定会有的函数，void setup()和void loop()，分别是初始化和循环函数。&lt;br&gt;setup会执行一次，loop在setup后会自动循环&lt;h3 id=&#34;setup函数&#34;&gt;&lt;a href=&#34;#setup函数&#34; class=&#34;headerlink&#34; title=&#34;setup函数&#34;&gt;&lt;/a&gt;setup函数&lt;/h3&gt;setup中用pinMode配置管脚模式为输出&lt;br&gt;pinMode(pin编号，INPUT)：高阻态，可认为是100m欧姆，电平不定。&lt;br&gt;pinMode(pinnum,INPUT_PULLUP):内置上拉输入，无外部信号默认高电平。&lt;br&gt;pinMode(pinnum,OUTPUT):输出模式，uno上高电平5v，电流&amp;lt;40mA&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;loop函数&#34;&gt;&lt;a href=&#34;#loop函数&#34; class=&#34;headerlink&#34; title=&#34;loop函数&#34;&gt;&lt;/a&gt;loop函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;digitalWrite(pinnum,HIGH&amp;#x2F;LOW):输出高低电平，只对output模式有效&lt;/li&gt;
&lt;li&gt;digitalRead(pinnum):读取高低电平,返回HIGH&amp;#x2F;LOW两种电平&lt;/li&gt;
&lt;li&gt;analogRead(anaPinNum)：读取模拟输入电平，返回0-1023的数字，对应0-5v的电压&lt;/li&gt;
&lt;li&gt;analogWrite(pwmPinNum,0-255)：输出PWM波，对应0-5v的电压，频率为490Hz(3,9,10,11pin),或980Hz(5,6pin)&lt;/li&gt;
&lt;li&gt;analogReference(AD参考电压输入来源)：切换AD参考电压输入来源，有默认值，一般不用，可以让输出更加精细。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断和轮询&#34;&gt;&lt;a href=&#34;#中断和轮询&#34; class=&#34;headerlink&#34; title=&#34;中断和轮询&#34;&gt;&lt;/a&gt;中断和轮询&lt;/h3&gt;&lt;p&gt;轮询：不断重复读取某个状态值，缺点是占用资源&lt;br&gt;中断：可以通过某个状态改变来发送信号，然后发送信号后可以执行其他操作，之后再恢复到发送信号之前的状态。&lt;br&gt;管脚中断：attachInterrupt(digitalPinToInterrupt(pinnum),ISR,mode),第一个参数是中断管脚号（uno为2，3），第二个参数是中断服务函数（可以自定义），第三个参数是中断模式，有LOW，RISING，FALLING，CHANGE四种模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LOW：低电平触发&lt;/li&gt;
&lt;li&gt;RISING：上升沿触发&lt;/li&gt;
&lt;li&gt;FALLING：下降沿触发&lt;/li&gt;
&lt;li&gt;CHANGE：任意电平变化触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意，终端服务函数应当很短，而且不能使用其他中断实现的函数，延时需要delayMicroseconds(us)&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;修改全局变量应当用volatile修饰，防止编译器优化&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;ESP32&#34;&gt;&lt;a href=&#34;#ESP32&#34; class=&#34;headerlink&#34; title=&#34;ESP32&#34;&gt;&lt;/a&gt;ESP32&lt;/h1&gt;&lt;h2 id=&#34;硬件&#34;&gt;&lt;a href=&#34;#硬件&#34; class=&#34;headerlink&#34; title=&#34;硬件&#34;&gt;&lt;/a&gt;硬件&lt;/h2&gt;&lt;p&gt;esp32-WROOM-32&lt;br&gt;串口芯片：CP2102&lt;br&gt;核心频率240mHz&lt;br&gt;WiFi IEEE 802.11 b&amp;#x2F;g&amp;#x2F;n 2.4GHz&lt;br&gt;BLuetooth 4.2 BR&amp;#x2F;EDR and BLE&lt;br&gt;520k SRAM 448kB ROM&lt;br&gt;2个I2S，RMT远程控制，LED PWM，1个host SD&amp;#x2F;eMMC&amp;#x2F;SDIO，一个slave SDIO&amp;#x2F;SPI. TWAI(CAN),12bitADC,Ethernet&lt;/p&gt;
&lt;h2 id=&#34;开发环境&#34;&gt;&lt;a href=&#34;#开发环境&#34; class=&#34;headerlink&#34; title=&#34;开发环境&#34;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;MicroPython+Thonny&lt;/p&gt;
&lt;h3 id=&#34;常用库&#34;&gt;&lt;a href=&#34;#常用库&#34; class=&#34;headerlink&#34; title=&#34;常用库&#34;&gt;&lt;/a&gt;常用库&lt;/h3&gt;&lt;h3 id=&#34;GPIO&#34;&gt;&lt;a href=&#34;#GPIO&#34; class=&#34;headerlink&#34; title=&#34;GPIO&#34;&gt;&lt;/a&gt;GPIO&lt;/h3&gt;&lt;figure class=&#34;highlight pgsql&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;div class=&#34;code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs pgsql&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;from&lt;/span&gt; machine &lt;span class=&#34;hljs-keyword&#34;&gt;import&lt;/span&gt; Pin&lt;br&gt;&lt;br&gt;p0 = Pin(&lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;,Pin.&lt;span class=&#34;hljs-keyword&#34;&gt;OUT&lt;/span&gt;) # &lt;span class=&#34;hljs-keyword&#34;&gt;create&lt;/span&gt; output pin &lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt; GPIO0&lt;br&gt;p0.&lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt;() # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &amp;quot;on&amp;quot; (high) &lt;span class=&#34;hljs-keyword&#34;&gt;level&lt;/span&gt;&lt;br&gt;p0.&lt;span class=&#34;hljs-keyword&#34;&gt;off&lt;/span&gt;() # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &amp;quot;off&amp;quot; (low) &lt;span class=&#34;hljs-keyword&#34;&gt;level&lt;/span&gt;&lt;br&gt;p0.&lt;span class=&#34;hljs-keyword&#34;&gt;value&lt;/span&gt;(&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;on&lt;/span&gt;/high&lt;br&gt;p0.init(p0.&lt;span class=&#34;hljs-keyword&#34;&gt;IN&lt;/span&gt;,p0.PULL_DOWN) # &lt;span class=&#34;hljs-keyword&#34;&gt;set&lt;/span&gt; pin &lt;span class=&#34;hljs-keyword&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;input&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;with&lt;/span&gt; a pull-down resistor&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;init函数中，id是强制的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;mode指定引脚模式，有IN，OUT，OPEN_DRAIN，AF_OPEN_DRAIN四种模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pull指定引脚是否连接弱上拉电阻，有None，PULL_UP，PULL_DOWN三种模式&lt;br&gt;弱上拉指上拉电阻阻值较大，高电平很容易因为外部电流驱动而拉低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;drive具有不同的最大安全电流的限制，有DRIVE_0-3四种选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;alt为引脚的备用功能，仅对alt和alt_open_drain两种模式有效，有0-7八种选择&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;value函数中，如果不带参数，就是得到当前状态，如果在输出模式，需要带参数，变为设置电平&lt;/p&gt;
&lt;p&gt;配置在引脚的触发源处于活动状态时要调用中断处理程序，如果引脚模式为Pin.IN，可以使用irq函数，如果引脚模式为Pin.IN，可以使用Pin.IRQ_RISING，Pin.IRQ_FALLING，Pin.IRQ_ANY三种模式，分别对应上升沿，下降沿，任意电平变化触发中断。&lt;/p&gt;
</content>
        <category term="技术" />
        <category term="博客" />
        <category term="电赛" />
        <updated>2023-07-05T01:46:48.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/</id>
        <title>电赛学习笔记-机器视觉</title>
        <link rel="alternate" href="http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89/"/>
        <content type="html">&lt;h1 id=&#34;开发环境&#34;&gt;&lt;a href=&#34;#开发环境&#34; class=&#34;headerlink&#34; title=&#34;开发环境&#34;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;h2 id=&#34;安装opencv&#34;&gt;&lt;a href=&#34;#安装opencv&#34; class=&#34;headerlink&#34; title=&#34;安装opencv&#34;&gt;&lt;/a&gt;安装opencv&lt;/h2&gt;&lt;h2 id=&#34;开发板：STM32F407&#34;&gt;&lt;a href=&#34;#开发板：STM32F407&#34; class=&#34;headerlink&#34; title=&#34;开发板：STM32F407&#34;&gt;&lt;/a&gt;开发板：STM32F407&lt;/h2&gt;&lt;h2 id=&#34;IDE：STM32CubeIDE&#34;&gt;&lt;a href=&#34;#IDE：STM32CubeIDE&#34; class=&#34;headerlink&#34; title=&#34;IDE：STM32CubeIDE&#34;&gt;&lt;/a&gt;IDE：STM32CubeIDE&lt;/h2&gt;&lt;h2 id=&#34;配置过程&#34;&gt;&lt;a href=&#34;#配置过程&#34; class=&#34;headerlink&#34; title=&#34;配置过程&#34;&gt;&lt;/a&gt;配置过程&lt;/h2&gt;&lt;p&gt;配置工程ioc文件，配置好基础外设后，再packs中安装X-CUBE-AI组件包，在软件包外设中添加模型文件，设置压缩倍数，导入测试集验证准确率&lt;/p&gt;
&lt;h2 id=&#34;模型&#34;&gt;&lt;a href=&#34;#模型&#34; class=&#34;headerlink&#34; title=&#34;模型&#34;&gt;&lt;/a&gt;模型&lt;/h2&gt;&lt;h3 id=&#34;yolo&#34;&gt;&lt;a href=&#34;#yolo&#34; class=&#34;headerlink&#34; title=&#34;yolo&#34;&gt;&lt;/a&gt;yolo&lt;/h3&gt;&lt;p&gt;利用mobilenet yolo50k模型可以导入到单片机中，只需要较少内存即可实现实时运行，实现人脸识别的功能&lt;/p&gt;
&lt;h3 id=&#34;openmv&#34;&gt;&lt;a href=&#34;#openmv&#34; class=&#34;headerlink&#34; title=&#34;openmv&#34;&gt;&lt;/a&gt;openmv&lt;/h3&gt;&lt;h2 id=&#34;硬件&#34;&gt;&lt;a href=&#34;#硬件&#34; class=&#34;headerlink&#34; title=&#34;硬件&#34;&gt;&lt;/a&gt;硬件&lt;/h2&gt;&lt;p&gt;正点原子ov7725摄像头&lt;br&gt;yolo50k&lt;/p&gt;
&lt;h1 id=&#34;相关资料&#34;&gt;&lt;a href=&#34;#相关资料&#34; class=&#34;headerlink&#34; title=&#34;相关资料&#34;&gt;&lt;/a&gt;相关资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Bt411w77m/?share_source=copy_web&amp;vd_source=4ed5c2c0429d7681216f506ac1e74065&#34;&gt;稚晖君&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://github.com/dog-qiuqiu/MobileNet-Yolo&#34;&gt;yolo50k仓库&lt;/a&gt;&lt;br&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1FL411u72p/?share_source=copy_web&amp;vd_source=4ed5c2c0429d7681216f506ac1e74065&#34;&gt;实时运行案例&lt;/a&gt;&lt;/p&gt;
</content>
        <category term="技术" />
        <category term="博客" />
        <category term="电赛" />
        <updated>2023-05-14T09:04:31.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/</id>
        <title>电赛学习笔记-micropython</title>
        <link rel="alternate" href="http://example.com/2023/05/14/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-micropython/"/>
        <content type="html">&lt;h1 id=&#34;micropython简介&#34;&gt;&lt;a href=&#34;#micropython简介&#34; class=&#34;headerlink&#34; title=&#34;micropython简介&#34;&gt;&lt;/a&gt;micropython简介&lt;/h1&gt;&lt;p&gt;micropython是一个能够利用python进行单片机开发的固件，目前主要是在esp32平台上进行的开发&lt;/p&gt;
&lt;h1 id=&#34;micropython安装&#34;&gt;&lt;a href=&#34;#micropython安装&#34; class=&#34;headerlink&#34; title=&#34;micropython安装&#34;&gt;&lt;/a&gt;micropython安装&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在micropython官网找到对应的单片机的型号的固件文件（.bin），下载到对应位置&lt;/li&gt;
&lt;li&gt;pip install esptool&lt;/li&gt;
&lt;li&gt;连接esp32单片机，查看端口号&lt;/li&gt;
&lt;li&gt;根据micropython官网的指示，利用esptool.py文件，清除单片机flash，再部署固件到单片机。&lt;/li&gt;
&lt;li&gt;安装uPyCraft IDE，选择好开发板类型和端口号后，&lt;h1 id=&#34;micropython使用&#34;&gt;&lt;a href=&#34;#micropython使用&#34; class=&#34;headerlink&#34; title=&#34;micropython使用&#34;&gt;&lt;/a&gt;micropython使用&lt;/h1&gt;需要根据单片机自带的库函数，进行python文档的开发&lt;h1 id=&#34;micropython的优点&#34;&gt;&lt;a href=&#34;#micropython的优点&#34; class=&#34;headerlink&#34; title=&#34;micropython的优点&#34;&gt;&lt;/a&gt;micropython的优点&lt;/h1&gt;代码量少，配置简单&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="技术" />
        <category term="博客" />
        <category term="电赛" />
        <updated>2023-05-14T08:47:54.000Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</id>
        <title>电赛学习笔记（1）——stm32学习笔记</title>
        <link rel="alternate" href="http://example.com/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
        <content type="html">&lt;h1 id=&#34;stm32基础&#34;&gt;&lt;a href=&#34;#stm32基础&#34; class=&#34;headerlink&#34; title=&#34;stm32基础&#34;&gt;&lt;/a&gt;stm32基础&lt;/h1&gt;&lt;h2 id=&#34;关于stm32产品线&#34;&gt;&lt;a href=&#34;#关于stm32产品线&#34; class=&#34;headerlink&#34; title=&#34;关于stm32产品线&#34;&gt;&lt;/a&gt;关于stm32产品线&lt;/h2&gt;&lt;h3 id=&#34;stm32f1系列-cortex-m3&#34;&gt;&lt;a href=&#34;#stm32f1系列-cortex-m3&#34; class=&#34;headerlink&#34; title=&#34;stm32f1系列 cortex-m3&#34;&gt;&lt;/a&gt;stm32f1系列 cortex-m3&lt;/h3&gt;&lt;h3 id=&#34;stm32f4系列-cortex-m4&#34;&gt;&lt;a href=&#34;#stm32f4系列-cortex-m4&#34; class=&#34;headerlink&#34; title=&#34;stm32f4系列 cortex-m4&#34;&gt;&lt;/a&gt;stm32f4系列 cortex-m4&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内置了rgb lcd驱动&lt;/li&gt;
&lt;li&gt;加入了DSP与FPU模块&lt;h3 id=&#34;stm32f7系列-cortex-m7&#34;&gt;&lt;a href=&#34;#stm32f7系列-cortex-m7&#34; class=&#34;headerlink&#34; title=&#34;stm32f7系列 cortex-m7&#34;&gt;&lt;/a&gt;stm32f7系列 cortex-m7&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;高速内存得到应用 &lt;h2 id=&#34;寄存器编程&#34;&gt;&lt;a href=&#34;#寄存器编程&#34; class=&#34;headerlink&#34; title=&#34;寄存器编程&#34;&gt;&lt;/a&gt;寄存器编程&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键字volatile&lt;/strong&gt;需要在声明寄存器变量的时候添加，因为要防止编译器自行优化。&lt;/p&gt;
&lt;h2 id=&#34;HAL库&#34;&gt;&lt;a href=&#34;#HAL库&#34; class=&#34;headerlink&#34; title=&#34;HAL库&#34;&gt;&lt;/a&gt;HAL库&lt;/h2&gt;&lt;p&gt;硬件抽象层，可以将不同产品线的芯片的寄存器操作抽象为函数，方便移植&lt;br&gt;&lt;strong&gt;&lt;font color=&#34;red&#34;&gt;本笔记使用HAL库进行编程&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;相对的，HAL库会产生大量的判断来降低代码运行效率&lt;br&gt;但是，还有另一个Low Layer库（LL），这个库可以提高效率&lt;/p&gt;
&lt;h2 id=&#34;stm32cubeMX配置&#34;&gt;&lt;a href=&#34;#stm32cubeMX配置&#34; class=&#34;headerlink&#34; title=&#34;stm32cubeMX配置&#34;&gt;&lt;/a&gt;stm32cubeMX配置&lt;/h2&gt;&lt;h2 id=&#34;stm32计时器&#34;&gt;&lt;a href=&#34;#stm32计时器&#34; class=&#34;headerlink&#34; title=&#34;stm32计时器&#34;&gt;&lt;/a&gt;stm32计时器&lt;/h2&gt;&lt;h3 id=&#34;PWM调制输出&#34;&gt;&lt;a href=&#34;#PWM调制输出&#34; class=&#34;headerlink&#34; title=&#34;PWM调制输出&#34;&gt;&lt;/a&gt;PWM调制输出&lt;/h3&gt;&lt;h4 id=&#34;几个重要参数&#34;&gt;&lt;a href=&#34;#几个重要参数&#34; class=&#34;headerlink&#34; title=&#34;几个重要参数&#34;&gt;&lt;/a&gt;几个重要参数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;占空比：高电平占整个周期的比例&lt;/li&gt;
&lt;li&gt;频率：整个PWM周期的倒数&lt;/li&gt;
&lt;li&gt;分辨率：占空比变化步长 &lt;h4 id=&#34;PWM实现方法&#34;&gt;&lt;a href=&#34;#PWM实现方法&#34; class=&#34;headerlink&#34; title=&#34;PWM实现方法&#34;&gt;&lt;/a&gt;PWM实现方法&lt;/h4&gt;输出比较模式，依靠内部计数器cnt和ccr设置的数值的比较来进行输出电平的控制，常用的有匹配时电平翻转和PWM模式&lt;br&gt;PWM占空比：$$DutyCycle&amp;#x3D;\frac{CCR}{ARR}$$&lt;br&gt;PWM频率：$$Freq&amp;#x3D;\frac{F_{clk}}{ARR}$$&lt;br&gt;PWM分辨率：$$Resolution&amp;#x3D;\frac{ARR}{2^{n}}$$&lt;h4 id=&#34;高级定时器&#34;&gt;&lt;a href=&#34;#高级定时器&#34; class=&#34;headerlink&#34; title=&#34;高级定时器&#34;&gt;&lt;/a&gt;高级定时器&lt;/h4&gt;死区生成：可以避免推挽电路上下管同时打开导致短路&lt;h3 id=&#34;PWM控制电机&#34;&gt;&lt;a href=&#34;#PWM控制电机&#34; class=&#34;headerlink&#34; title=&#34;PWM控制电机&#34;&gt;&lt;/a&gt;PWM控制电机&lt;/h3&gt;舵机是根据pwm信号控制舵机转动角度的，内部有直流电机&lt;h4 id=&#34;电机驱动芯片&#34;&gt;&lt;a href=&#34;#电机驱动芯片&#34; class=&#34;headerlink&#34; title=&#34;电机驱动芯片&#34;&gt;&lt;/a&gt;电机驱动芯片&lt;/h4&gt;利用H桥，可以控制电机转动方向。四个开关管可以构成两个推挽电路，使得电机可以获得两个方向的电流。&lt;br&gt;电机需要的电源一般是大功率的，不能直接通过gpio驱动，因此可以通过让stlink的5v口接入电机驱动芯片来获得电源。但是注意，pwm信号的地应当和电机电源的地相连，否则会出现电平不稳定的情况。&lt;h3 id=&#34;PWM代码&#34;&gt;&lt;a href=&#34;#PWM代码&#34; class=&#34;headerlink&#34; title=&#34;PWM代码&#34;&gt;&lt;/a&gt;PWM代码&lt;/h3&gt;pwm的激活结构如下：&lt;br&gt;&lt;img src=&#34;/2023/05/11/%E7%94%B5%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/PWM_Structure.jpg&#34; alt=&#34;PWM_Structure&#34;&gt;&lt;/li&gt;
&lt;li&gt;RCC开启时钟&lt;/li&gt;
&lt;li&gt;配置时基单元&lt;/li&gt;
&lt;li&gt;配置输出比较单元&lt;/li&gt;
&lt;li&gt;配置GPIO，设置为复用推挽输出&lt;/li&gt;
&lt;li&gt;运行控制，启动计数器&lt;h4 id=&#34;TIM库函数&#34;&gt;&lt;a href=&#34;#TIM库函数&#34; class=&#34;headerlink&#34; title=&#34;TIM库函数&#34;&gt;&lt;/a&gt;TIM库函数&lt;/h4&gt;在hal库中，tim相关库函数在stm32f1xx_hal_tim.h文件中&lt;br&gt;其中有关输出比较的内容有：&lt;/li&gt;
&lt;li&gt;TIM_OC_InitTypeDef: 输出比较初始化结构体&lt;/li&gt;
&lt;li&gt;HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)：输出比较初始化函数&lt;/li&gt;
&lt;li&gt;HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef *sConfig, uint32_t Channel)：配置输出通道函数&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="技术" />
        <category term="博客" />
        <category term="电赛" />
        <updated>2023-05-11T08:19:20.000Z</updated>
    </entry>
</feed>
